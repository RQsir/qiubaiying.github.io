<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java API -- Date && SimpleDateFormat && Calendar]]></title>
    <url>%2F2019%2F04%2F29%2Fjava-API-Date-SimpleDateFormat-Calendar%2F</url>
    <content type="text"><![CDATA[java中有一种特殊的对象，我们平时都是通过字符串的形式使用它，但在底层却时不时涉及到一些数字运算；除此之外，我们对它的字符串输出形式，往往还是百般挑剔，猜猜它是谁？：-）没错，它就是java中的Date对象java API下为我们封装了有关时间和日期操作了相关函数，总结如下：Date类 – 日期获取的好帮手首先，学习一个类，大致分为以下几个步骤：看类所在package，如果在java.lang包下，则使用时可以省去导包操作。接着看类的说明，了解类的大致用途即可。查看类的构造函数查看类的常用成员方法好，我们按照上述步骤，来学习一下Date。所在package由package java.util;可知，Date包位于java.util包下，所有使用时需要导包。类的介绍查看源码注释123456789101112131415/** * The class &lt;code&gt;Date&lt;/code&gt; represents a specific instant * in time, with millisecond precision. * &lt;p&gt; * Prior to JDK&amp;nbsp;1.1, the class &lt;code&gt;Date&lt;/code&gt; had two additional * functions. It allowed the interpretation of dates as year, month, day, hour, * minute, and second values. It also allowed the formatting and parsing * of date strings. Unfortunately, the API for these functions was not * amenable to internationalization. As of JDK&amp;nbsp;1.1, the * &lt;code&gt;Calendar&lt;/code&gt; class should be used to convert between dates and time * fields and the &lt;code&gt;DateFormat&lt;/code&gt; class should be used to format and * parse date strings. * The corresponding methods in &lt;code&gt;Date&lt;/code&gt; are deprecated. * &lt;p&gt; */首先，它告诉我们：Date是用来表示一个以毫秒为单位的确定时刻的类。Date可以表征“年”、“月”、“日”、“时”、“分”和“秒”。构造方法由于一些方法已经过时，这里我们只提及两个常用的构造方法。1234567891011121314151617181920212223/** * Allocates a &lt;code&gt;Date&lt;/code&gt; object and initializes it so that * it represents the time at which it was allocated, measured to the * nearest millisecond. * * @see java.lang.System#currentTimeMillis() */ public Date() &#123; this(System.currentTimeMillis()); &#125;/** * Allocates a &lt;code&gt;Date&lt;/code&gt; object and initializes it to * represent the specified number of milliseconds since the * standard base time known as "the epoch", namely January 1, * 1970, 00:00:00 GMT. * * @param date the milliseconds since January 1, 1970, 00:00:00 GMT. * @see java.lang.System#currentTimeMillis() */ public Date(long date) &#123; fastTime = date; // fastTime 是成员变量 &#125;空参构造方法Date()用来初始化一个Date对象，其时间基准线为jvm运行环境的当前时间，也就是说这个Date对象的时间值与当前时间一致。有参构造方法Date(long date)用来初始化一个相对时间基准线，时间值为long date的Date对象。其中，时间基准线为1970-1-1 00:00:00，俗称“计算机元年”。举个例子，Date(1000)代表的是1970-1-1 00:00:01这个时刻。常用成员方法这里我们介绍两个常用成员函数setTime()和getTime()：12345678910111213141516171819202122232425262728/** * Sets this &lt;code&gt;Date&lt;/code&gt; object to represent a point in time that is * &lt;code&gt;time&lt;/code&gt; milliseconds after January 1, 1970 00:00:00 GMT. * * @param time the number of milliseconds. */ public void setTime(long time) &#123; fastTime = time; cdate = null; &#125;/** * Returns the number of milliseconds since January 1, 1970, 00:00:00 GMT * represented by this &lt;tt&gt;Date&lt;/tt&gt; object. * * @return the number of milliseconds since January 1, 1970, 00:00:00 GMT * represented by this date. */ public long getTime() &#123; return getTimeImpl(); &#125; private final long getTimeImpl() &#123; if (cdate != null &amp;&amp; !cdate.isNormalized()) &#123; normalize(); &#125; return fastTime; &#125;其中setTime(long time)用来设置时间，参数time为相对于“1970-1-1 00:00:00”的时间值，单位为毫秒。而getTime()代表的是当前时间的毫秒值，同样是相对于“1970-1-1 00:00:00”。SimpleDateFormat类 – 日期格式化&amp;解析神器所在包SimpleDateFormat位于包java.text下，使用前需要导包。类概述123456/** * &lt;code&gt;SimpleDateFormat&lt;/code&gt; is a concrete class for formatting and * parsing dates in a locale-sensitive manner. It allows for formatting * (date &amp;rarr; text), parsing (text &amp;rarr; date), and normalization. * * &lt;p&gt;大意是说：SimpleDateFormat是一个用来格式化Date（输入为Date，输出为String），以及解析Date字符串（输入为String，输出为Date）的具体类。SimpleDateFormat特色是支持用户自定义格式，格式化Date。构造方法这里我们主要讲解两个常用构造方法，分别是：空参构造方法SimpleDateFormat()，以及有参构造方法SimpleDateFormat(String)。下面是它们的jdk源码：123456789101112131415161718192021222324252627282930313233/** * Constructs a &lt;code&gt;SimpleDateFormat&lt;/code&gt; using the default pattern and * date format symbols for the default * &#123;@link java.util.Locale.Category#FORMAT FORMAT&#125; locale. * &lt;b&gt;Note:&lt;/b&gt; This constructor may not support all locales. * For full coverage, use the factory methods in the &#123;@link DateFormat&#125; * class. */ public SimpleDateFormat() &#123; this("", Locale.getDefault(Locale.Category.FORMAT)); applyPatternImpl(LocaleProviderAdapter.getResourceBundleBased().getLocaleResources(locale).getDateTimePattern(SHORT, SHORT, calendar)); &#125;/** * Constructs a &lt;code&gt;SimpleDateFormat&lt;/code&gt; using the given pattern and * the default date format symbols for the default * &#123;@link java.util.Locale.Category#FORMAT FORMAT&#125; locale. * &lt;b&gt;Note:&lt;/b&gt; This constructor may not support all locales. * For full coverage, use the factory methods in the &#123;@link DateFormat&#125; * class. * &lt;p&gt;This is equivalent to calling * &#123;@link #SimpleDateFormat(String, Locale) * SimpleDateFormat(pattern, Locale.getDefault(Locale.Category.FORMAT))&#125;. * * @see java.util.Locale#getDefault(java.util.Locale.Category) * @see java.util.Locale.Category#FORMAT * @param pattern the pattern describing the date and time format * @exception NullPointerException if the given pattern is null * @exception IllegalArgumentException if the given pattern is invalid */ public SimpleDateFormat(String pattern) &#123; this(pattern, Locale.getDefault(Locale.Category.FORMAT)); &#125;其中，空参构造方法SimpleDateFormat()是以默认格式Sun Apr 28 20:45:54 CST 2019构造SimpleDateFormat对象，在之后的format过程中，会以这个格式来生成对应的字符串。而有参构造方法SimpleDateFormat(String)，则是用给定的格式（如：yyyy:MM:dd HH:mm:ss）来生成对应SimpleDateFormat对象，在之后的format过程中，会以这个格式来生成对应的字符串。常用成员方法这里要注意一下，我们一般不怎么使用SimpleDateFormat自己特有的成员方法；相反，我们比较爱用其继承于父类DateFormat的方法formate(Date)和parse(String)。相关源码如下：123456789101112131415161718192021222324252627282930313233/** * Formats a Date into a date/time string. * @param date the time value to be formatted into a time string. * @return the formatted time string. */ public final String format(Date date) &#123; return format(date, new StringBuffer(), DontCareFieldPosition.INSTANCE).toString(); &#125; /** * Parses text from the beginning of the given string to produce a date. * The method may not use the entire text of the given string. * &lt;p&gt; * See the &#123;@link #parse(String, ParsePosition)&#125; method for more information * on date parsing. * * @param source A &lt;code&gt;String&lt;/code&gt; whose beginning should be parsed. * @return A &lt;code&gt;Date&lt;/code&gt; parsed from the string. * @exception ParseException if the beginning of the specified string * cannot be parsed. */ public Date parse(String source) throws ParseException &#123; ParsePosition pos = new ParsePosition(0); Date result = parse(source, pos); if (pos.index == 0) throw new ParseException("Unparseable date: \"" + source + "\"" , pos.errorIndex); return result; &#125;从以上代码可知，方法format主要完成了Date对象到指定格式字符串的转换；而parse方法主要完成了String对象到Date对象的转化。Calendar类 – 日期操作的手术刀所在包位于java.util包下，使用前需执行导包操作。类简述见看一段jdk英文注解：123456789/** * The &lt;code&gt;Calendar&lt;/code&gt; class is an abstract class that provides methods * for converting between a specific instant in time and a set of &#123;@link * #fields calendar fields&#125; such as &lt;code&gt;YEAR&lt;/code&gt;, &lt;code&gt;MONTH&lt;/code&gt;, * &lt;code&gt;DAY_OF_MONTH&lt;/code&gt;, &lt;code&gt;HOUR&lt;/code&gt;, and so on, and for * manipulating the calendar fields, such as getting the date of the next * week. An instant in time can be represented by a millisecond value that is * an offset from the &lt;a name="Epoch"&gt;&lt;em&gt;Epoch&lt;/em&gt;&lt;/a&gt;, January 1, 1970 * 00:00:00.000 GMT (Gregorian).翻译过来，大致意思就是：Calendar是一个在“年”、“月”、“日”、“时”等日历属性，以及时间点（以毫秒为单位）之间进行转化的一个工具类。它可以对“年”、“月”、“日”、“时”等日历属性进行相关算术运算，最终反应在Date中的就是属性值fastTime的变化（即毫秒值的变化）。构造方法Calendar构造函数有两个，分别为Calendar()以及Calendar(TimeZone zone, Locale aLocale)，但平时使用中我们基本不用。实例化Calendar类，我们一般选择使用ta的静态成员方法getInstance()，实例化的是其子类对象。原因是：我们使用的某些成员方法如add(int, int)，它的实现是在Calendar的子类中完成的，这里用到了多态的向上转型。相应源码如下：123456789101112/** * Gets a calendar using the default time zone and locale. The * &lt;code&gt;Calendar&lt;/code&gt; returned is based on the current time * in the default time zone with the default * &#123;@link Locale.Category#FORMAT FORMAT&#125; locale. * * @return a Calendar. */ public static Calendar getInstance() &#123; return createCalendar(TimeZone.getDefault(), Locale.getDefault(Locale.Category.FORMAT)); &#125;需要注意的是：通过getInstance()方法获取的Calendar子类对象，其时间值是相对“计算机元年”而言的。常用成员方法这里，我们主要讲解“查询”、“设置”、“修改”calendar指定字段(filed)的成员方法。它们分别对应为：get(int)方法、set(int,int)方法、add(int,int)方法。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 /** * Returns the value of the given calendar field. In lenient mode, * all calendar fields are normalized. In non-lenient mode, all * calendar fields are validated and this method throws an * exception if any calendar fields have out-of-range values. The * normalization and validation are handled by the * &#123;@link #complete()&#125; method, which process is calendar * system dependent. * * @param field the given calendar field. * @return the value for the given calendar field. * @throws ArrayIndexOutOfBoundsException if the specified field is out of range * (&lt;code&gt;field &amp;lt; 0 || field &amp;gt;= FIELD_COUNT&lt;/code&gt;). * @see #set(int,int) * @see #complete() */ public int get(int field) &#123; complete(); return internalGet(field); &#125;/** * Sets the given calendar field to the given value. The value is not * interpreted by this method regardless of the leniency mode. * * @param field the given calendar field. * @param value the value to be set for the given calendar field. * @throws ArrayIndexOutOfBoundsException if the specified field is out of range * (&lt;code&gt;field &amp;lt; 0 || field &amp;gt;= FIELD_COUNT&lt;/code&gt;). * in non-lenient mode. * @see #set(int,int,int) * @see #set(int,int,int,int,int) * @see #set(int,int,int,int,int,int) * @see #get(int) */ public void set(int field, int value) &#123; // If the fields are partially normalized, calculate all the // fields before changing any fields. if (areFieldsSet &amp;&amp; !areAllFieldsSet) &#123; computeFields(); &#125; internalSet(field, value); isTimeSet = false; areFieldsSet = false; isSet[field] = true; stamp[field] = nextStamp++; if (nextStamp == Integer.MAX_VALUE) &#123; adjustStamp(); &#125; &#125; /** * Adds or subtracts the specified amount of time to the given calendar field, * based on the calendar's rules. For example, to subtract 5 days from * the current time of the calendar, you can achieve it by calling: * &lt;p&gt;&lt;code&gt;add(Calendar.DAY_OF_MONTH, -5)&lt;/code&gt;. * * @param field the calendar field. * @param amount the amount of date or time to be added to the field. * @see #roll(int,int) * @see #set(int,int) */ abstract public void add(int field, int amount);先说get(int)方法，这个方法主要通过指定int型字段来获取相应字段的整数型值。例如，get(Calendar.YEAR)返回的就是当前系统的年份值。常用的字段总结如下：字段名含义YEAR年份MONTH月份DAY_OF_MONTH月份中的日子HOUR_OF_DAY一天中的小时MINUTE小时中的分钟SECOND分钟中的秒接着谈谈set(int field, int value)方法，这个方法是给指定字段设置给定值。例如，我们可以将月份设置为一月，即set(Calendar.MONTH, Calendar.JANUARY)或者set(Calendar.MONTH, 0)（因为这里采用的是格里高利纪年法，0表示一月）。最后轮到add(int field, int amount)了，这个方法和set(int ,int )方法的区别有点类似“绝对路径”和“相对路径”的关系。add方法更加偏向于通过运算（相对与当前字段而言）来更改字段值。举个栗子：如果当前月份是二月，我们向将其改为三月，可以这样add(Calendar.MONTH, 1)；如果我们想将其改为一月，可以这样add(Calendar.MONTH, -1)。]]></content>
      <categories>
        <category>java-se</category>
      </categories>
      <tags>
        <tag>java - Date</tag>
        <tag>java - SimpleDateFormat</tag>
        <tag>java - Calendar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中根类Object的常用方法]]></title>
    <url>%2F2019%2F04%2F29%2Fjava%E4%B8%AD%E6%A0%B9%E7%B1%BBObject%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Object类，一般我们习惯称之为超类或根父类，这代表了它至高无上的低位。它是所有类的父类，它当中的一些属性将被所有类继承。这里我主要总结了toString()、equals()以及hashCode()这3个方法。toString()方法这里首先引入一段jdk源码：123456789101112131415161718192021222324/** * Returns a string representation of the object. In general, the * &#123;@code toString&#125; method returns a string that * "textually represents" this object. The result should * be a concise but informative representation that is easy for a * person to read. * It is recommended that all subclasses override this method. * &lt;p&gt; * The &#123;@code toString&#125; method for class &#123;@code Object&#125; * returns a string consisting of the name of the class of which the * object is an instance, the at-sign character `&#123;@code @&#125;', and * the unsigned hexadecimal representation of the hash code of the * object. In other words, this method returns a string equal to the * value of: * &lt;blockquote&gt; * &lt;pre&gt; * getClass().getName() + '@' + Integer.toHexString(hashCode()) * &lt;/pre&gt;&lt;/blockquote&gt; * * @return a string representation of the object. */ public String toString() &#123; return getClass().getName() + "@" + Integer.toHexString(hashCode()); &#125;这个方法主要完成Object对象的文本化输出。输出内容由getClass().getName()和Integer.toHexString(hashCode())两部分组成。第一部分是：对象所属的包名加类名，第二个部分是：对象地址的hash表示。在实际的开发中，我们一般会通过IDE自动重写该方法。equals()方法二话不说，上jdk源码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Indicates whether some other object is "equal to" this one. * &lt;p&gt; * The &#123;@code equals&#125; method implements an equivalence relation * on non-null object references: * &lt;ul&gt; * &lt;li&gt;It is &lt;i&gt;reflexive&lt;/i&gt;: for any non-null reference value * &#123;@code x&#125;, &#123;@code x.equals(x)&#125; should return * &#123;@code true&#125;. * &lt;li&gt;It is &lt;i&gt;symmetric&lt;/i&gt;: for any non-null reference values * &#123;@code x&#125; and &#123;@code y&#125;, &#123;@code x.equals(y)&#125; * should return &#123;@code true&#125; if and only if * &#123;@code y.equals(x)&#125; returns &#123;@code true&#125;. * &lt;li&gt;It is &lt;i&gt;transitive&lt;/i&gt;: for any non-null reference values * &#123;@code x&#125;, &#123;@code y&#125;, and &#123;@code z&#125;, if * &#123;@code x.equals(y)&#125; returns &#123;@code true&#125; and * &#123;@code y.equals(z)&#125; returns &#123;@code true&#125;, then * &#123;@code x.equals(z)&#125; should return &#123;@code true&#125;. * &lt;li&gt;It is &lt;i&gt;consistent&lt;/i&gt;: for any non-null reference values * &#123;@code x&#125; and &#123;@code y&#125;, multiple invocations of * &#123;@code x.equals(y)&#125; consistently return &#123;@code true&#125; * or consistently return &#123;@code false&#125;, provided no * information used in &#123;@code equals&#125; comparisons on the * objects is modified. * &lt;li&gt;For any non-null reference value &#123;@code x&#125;, * &#123;@code x.equals(null)&#125; should return &#123;@code false&#125;. * &lt;/ul&gt; * &lt;p&gt; * The &#123;@code equals&#125; method for class &#123;@code Object&#125; implements * the most discriminating possible equivalence relation on objects; * that is, for any non-null reference values &#123;@code x&#125; and * &#123;@code y&#125;, this method returns &#123;@code true&#125; if and only * if &#123;@code x&#125; and &#123;@code y&#125; refer to the same object * (&#123;@code x == y&#125; has the value &#123;@code true&#125;). * &lt;p&gt; * Note that it is generally necessary to override the &#123;@code hashCode&#125; * method whenever this method is overridden, so as to maintain the * general contract for the &#123;@code hashCode&#125; method, which states * that equal objects must have equal hash codes. * * @param obj the reference object with which to compare. * @return &#123;@code true&#125; if this object is the same as the obj * argument; &#123;@code false&#125; otherwise. * @see #hashCode() * @see java.util.HashMap */ public boolean equals(Object obj) &#123; return (this == obj); &#125;如注释所述，equals方法主要用于判断非空对象与另一给定对象，是否为同一对象（在堆内存中位于同一地址空间）。在实际开发中，我们一般会选择重写该方法去完成更具体的功能。例如，在jdk中的String类中，就重写了equals方法，去判断两个字符串是否相等。hashCode()方法jdk源码如下：123456789101112131415161718192021222324252627282930313233343536/** * Returns a hash code value for the object. This method is * supported for the benefit of hash tables such as those provided by * &#123;@link java.util.HashMap&#125;. * &lt;p&gt; * The general contract of &#123;@code hashCode&#125; is: * &lt;ul&gt; * &lt;li&gt;Whenever it is invoked on the same object more than once during * an execution of a Java application, the &#123;@code hashCode&#125; method * must consistently return the same integer, provided no information * used in &#123;@code equals&#125; comparisons on the object is modified. * This integer need not remain consistent from one execution of an * application to another execution of the same application. * &lt;li&gt;If two objects are equal according to the &#123;@code equals(Object)&#125; * method, then calling the &#123;@code hashCode&#125; method on each of * the two objects must produce the same integer result. * &lt;li&gt;It is &lt;em&gt;not&lt;/em&gt; required that if two objects are unequal * according to the &#123;@link java.lang.Object#equals(java.lang.Object)&#125; * method, then calling the &#123;@code hashCode&#125; method on each of the * two objects must produce distinct integer results. However, the * programmer should be aware that producing distinct integer results * for unequal objects may improve the performance of hash tables. * &lt;/ul&gt; * &lt;p&gt; * As much as is reasonably practical, the hashCode method defined by * class &#123;@code Object&#125; does return distinct integers for distinct * objects. (This is typically implemented by converting the internal * address of the object into an integer, but this implementation * technique is not required by the * Java&amp;trade; programming language.) * * @return a hash code value for this object. * @see java.lang.Object#equals(java.lang.Object) * @see java.lang.System#identityHashCode */ public native int hashCode();hashCode方法，返回的是对象在内存中地址的hash编码。这在HashTable中会用到，主要是用作对象存储的index使用。]]></content>
      <categories>
        <category>java-se</category>
      </categories>
      <tags>
        <tag>java - Object</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java API -- System类]]></title>
    <url>%2F2019%2F04%2F29%2Fjava-API-System%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[System类是我们一开始学习java就接触到的一个常用类，在这个类中封装了许多和系统底层有关的方法供我们调用。所属包首先，查看jdk我们可以知道，System类是位于java.lang包下的。因此，是无需导包就能直接使用的。类描述我们先看一段官方注解：12345678910111213/** * The &lt;code&gt;System&lt;/code&gt; class contains several useful class fields * and methods. It cannot be instantiated. * * &lt;p&gt;Among the facilities provided by the &lt;code&gt;System&lt;/code&gt; class * are standard input, standard output, and error output streams; * access to externally defined properties and environment * variables; a means of loading files and libraries; and a utility * method for quickly copying a portion of an array. * * @author unascribed * @since JDK1.0 */大意就是，System这个类一个基础工具类，它无法被实例化。它主要用于标准输入、输出流的控制，以及数组的操作等。构造函数123/** Don't let anyone instantiate this class */ private System() &#123; &#125;由于构造函数的私有属性，因此System类是无法实例化的。常用成员方法输出方法这里介绍两个方法，分别是：System.out.println()以及System.err.println()。实际上，这两个方法都是通过System内的静态不可变成员变量out或err，并且它们都是PrintStream类的的对象引用，然后通过对象调用类中方法。数组操作方法12345678910111213141516* @param src the source array. * @param srcPos starting position in the source array. * @param dest the destination array. * @param destPos starting position in the destination data. * @param length the number of array elements to be copied. * @exception IndexOutOfBoundsException if copying would cause * access of data outside array bounds. * @exception ArrayStoreException if an element in the &lt;code&gt;src&lt;/code&gt; * array could not be stored into the &lt;code&gt;dest&lt;/code&gt; array * because of a type mismatch. * @exception NullPointerException if either &lt;code&gt;src&lt;/code&gt; or * &lt;code&gt;dest&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;. */ public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length);从源数组src向目的数组dest，复制给定长度length的数据。退出jvm方法1234567891011121314151617181920212223/** * Terminates the currently running Java Virtual Machine. The * argument serves as a status code; by convention, a nonzero status * code indicates abnormal termination. * &lt;p&gt; * This method calls the &lt;code&gt;exit&lt;/code&gt; method in class * &lt;code&gt;Runtime&lt;/code&gt;. This method never returns normally. * &lt;p&gt; * The call &lt;code&gt;System.exit(n)&lt;/code&gt; is effectively equivalent to * the call: * &lt;blockquote&gt;&lt;pre&gt; * Runtime.getRuntime().exit(n) * &lt;/pre&gt;&lt;/blockquote&gt; * * @param status exit status. * @throws SecurityException * if a security manager exists and its &lt;code&gt;checkExit&lt;/code&gt; * method doesn't allow exit with the specified status. * @see java.lang.Runtime#exit(int) */ public static void exit(int status) &#123; Runtime.getRuntime().exit(status); &#125;方法描述为：终止正在运行的jvm，并返回一个状态码。依照惯例：返回‘0’，代表正常退出 ；其他值，代表异常退出。垃圾回收方法123456789101112131415161718192021/** * Runs the garbage collector. * &lt;p&gt; * Calling the &lt;code&gt;gc&lt;/code&gt; method suggests that the Java Virtual * Machine expend effort toward recycling unused objects in order to * make the memory they currently occupy available for quick reuse. * When control returns from the method call, the Java Virtual * Machine has made a best effort to reclaim space from all discarded * objects. * &lt;p&gt; * The call &lt;code&gt;System.gc()&lt;/code&gt; is effectively equivalent to the * call: * &lt;blockquote&gt;&lt;pre&gt; * Runtime.getRuntime().gc() * &lt;/pre&gt;&lt;/blockquote&gt; * * @see java.lang.Runtime#gc() */ public static void gc() &#123; Runtime.getRuntime().gc(); &#125;调用jvm的垃圾回收机制，去尽可能的回收系统资源。一般与Object类的finalize()方法配套使用1234567/** * Called by the garbage collector on an object when garbage collection * determines that there are no more references to the object. * A subclass overrides the &#123;@code finalize&#125; method to dispose of * system resources or to perform other cleanup. * &lt;p&gt; protected void finalize() throws Throwable &#123; &#125;流程是：12345678910111213public class Test&#123; public static void main(String[] args)&#123; new Student(); //创建匿名对象，方便gc回收 System.gc(); //调用jvm回收机制 &#125;&#125;class Student&#123; @override void finalize()&#123; System.out.println("在这里完成一些收尾工作"); &#125;&#125;运行结果是：可能打印出“在这里完成一些收尾工作”。因为gc不能保证每次都能回收Student资源（the Java Virtual Machine has made a best effort to reclaim space from all discarded）。]]></content>
      <categories>
        <category>java-se</category>
      </categories>
      <tags>
        <tag>java - System</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java -- 多态]]></title>
    <url>%2F2019%2F04%2F26%2Fjava-%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[基本概念多态的前提：存在子父类继承关系（或子类和父类接口实现关系）存在方法重写父类（或父接口）引用指向子类对象动态绑定：​ 运行期间调用的方法，是根据具体的类型决定的。多态的成员特点成员分类特点成员变量编译时看的是左边，运行时看的是左边成员方法编译时看的是左边，运行时看的是右边（动态绑定）静态成员方法编译时看的是左边，运行时看的也是左边举例说明先定义父类和子类1234567891011121314151617181920212223class Dad &#123; int num = 20; public void method() &#123; System.out.println("我是父类方法"); &#125; public static void function() &#123; System.out.println("我是父类静态方法"); &#125;&#125;class Kid extends Dad &#123; int num = 10; public void method() &#123; System.out.println("我是子类方法"); &#125; public static void function() &#123; System.out.println("我是子类静态方法"); &#125;&#125;1 对于成员变量12345678910public class PoymorphicDemo &#123; public static void main(String[] args) &#123; Dad d = new Kid(); //d.num 编译时，首先会查看父类Dad中是否存在num成员变量，如不存在，则会报错，这就是“编译看左边” System.out.println(d.num); &#125;&#125;//输出 20//这就说明最后输出的是父类Dad中的成员变量，即所谓“运行看左边”2 对于成员方法1234567891011public class PoymorphicDemo2 &#123; public static void main(String[] args) &#123; Dad d = new Kid();//d.method()编译时，首先会查看父类Dad中是否存在method成员方法，不存在，就会报错，即“编译看左边” d.method(); &#125;&#125;//输出 我是子类方法//最后执行的是子类成员方法，即所谓的“运行看右边”，这里涉及运行期间的编译器“动态绑定”3 对于静态成员方法与成员变量类似，这里不在赘述。多态中的向上转型和向下转型本质上属于引用数据类型的转型问题。可以和基本数据类型转型进行对比基本数据类型引用数据类型自然转型小存储空间向大存储空间转型子类向父类转型（向上转型）强制转型大存储空间向小存储空间转型父类向子类转型（向下转型）说明：向上转型，只能调用父类中存在并被重写的方法；向下转型，可以调用子类中特有的方法多态的优缺点优点：由于多态基于继承和接口，故继承和接口所具有的优点，它都具有（如减少代码冗余，可维护，模块化编程等）缺点：无法访问子类特有成员]]></content>
      <categories>
        <category>java-se</category>
      </categories>
      <tags>
        <tag>java多态</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java -- 修饰符总结]]></title>
    <url>%2F2019%2F04%2F26%2Fjava-%E4%BF%AE%E9%A5%B0%E7%AC%A6%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[权限修饰符public：所有类都可以访问private：当前类可以访问default（默认，什么都不写）：同一包下，可以访问protected：子类可以访问修饰符总结修饰符类成员变量成员方法构造方法publicYYYYdefaultYYYYprotectedYYYprivateYYYabstractYYstaticYYfinalYYY修饰符使用常用规则：一般使用public修饰类，一个java文件中最好只有一个类。如果一个文件中有多个类，类名和文件名相同的类，必须用public修饰；其余类不能用public修饰。一般用private修饰成员变量，并提供相应的get、set方法一般用public修饰成员方法，除非那些你不想让人调用的方法，可以用private修饰。一般用public修饰构造方法，除非你不想让别人实例化这个类，可以用private修饰。]]></content>
      <categories>
        <category>java-se</category>
      </categories>
      <tags>
        <tag>java修饰符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中的接口 && 匿名对象]]></title>
    <url>%2F2019%2F04%2F26%2Fjava%E4%B8%AD%E7%9A%84%E6%8E%A5%E5%8F%A3-%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[java中的接口接口是为了解决java中继承的单一局限性，而提出来的。接口是一个比抽象类还要抽象的类，其中所有成员方法都是抽象方法，类通过关键字implements来实现接口接口可以看做是拓展类的各种功能的一个全抽象父类，它可以实现针对不同功能，开发不同接口，最后再将接口合并，实现了模块化独立编程的目的。接口的成员特点成员分类特点成员方法全部为抽象方法默认使用public abstract修饰只能使用public abstract修饰成员变量默认使用public static final修饰，相当于常量构造方法没有构造方法，因为不需要初始化成员变量注意：接口不能实例化，实现接口需重写其中所有方法接口与类之间的关系分类关系类与类继承关系，单一继承，多层继承类与接口实现关系，可以一对多，一个类实现多个接口接口与接口继承关系，单一继承，多层继承类与接口的综合举例匿名对象匿名对象：没有名字的对象。应用场景：当方法只调用一次时，可以使用匿名对象可以当作参数传递，但是无法在传参之前做其他事。注意：匿名对象可以调用成员变量进行赋值，但由于无法在后续操作中使用，所有没有意义]]></content>
      <categories>
        <category>java-se</category>
      </categories>
      <tags>
        <tag>java匿名对象</tag>
        <tag>java接口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中的静态 && 代码块]]></title>
    <url>%2F2019%2F04%2F25%2Fjava%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81-%E4%BB%A3%E7%A0%81%E5%9D%97%2F</url>
    <content type="text"><![CDATA[java中的静态修饰符修饰符static： 是一个关键字，用于修饰成员变量和成员方法特点被所有对象共享可以使用类名调用静态加载优先于对象随着类的加载而加载注意事项静态方法静态方法只可以调用静态的成员（包括方法和变量）非静态方法既可以调用非静态方法和变量，也可以调用静态的方法和变量由于静态方法优先于对象创建，故静态方法中没有this对象使用场景static常用来修饰工具类中的方法和变量，例如JDK中Math工具类等。java中的代码块基本概念形式如下：12345&#123; System.out.println("这是一个java代码块"); ......&#125;分类：局部代码块和局部变量类似，出现在方法内部，主要用于限制变量和方法的作用域，即代码块外不能访问代码块中的变量和方法构造代码块和类中的构造方法类似，出现在类内部，用来存放基于类的所有对象的公共代码部分，可以降低代码冗余度，会随着对象的创建自动调用静态代码块和静态方法类似，出现在类内部，用来存放类中需要初始化的一些代码（如驱动），随着类的加载而加载，并且自动调用同步代码块用于不同线程间的同步问题一个static和代码块的面试题123456789101112131415161718192021222324252627282930313233343536public class BlockTest &#123; static &#123; System.out.println("BlockTest静态代码块执行"); &#125; &#123; System.out.println("BlockTest构造代码块执行"); &#125; public BlockTest()&#123; System.out.println("BlockTest无参构造执行了"); &#125; public static void main(String[] args) &#123; System.out.println("BlockTest的主函数执行了"); Coder c = new Coder(); Coder c2 = new Coder(); &#125;&#125;class Coder &#123; static &#123; System.out.println("Coder静态代码块执行"); &#125; &#123; System.out.println("Coder构造代码块执行"); &#125; public Coder() &#123; System.out.println("Coder无参空构造执行"); &#125;&#125;问题：代码如上，请写出程序的执行顺序分析如下：​ 首先，程序启动，JVM会加载main函数所在类，即BlockTest这个类，这时候它的静态代码块随之加载并自动执行，打印&quot;BlockTest静态代码块执行&quot;。由于main的调用是基于类的加载，并未实例化BlockTest，故其局部代码块和构造方法都不会执行。​ 接着，调用main函数，打印&quot;BlockTest的主函数执行了&quot;。接着执行Coder c = new Coder()，会加载Coder类，调用其静态代码块，打印&quot;Coder静态代码块执行&quot;。随后，在生成c对象中，首先调用其类中代码块，打印&quot;Coder构造代码块执行&quot;，然后调用其构造方法，打印&quot;Coder无参空构造执行&quot;。​ 最后，执行Coder c2 = new Coder()，和上面类似。不同的是，这时Coder类已经加载，故不会再次调用其静态代码块。但再次生成了一个新的对象c2，因此会调用其类中代码块，打印&quot;Coder构造代码块执行&quot;，接着调用其构造方法，打印&quot;Coder无参空构造执行&quot;。​ 总结：整个程序的打印输出为：1234567BlockTest静态代码块执行BlockTest的主函数执行了Coder静态代码块执行Coder构造代码块执行Coder无参空构造执行Coder构造代码块执行Coder无参空构造执行]]></content>
      <categories>
        <category>java-se</category>
      </categories>
      <tags>
        <tag>java静态</tag>
        <tag>java代码块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中的继承 && abstract && final]]></title>
    <url>%2F2019%2F04%2F25%2Fjava%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF-abstract-final%2F</url>
    <content type="text"><![CDATA[java中的继承java中的继承问题分为两类：一是成员变量的继承；二是成员方法的继承。成员变量的继承特点​ 子类只能继承父类的非私有成员变量成员变量引用原则（就近原则）​ 变量名相同，引用顺序为：局部变量 -&gt; 子类成员变量 -&gt; 父类成员变量变量之间的区别调用​ this调用子类的成员变量，super调用父类的成员变量继承的优点​ 能够减少代码冗余，方便代码维护成员方法的继承特点子类只能继承父类的非私有成员方法子类重写方法的权限修饰符要大于等于其父类，即父类方法是默认权限修饰，则子类方法可以是默认修饰符或者public修饰符成员方法的调用原则（就近原则）​ 方法名相同，调用顺序为：子类方法 -&gt; 父类方法子父类方法之重写与重载方法重写：子类方法与父类方法，不仅方法名相同，而且参数列表相同，返回值也相同，基本上一模一样。只是方法执行代码不同。方法重载：两个方法方法名相同，而参数列表不同，这是函数的重载，要与成员函数的重写加以区分。this和super总结关键词含义应用场景this指向调用方法的当前对象1.调用子类的成员变量2.调用子类的成员方法3.在子类的构造函数的第一行调用子类的其他构造函数super指向当前对象的父类对象1.调用父类的成员变量2.调用父类的成员方法3.在子类的构造函数的第一行调用父类的构造函数java关键字之abstractabstract可以用来修饰类和方法，被修饰的类和方法分别被称之为“抽象类”和“抽象方法”概念解析​ 抽象类：只有含有抽象方法的类，肯定是抽象类；抽象类也可以没有抽象方法，不过这样就失去了抽象类的意义。另外，抽象类中可以含有非抽象方法。抽象类无法实例化，但这并不是因为抽象类没有构造方法，只是因为抽象类中存在抽象函数。​ 抽象方法：没有方法体，由关键词abstract修饰的方法叫做抽象方法。注意：一个类继承了抽象类，需要重写其中的所有抽象方法。否则，可以将其声明为抽象类抽象类的成员特点分类特点成员变量1. 可以有成员变量2. 可以有常量成员方法1.可以有抽象方法2.可以有非抽象方法构造方法有构造方法，需要对抽象类成员变量进行初始化构造方法会在对象实例化时，自动调用；如果调用失败，则实例化也失败。java关键字之finalfinal修饰的类，无法被继承final修饰的变量为常量，无法修改。且必须初始化，可以显示初始化（即声明时就初始化）或在构造函数初始化final修饰的成员方法，无法被重写类无法实例化的两种方法给类加上abstract关键字，使其成为抽象类。给类的构造函数加上private关键字，使其在new时，由于构造方法私有不可访问的特性，导致类实例化失败。]]></content>
      <categories>
        <category>java-se</category>
      </categories>
      <tags>
        <tag>java继承</tag>
        <tag>java - abstract</tag>
        <tag>java - fianl</tag>
        <tag>this &amp;&amp; super</tag>
        <tag>java中类无法实例化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java -- 文本文件读写]]></title>
    <url>%2F2019%2F04%2F24%2Fjava-%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%2F</url>
    <content type="text"><![CDATA[文本文件写操作基本流程1、创建FileWriter对象12345FileWriter fw = new FileWriter("~/a.txt"); //覆盖写入或FileWriter fw = new FileWriter("~/a.txt",true); //追加写入2、写入字符串及刷新缓冲区12fw.write("HelloWorld!");fw.flush();3、关闭IO，通知系统释放相关资源1fw.close();换行不同操作系统的换行转义字符存在差异，总结如下：系统换行转义字符windows\r\nmactintosh\rlinux\n文本文件读操作通过字符进行读取12345678910//1.创建FileReader对象FileReader fr = new FileReader("a.txt");//2.读取单个字符int c;//3.循环读取，结束标志为“-1”while (-1 != (c = fr.read()))&#123; System.out.print((char)c);&#125;通过字符数组读取123456789101112//1.创建FileReader对象FileReader fr = new FileReader("a.txt");//2.读取文件到字符数组char[] str = new char[1024];// len记录读取长度int len;//3.循环读取，结束标志为“-1”while ((len = fr.read(str)) != -1)&#123; System.out.print(str,0,len); // 这里必须指定str长度&#125;文本文件高效读写——BufferedReader &amp; BufferedWriter基本操作基本读写方法和流程相同，只不过构造函数略有差异1234567//BufferedReader构造函数BufferedReader br = new BufferedReader(new FileReader("a.txt"));//本质上是将字符暂存在输入流缓冲区，加快读取速率//BufferedWriter构造函数BufferedWriter bw = new BufferedWriter(new FileWriter("a.txt"));//本质上是将字符暂存在输出流缓冲区，加快写入速率特殊函数12345//BufferedWritervoid newLine(); //写一个换行符，由系统决定//BufferedReaderString readLine(); //读取并返回一行数据，不包括换行符，为空则返回NULL]]></content>
      <categories>
        <category>java-se</category>
      </categories>
      <tags>
        <tag>文本文件读写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中为何任何对象都可以和String进行拼接？]]></title>
    <url>%2F2019%2F04%2F24%2Fjava%E4%B8%AD%E4%B8%BA%E4%BD%95%E4%BB%BB%E4%BD%95%E5%AF%B9%E8%B1%A1%E9%83%BD%E5%8F%AF%E4%BB%A5%E5%92%8CString%E8%BF%9B%E8%A1%8C%E6%8B%BC%E6%8E%A5%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[问题引入在学习java-se中偶然对以下代码产生了兴趣，如下：1234 String s ="hello" + 123 + true + 1.32; System.out.println("拼接后的String为：" + s);//out:拼接后的String为：hello123true1.32由上可知，任何变量（不管是基本数据类型，还是引用数据类型）都可以自动向String进行转换，以完成最后的拼接。那么，这背后的操作是如何实现的呢？原理剖析引用数据类型向String的转换引用数据类型，也就是我们常说的类类型，在java中都共同拥有一个顶层父类Object，而在这个Object类中，我们可以发现这样一个方法toString()，其源码如下：123456789101112131415161718192021222324/** * Returns a string representation of the object. In general, the * &#123;@code toString&#125; method returns a string that * "textually represents" this object. The result should * be a concise but informative representation that is easy for a * person to read. * It is recommended that all subclasses override this method. * &lt;p&gt; * The &#123;@code toString&#125; method for class &#123;@code Object&#125; * returns a string consisting of the name of the class of which the * object is an instance, the at-sign character `&#123;@code @&#125;', and * the unsigned hexadecimal representation of the hash code of the * object. In other words, this method returns a string equal to the * value of: * &lt;blockquote&gt; * &lt;pre&gt; * getClass().getName() + '@' + Integer.toHexString(hashCode()) * &lt;/pre&gt;&lt;/blockquote&gt; * * @return a string representation of the object. */ public String toString() &#123; return getClass().getName() + "@" + Integer.toHexString(hashCode()); &#125;通过阅读方法注释，我们不难知道：这个方法是用来输出一个object对象的。所有Java类都是object类的子类，因此所有Java对象都具有toString方法。不仅如此，所有Java对象都可以和字符串进行连接运算，当Java对象和字符串进行连接运算时，系统自动调用Java对象toString()方法，返回值和字符串进行连接运算。基本数据类型向String的转换首先，我们知道在Java中，一切皆对象，但八大基本类型却不是对象。通过上述分析，我们可以解释对象通过toString()转换为字符串后与String对象完成拼接，那么基本数据类型又是如何完成这一过程的呢？要解释这一问题，就要涉及java中基本数据类型的自动装箱技术。所谓装箱，就是把基本类型用它们相对应的引用类型包起来，使它们可以具有对象的特质，如我们可以把int型包装成Integer类的对象，或者把double包装成Double，等等。J2SE5.0后提供了自动装箱与拆箱的功能，此功能事实上是编译器来帮您的忙，编译器在编译时期依您所编写的方法，决定是否进行装箱或拆箱动作。自动装箱的过程：每当需要一种类型的对象时，这种基本类型就自动地封装到与它相同类型的包装中。通过自动装箱，我们就可以很好的解释为什么基本数据类型int、float等能够完成向String的转换与拼接。整个过程就是，编译器检测到我们需要进行int与字符串的拼接，首先自动帮我们将int自动装箱成Integer对象，然后Integer对象调用自身的toString()方法转为字符串，最终完成拼接工作。参考文章Java 包装类 拆箱 装箱java打印对象和toString方法]]></content>
      <categories>
        <category>java-se</category>
      </categories>
      <tags>
        <tag>String拼接</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[成员变量 && 局部变量 && 构造方法 && 导包]]></title>
    <url>%2F2019%2F04%2F22%2F%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-%E5%AF%BC%E5%8C%85%2F</url>
    <content type="text"><![CDATA[java中的“成员变量”和“局部变量”成员变量局部变量声明位置不同在方法外在方法内或方法声明上（形参）存储空间不同在堆内存在栈内存生命周期不同随着对象的产生而产生，随着对象的销毁而销毁随着方法的产生而产生，随着方法的销毁而销毁初始化不同系统自动初始化（通过构造函数完成）手动初始化（不初始化会报错）java 中的构造方法java中的构造方法可以重载java中如果没有构造方法，编译器会自动补上无参构造方法；但一但编译器检测到有构造函数，则不会自动补上无参构造方法，如这时候再调用无参构造，则会报错，因此推荐手动书写无参构造方法。java中的导包属于java.lang包中的类，使用时无需导包，例如Object类、String类等。]]></content>
      <categories>
        <category>java-se</category>
      </categories>
      <tags>
        <tag>“成员变量”和“局部变量”</tag>
        <tag>构造方法</tag>
        <tag>导包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中数组是对象吗？]]></title>
    <url>%2F2019%2F04%2F22%2Fjava%E4%B8%AD%E6%95%B0%E7%BB%84%E6%98%AF%E5%AF%B9%E8%B1%A1%E5%90%97%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[最近在学习javaSE，其中印象最深的一句话便是“java中一切皆对象”；那么数组作为一种源自C语言的数据结构，在java中它也是对象吗？提出问题这个疑问主要源自对以下代码的疑问：12int[] arr = new int[3];int size = arr.length; #得到数组长度数组居然存在length这个属性，这很明显是对象才具有的特性。同时，数组也排除于8大基本数组类型之外，《java核心卷一》中对数组的定义是：一个数据容器，用来存储相同数据类型的数据集合。相应解释通过万能的Google，让我找到了一篇博文Java中数组的特性 ,恰到好处地诠释了这个问题，现总结如下：可以认定，java中的数组也是对象，它具有java中其他对象的一些基本特点：封装了一些数据，可以访问属性，也可以调用方法。所以，数组是对象。数组也是有类型的，例如int[]的类型是[I，String []的类型是[[Ljava.lang.String等。但是我们没有自己创建这个类，也没有在Java的标准库中找到这个类，这只能有一个解释，那就是虚拟机自动创建了数组类型数组的顶层父类为Object，虽然存在Object[] = 引用数据类型[]，这仅说明引用数据类型[]不继承自Object[]，但是我可以允许你向上转型到Object[]，这种特性是赋予你的一项特权。换一种思考方式，如果有两个类A和B，如果B继承（extends）了A，那么A[]类型的引用就可以指向B[]类型的对象。这种情况同样适用于多维数组，因为我们可以将n维数组看做一维数组中存放着(n-1)维数组几个易错点123456Object[] objArr = new int[3]; //错误因为int不是引用类型，Object不是int的父类，在这里自动装箱不起作用Object[] objArr2 = &#123;"aaa", 1, 2.5&#125;;//这种情况下自动装箱可以工作，也就是说，Object数组中可以存放任何值，包括基本数据类型。//这种特性主要是用于方法中多个参数的传递，方便方法内部访问或遍历数组中的各个元素]]></content>
      <categories>
        <category>java-se</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java内存管理 -- 栈 && 堆 && 方法区]]></title>
    <url>%2F2019%2F04%2F22%2Fjava%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E6%A0%88-%E5%A0%86-%E6%96%B9%E6%B3%95%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[“栈”——存储方法及其中的局部变量程序由数据和方法组成，而它们都可以用地址指代。栈便是存储这些地址的地方。栈中的内存是以方法为单位进行划分的，方法调用结束后，内存回收。我们在栈中调用某个方法，首先先开辟一块栈内存区，内存区的开头存储的是被调用方法地址，其他内存空间用于存储方法中的局部变量地址。然后cpu通过方法的地址，到方法区查找并执行对应代码。遇到变量，则存储在之前的栈内存中；遇到方法，则在栈中开辟新的内存空间。方法之间的调用是以“栈”的形式体现的，即“被调用”的方法，后入栈，先出栈。“堆”——存储New出来的对象由JVM的垃圾回收机制进行管理，空闲时回收“方法区”——存储方法代码在java中，方法区一般存储着class文件，而方法则包含在相应的class中举个栗子“堆”和“栈”的例子1int[] arr = new int[3];如上，我们声明并初始化了一个整型数组。其中整型数组 arr 就是“栈”变量，而 new int[3] 属于堆变量。“方法区”的例子如下图所示，当jvm调用方法时，无论是main方法还是change方法，其都是通过在方法区查找对应class文件中的对应方法，然后将对应代码加载到栈内存，最后由cpu去执行。]]></content>
      <categories>
        <category>java-se</category>
      </categories>
      <tags>
        <tag>java内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux -- 编译JDK源码]]></title>
    <url>%2F2019%2F04%2F19%2Flinux-%E7%BC%96%E8%AF%91JDK%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[获取JDK源码java 8 源代码地址：http://jdk.java.net/8/java 9 源代码地址：http://jdk.java.net/java-se-ri/9java 10 源代码地址：http://jdk.java.net/10/环境构建1 安装相关依赖123456#安装aptitude（在处理依赖问题上更佳。aptitude 在删除一个包时，会同时删除本身所依赖的包）sudo apt-get install aptitude#更新源信息sudo aptitude update#安装编译openjdk8所需依赖sudo aptitude install build-essential libx11-dev libxext-dev libxrender-dev libxtst-dev libxt-dev libcups2-dev libfreetype6-dev libasound2-dev ccache2 下载Bootstrap JDK一般选择落后一个大版本的JDK作为Bootstrap JDK，这里安装了OpenJDK 7。据说Ubuntu18.04已经去除了openJdk-7的源，所以本次进行了下载后手动安装：[openjdk-7-jdk](https://packages.debian.org/experimental/openjdk-7-jdk) [openjdk-7-jre](https://packages.debian.org/experimental/openjdk-7-jre) [openjdk-7-jre-headless](https://packages.debian.org/experimental/openjdk-7-jre-headless) [libjpeg62-turbo](https://packages.debian.org/sid/libjpeg62-turbo) [libfontconfig1](https://packages.debian.org/sid/libfontconfig1) [fontconfig-config](https://packages.debian.org/sid/fontconfig-config) 下载以上安装包，然后执行命令：sudo dpkg -i openjdk-7-* libjpeg62-turbo* libfontconfig1* fontconfig-config*如果在安装过程中报错，则执行以下命令：sudo apt --fix-broken install3 切换默认jdkupdate-alternatives是Debian系统中专门维护系统命令链接符的工具，通过它可以很方便的设置系统默认使用哪个命令、哪个软件版本，比如系统中同时安装了open jdk和sun jdk两个版本，而我们又希望系统默认使用sun jdk，通过update-alternatives就可以方便实现管理。通过sudo update-alternatives --config java进行java版本切换4 安装gcc-4.8 和g++ 4.8之前使用apt 默认安装了最新的gcc-7，导致jdk编译中语法大量报错，浪费了大量时间进行改错第一步：1$ sudo apt-get install gcc-4.8第二步：设置默认的gcc版本1sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.8 100如果用过此方法配置过多个gcc版本，会看到如下选项12345678910➜ openjdk update-alternatives --config gcc There are 2 choices for the alternative gcc (providing /usr/bin/gcc). Selection Path Priority Status------------------------------------------------------------ 0 /usr/bin/gcc-7 50 auto mode* 1 /usr/bin/gcc-4.8 20 manual mode 2 /usr/bin/gcc-7 50 manual modePress &lt;enter&gt; to keep the current choice[*], or type selection number:按同样的方法配置g++配置、编译OpenJDK 81 配置1$ bash ./configure --with-target-bits=64 --with-debug-level=slowdebug --enable-debug-symbols ZIP_DEBUGINFO_FILES=0一般没什么问题，有的话，按照提示进行fix2 编译及排错开始编译1$ make all ZIP_DEBUGINFO_FILES=0排错错误1123*** This OS is not supported: Linux ethan 4.4.0-133-generic #159~14.04.1-Ubuntu SMP Fri Aug 10 08:17:48 UTC 2018 x86_64 x86_64 x86_64 GNU/Linuxmake[5]: *** [check_os_version] 错误 1make[4]: *** [linux_amd64_compiler2/debug] 错误 2解决1修改文件 ./hotspot/make/linux/Makefile修改 SUPPORTED_OS_VERSION = 2.4% 2.5% 2.6% 2.7% 为SUPPORTED_OS_VERSION = 2.4% 2.5% 2.6% 2.7% 3% 4%错误212error: ‘int readdir_r(DIR*, dirent*, dirent**)’ is deprecated [-Werror=deprecated-declarations] if((status = ::readdir_r(dirp, dbuf, &amp;p)) != 0) &#123;解决2修改文件vim hotspot/make/linux/makefiles/gcc.make12# Compiler warnings are treated as errors# WARNINGS_ARE_ERRORS = -Werror3 编译成功123456789101112131415161718## Finished docs (build time 00:02:28)----- Build times -------Start 2019-04-15 01:48:49End 2019-04-15 02:04:0700:00:30 corba00:00:24 demos00:02:28 docs00:07:24 hotspot00:00:27 images00:00:17 jaxp00:00:26 jaxws00:03:04 jdk00:00:01 langtools00:00:16 nashorn00:15:18 TOTAL-------------------------Finished building OpenJDK for target 'all'参考资料mac下编译openjdk1.9及集成clion动态调试CentOS上编译OpenJDK8源码 以及 在eclipse上调试HotSpot虚拟机源码]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>编译JDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[openjdk-8 -- 使用Clion调试源码]]></title>
    <url>%2F2019%2F04%2F19%2Fopenjdk-8-%E4%BD%BF%E7%94%A8Clion%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[终端中gdb断点进入源码调试hotspot1 编译class12345678910$ vim ~/Test.java# 输入以下内容public class Test&#123; public static void main(String[] args)&#123; System.out.println("hello world !"); &#125;&#125;$ /root/openjdk/build/linux-x86_64-normal-server-slowdebug/jdk/bin/javac Test.java$ /root/openjdk/build/linux-x86_64-normal-server-slowdebug/jdk/bin/java Testhello world2 进入gdb测试12345678910# 第一步，启动gdb$ gdb --args /root/openjdk/build/linux-x86_64-normal-server-slowdebug/jdk/bin/java ~/Test# 第二步，设置断点(gdb) break init.cpp:95# 第三步，开始debug(gdb) run# debug会在断点处停止，可以查看断点处代码(gdb) l# 最后，退出gdb(gdb) quit整个操作如下图所示：在IDE中调试，这里选择Clion1 导入项目打开clion，选择 File-&gt;ImportProject，选择到 ~/ClionProjects/openjdk-8/hotspot作为jvm源码的根目录，这里导入的过程无脑点击next即可对于可能遇到的头文件不包含问题，解决如下：clion导入源码之后遇到头文件找不到的问题，而实际上这些头文件在源码里面是存在的，只不过在某些源文件里面是以相对路径的方式来搜索，可以在CMakeLists.txt里面添加一些根路径1234include_directories(./src/share/vm)include_directories(./src/cpu/x86/vm)include_directories(./src/share/vm/precompiled)include_directories(./src/share/vm/utilities)另外，如果某些头文件依然找不到，可以手工导入，然后把导入的头文件加到hotspot/src/share/vm/precompiled/precompiled.hpp里，因为大多数源文件都会包含这个源文件12345678# include &lt;cstdlib&gt;# include &lt;cstdint&gt;# include &quot;register_x86.hpp&quot;# include &quot;assembler_x86.hpp&quot;# include &quot;globalDefinitions.hpp&quot;# include &quot;globalDefinitions_x86.hpp&quot;# include &quot;assembler_x86.hpp&quot;#include &lt;stubRoutines_x86.hpp&gt;2 配置debug右上角，点击Edit Configuration进入如下界面，添加Application：jdk-8，Execuable中选择～/CLionProjects/openjdk-9/build/linux-x86_64-normal-serverANDclient-slowdebug/jdk/binBefore lauch: Activate tool window 下的预build项一定要去掉，我的已经去掉了3 设置断点，开始debug断点选在jni.cpp的创建vm处，然后开始debug这里如果报错，如下图所示：可以在点击LLDB，输入process handle SIGSEGV --stop=false即可，这里告诉编译器忽略错误一般Clion默认使用GDB进行debug，可以根据如下所示进行切换同理，若为GDB的话，点击输入handle SIGSEGV pass noprint nostop即可动图如下：参考资料深入jvm内部掌握java线程的运行原理]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Clion调试JDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux -- make install的安装与卸载]]></title>
    <url>%2F2019%2F04%2F13%2Flinux%20--%20make%20install%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8D%B8%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[在ubuntu中安装程序时，并不能总能通过apt等包管理器完成；这时候就不得不通过编译源码，安装二进制程序解决。但如果make install默认安装的话，就会给之后的程序卸载带来隐患；基于这些问题，先记录如下：安装make install 一般会加上option参数--prefix ,表示安装对应目录。如：1$ make install --prefix=/opt/application如果不配置该选项，安装后可执行文件默认放在/usr/local/bin，库文件默认放在/usr/local/lib，配置文件默认放在/usr/local/etc，其它的资源文件放在/usr/local/share，比较凌乱。用--prefix选项的另一个好处是方便卸载软件或移植软件；当某个安装的软件不再需要时，只须简单的删除该安装目录，就可以把软件卸载得干干净净；而移植软件只需拷贝整个目录到另外一个机器即可（相同的操作系统下）。卸载如果按照上面的操作方式 ，即加上了--prefix参数，那么直接删除对应配置目录，卸载就完成了万一在make install时，忘记加上--prefix参数，那么可以采取1$ make install &amp; &gt; Log_install这样做，会重新覆盖安装，并且将对应的安装信息写入Log_install 文件中。我们只需根据日志文件，删除对应目录的文件，即可完成卸载。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>make</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux -- 编译命令总结]]></title>
    <url>%2F2019%2F04%2F13%2Flinux-%E7%BC%96%E8%AF%91%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[在平时的linux开发中，特别是非IDE开发 中，总是会或多或少的遇到相关开发命令，特点总结如下：分类编译命令 gcc g++gcc是linux平台中默认的c语言编译命令，g++则是对应c++编译命令编译批处理命令make如果源文件太多，一个一个编译时就会特别麻烦，于是人们想到可以通过批处理来编译源文件，make就是在这样的初衷下诞生的。但make命令有一个不方便的地方，就是你必须自己编辑makefile文件来指导make的编译过程，这在遇到大工程时，难度是不可想象的。make还支持增量编译，即当我们改变了一小部分的源码文件的时候重新执行make，它将不会重新编译整个程序，而是仅仅更新那些直接或者间接依赖这些改变了的源码文件的非源码文件。自动生成makefile的cmake尽管cmake命令也需要手动编辑CMakeLists.txt文件来指导cmake命令，但相较于 makefile的编辑，难度已大大降低。除此之外，cmake还支持跨平台makefile生成。它会自动辨别使用那种编译器去编译给出的源码种类，自动发现跨平台系统库。简而言之，就是cmake可以帮我们解决系统环境相关配置，解决跨平台编译难题。实践在平时的使用中，基本遵循一下流程：123456# 1.编辑CMakeLists.txt, 执行cmake &lt;path.CMakeList.txt&gt;, 生成makefile$ cmake ./CMakeLists.txt# 2.执行make，进行批量编译$ make# 3. 进入可执行文件所在目录，运行$ ./runflie]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>编译命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux -- 文件编码与转换]]></title>
    <url>%2F2019%2F04%2F12%2Flinux-%E6%96%87%E4%BB%B6%E7%BC%96%E7%A0%81%E4%B8%8E%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[使用vim进行文档识别（不改变编码）由于windows系统普遍采用GBK编码，这样导致在windows上编辑的文本转移到采用utf-8编码的linux上后，容易出现乱码现象。其中的原因是，GBK编码的文件在linux上以utf-8进行解码，会出错。于是，接下来打算在vim中以fileencodings的方式进行尝试解码，然后用vim的utf-8缓存编码进行显示操作如下：1.打开vimrc文件，没有则新建1$ vim ~/.vimrc2.在vimrc中添加12set encoding=utf-8set fileencodings=ucs-bom,utf-8,cp936知识补充vim 中通过底部命令set fileencoding显示当前编辑文件编码encoding: Vim 内部使用的字符编码方式，包括 Vim 的 buffer (缓冲区)、菜单文本、消息文本等。fileencoding: Vim 中当前编辑的文件的字符编码方式，Vim 保存文件时也会将文件保存为这种字符编码方式 (不管是否新文件都如此)。fileencodings: Vim自动探测fileencoding的顺序列表，启动时会按照它所列出的字符编码方式逐一探测即将打开的文件的字符编码方式，并且将 fileencoding 设置为最终探测到的字符编码方式。ermencoding: Vim 所工作的终端 (或者 Windows 的 Console 窗口) 的字符编码方式。如果vim所在的term与vim编码相同，则无需设置。如其不然，你可以用vim的termencoding选项将自动转换成term 的编码.这个选项在 Windows 下对我们常用的 GUI 模式的 gVim 无效，而对 Console 模式的Vim 而言就是 Windows 控制台的代码页，并且通常我们不需要改变它。使用iconv进行编码转换经过尝试，在vim中，通过底部命令set fileencoding=utf-8，即使将原GBK（也称cp936）编码的文档转码为utf-8，在vim中显示也依然存在乱码现象。问题分析：这种原因可能是在vim中set fileencoding=utf-8 仅仅是改变了文档编码标志，并未真正改变其编码。基予此，采用iconv进行转码操作。iconv命令是用来转换文件的编码方式的（Convert encoding of given files from one encoding to another），比如它可以将UTF8编码的转换成GB18030的编码，反过来也行。命令如下：1$ iconv -f &#123;&#123;from_encoding&#125;&#125; &#123;&#123;input_file&#125;&#125; &gt; &#123;&#123;output_file&#125;&#125;实际上vim的编码自适应显示，底层也是调用了iconv命令]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>文件乱码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux -- 软链接和硬链接]]></title>
    <url>%2F2019%2F04%2F12%2Flinux-%E8%BD%AF%E9%93%BE%E6%8E%A5%E5%92%8C%E7%A1%AC%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[文件名和数据文件名与数据，这在 Linux 上被分成两个部分：用户数据 (user data) 与元数据 (metadata)。如下所示：用户数据，即文件数据块（data block），是真正记录数据的地方；而元数据（metadata）是记录文件相关属性（如文件名、文件大小、索引节点inode）的地方。并且实际上，linux系统是通过inode进行文件查找等相关操作的。文件名主要是为了方便用户对文件的识记。显示inode节点可以使用stat或ls -i命令硬链接与软链接为解决文件共享，引入了软硬链接。链接为 Linux 系统解决了文件的共享使用，还带来了隐藏文件路径、增加权限安全及节省存储等好处。硬链接 硬链接文件除了文件名与所指向文件不同外，其余全部相同，即原被链接文件inode对应多个文件名。通过如下方式创建硬链接：1$ link oldfile hard.link特点如下：文件有相同的 inode 及 data block；只能对已存在的文件进行创建；不能交叉文件系统进行硬链接的创建；不能对目录进行创建，只可对文件创建；删除一个硬链接文件并不影响其他有相同 inode 号的文件。软链接 就是一个普通文件，只是数据块内容写有指向文件的inode信息。软链接也有自己的 inode 号以及用户数据块。通过如下方式创建软链接：1$ ln -s old.file soft.link特点如下：软链接有自己的文件属性及权限等；可对不存在的文件或目录创建软链接；软链接可交叉文件系统；软链接可对文件或目录创建；创建软链接时，链接计数 i_nlink 不会增加；删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接（即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接）。链接相关命令使用find 命令，其不仅可查找某文件的软链接，还可以用于查找相同 inode 的所有硬链接。12345678910// 查找目录下文件的软链接$ find &lt;directory&gt; -lname &lt;file&gt;// 查找目录下文件的硬链接$ find &lt;directory&gt; -samefile &lt;file&gt;or$ find &lt;directory&gt; -inum &lt;inode&gt;// 列出目录下所有的软链接$ find &lt;directory&gt; -type l -ls]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>软链接和硬链接</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度anyQ -- 编译错误]]></title>
    <url>%2F2019%2F04%2F10%2F%E7%99%BE%E5%BA%A6anyQ-%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[偶然在github上发现了百度的anyQ智能对话框架，刚好自己也在研究这一块，遂决定重现一下这个模型。中途遇到不少编译错误，现记录下来错误执行mkdir build &amp;&amp; cd build &amp;&amp; cmake .. &amp;&amp; make 后报错如下：1234/home/AnyQ/build/third_party/include/dmlc/./logging.h:323:31: error: ‘DMLC_LOG_STACK_TRACE_SIZE’ was not declared in this scopemake[2]: *** [third_party/paddle/src/extern_paddle-stamp/extern_paddle-build] Error 2make[1]: *** [CMakeFiles/extern_paddle.dir/all] Error 2make: *** [all] Error 2解决方法：首先将原官方https://github.com/baidu/AnyQ.git 替换为 https://github.com/ljch2018/AnyQ.git然后修改如下两个文件，使之以单线程编译即可1234xgboost.cmake：INSTALL_COMMAND cd $&#123;XGBOOST_INSTALL_DIR&#125; &amp;&amp; make -j1paddle.cmakeBUILD_COMMAND cd $&#123;PADDLE_INSTALL_DIR&#125; &amp;&amp; make -j1建议尽量使用官方的docker镜像，避免不必用的环境问题12# paddle官方镜像docker pull paddlepaddle/paddle:latest-dev]]></content>
      <categories>
        <category>智能对话系统</category>
      </categories>
      <tags>
        <tag>anyQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ruby -- 安装]]></title>
    <url>%2F2019%2F04%2F10%2FRuby-%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Ruby 安装分3中途径：官方下载源码，编译make，然后make install，优点是可以保持版本最新通过系统自带apt 安装，sudo apt install -y ruby-full ，简单快捷，但一般版本偏旧通过第三方包管理器安装，这里选择RVMRVM安装Ruby安装RVM12$ gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB$ curl -sSL https://get.rvm.io | bash -s stable安装过后，需要刷新一下bash环境1$ source /etc/profile.d/rvm.sh检查是否安装成功1$ rvm -v用RVM安装Ruby1.查看已发布Ruby1$ rvm list known2.安装指定版本的Ruby，完成后Ruby和RubyGems会同时安装好1$ rvm install 2.6.23.设置默认ruby版本1$ rvm 2.6.2 --default如果报错12345RVM is not a function, selecting rubies with 'rvm use ...' will not work.You need to change your terminal emulator preferences to allow login shell.Sometimes it is required to use `/bin/bash --login` as the command.Please visit https://rvm.io/integration/gnome-terminal/ for an example.只需执行/bin/zsh --login 即可解决，更多请看这里4.检查ruby和gem是否安装成功12$ ruby -v$ gem -vRVM常用命令查询已安装的ruby1$ rvm list卸载指定版本ruby1$ rvm remove 2.6.2Ruby中国源替换替换命令12$ gem source -r https://rubygems.org/$ gem source -a https://gems.ruby-china.com/查看当前源1$ gem sources -l]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>ruby</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux -- 程序安装]]></title>
    <url>%2F2019%2F04%2F10%2Flinux-%E7%A8%8B%E5%BA%8F%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[平时在linux使用当中，经常会碰到安装各种程序。但由于使用惯了windows系统，往往会反复的去Google；结果再次遇到时，又忘得一干二净了。基于此，特地总结如下：在linux中，一般存在3种程序安装的方法。二进制文件安装1.下载文件，解压到安装目录安装目录分为3类：/usr：系统级的目录，可以理解为C:/Windows/，/usr/lib理解为C:/Windows/System32。/usr/local：用户级的程序目录，可以理解为C:/Progrem Files/。这里主要存放那些手动安装的软件，即不是通过apt-get安装的软件。它和/usr目录具有相类似的目录结构。让软件包管理器来管理/usr目录，而把自定义的脚本(scripts)放到/usr/local目录下面，我想这应该是个不错的主意。/opt：用户级的程序目录，可以理解为D:/Software，opt有可选的意思，这里可以用于放置第三方大型软件（或游戏），当你不需要时，直接rm -rf掉即可。在硬盘容量不够时，也可将/opt单独挂载到其他磁盘上使用。2.添加软连接(以nodejs为例)12$ sudo ln -s /usr/local/node/bin/npm /usr/local/bin/npm$ sudo ln -s /usr/local/node/bin/node /usr/local/bin/node源码编译安装1.下载源码1sudo git clone https://github.com/nodejs/node.git2.修改目录权限1sudo chmod -R 755 node3.通过configure生成配置文件，并编译安装1234cd nodesudo ./configuresudo makesudo make install通过包管理器安装12sudo apt-get install nodejssudo apt-get install npm]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu -- apt update error]]></title>
    <url>%2F2019%2F04%2F10%2Fubuntu-apt-update-error%2F</url>
    <content type="text"><![CDATA[最近在一次ubuntu的例行apt更新中，竟然报错了；在一阵疯狂Google后，总算是解决了，现总结如下：出现错误尝试sudo apt update，输出如下错误：12345$ Err:17 http://ppa.launchpad.net/a-v-shkop/chromium/ubuntu bionic Release 404 Not Found [IP: 91.189.95.83 80]Reading package lists... Done E: The repository 'http://ppa.launchpad.net/a-v-shkop/chromium/ubuntu bionic Release' does not have a Release file.N: Updating from such a repository can't be done securely, and is therefore disabled by default.解决方案根据错误提示，可知为ppa源问题，解决如下：1$ sudo add-apt-repository -r http://ppa.launchpad.net/a-v-shkop/chromium/ubuntu另外，网上还给出了额外的shell脚本解决方法1.touch ppa-remove 新建一个文本输入如下内容：12345678910111213141516#!/bin/bashsudo rm /tmp/update.txt; tput setaf 6; echo "Initializing.. Please Wait" sudo apt-get update &gt;&gt; /tmp/update.txt 2&gt;&amp;1; awk '( /W:/ &amp;&amp; /launchpad/ &amp;&amp; /404/ ) &#123; print substr($5,26) &#125;' /tmp/update.txt &gt; /tmp/awk.txt; awk -F '/' '&#123; print $1"/"$2 &#125;' /tmp/awk.txt &gt; /tmp/awk1.txt; sort -u /tmp/awk1.txt &gt; /tmp/awk2.txttput sgr0if [ -s /tmp/awk2.txt ]then tput setaf 1 printf "PPA's going to be removed\n%s\n" "$(cat /tmp/awk2.txt)" tput sgr0 while read -r line; do echo "sudo add-apt-repository -r ppa:$line"; done &lt; /tmp/awk2.txt &gt; out bash outelse tput setaf 1 echo "No PPA's to be removed" tput sgr0fi2.赋予文件执行权限1$ sudo chmod +x ppa-remove3.运行1$ sudo ./ppa-remove]]></content>
      <categories>
        <category>踩坑</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker -- 镜像操作]]></title>
    <url>%2F2019%2F04%2F09%2FDocker-%E9%95%9C%E5%83%8F%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[获取镜像从 Docker 镜像仓库获取镜像的命令是 docker pull。其命令格式为：1docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]具体的选项可以通过 docker pull --help 命令看到，这里我们说一下镜像名称的格式。Docker 镜像仓库地址：地址的格式一般是 &lt;域名/IP&gt;[:端口号]。默认地址是 Docker Hub。仓库名：如之前所说，这里的仓库名是两段式名称，即 &lt;用户名&gt;/&lt;软件名&gt;。对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像。下载也是一层层的去下载，并非单一文件。下载过程中给出了每一层的 ID 的前 12 位。并且下载结束后，给出该镜像完整的 sha256 的摘要，以确保下载一致性。列出镜像要想列出已经下载下来的镜像，可以使用 docker image ls 命令。删除本地镜像如果要删除本地的镜像，可以使用 docker image rm 命令，其格式为：1$ docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]其中，&lt;镜像&gt; 可以是 镜像短 ID、镜像长 ID、镜像名 或者 镜像摘要容器对镜像的依赖如果有用这个镜像启动的容器存在（即使容器没有运行），那么同样不可以删除这个镜像。之前讲过，容器是以镜像为基础，再加一层容器存储层，组成这样的多层存储结构去运行的。因此该镜像如果被这个容器所依赖的，那么删除必然会导致故障。如果这些容器是不需要的，应该先将它们删除，然后再来删除镜像。]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker -- Error response from daemon]]></title>
    <url>%2F2019%2F04%2F09%2Fdocker-Error-response-from-daemon%2F</url>
    <content type="text"><![CDATA[错误如下：1docker: Error response from daemon: OCI runtime create failed: container_linux.go:348: starting container process caused "process_linux.go:297: copying bootstrap data to pipe caused \"write init-p: broken pipe\"": unknown.由于docker的版本更新引起解决办法： 3种任选其一使用低版本的dockerdocker CE1$ sudo apt-get install docker-ce=18.06.1~ce~3-0~ubuntudocker EE on CentOS 7123$ sudo curl -SsL https://download.docker.com/linux/centos/docker-ce.repo -o /etc/yum.repos.d/docker-ce.repo$ sudo yum --showduplicates list docker-ce$ sudo yum install docker-ce-18.06.1.ce-3-0.el7.centos更多其他版本的安装，看这里升级linux内核例如，你现在在用Ubuntu 14.04，可以将其升级到Ubuntu 16 Xenial1$ sudo apt-get install linux-generic-lts-xenial升级系统版本对于Ubuntu 14.04，你可以使用一下命令升级到Xenial1$ sudo do-release-upgrade如果遇到14.04 --&gt; 16.04 failed; apt (&gt;= 1.0.1ubuntu2.13)&#39; is not installed报错，可以执行以下命令：12$ sudo apt update$ sudo apt dist-upgrade]]></content>
      <categories>
        <category>踩坑</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker -- 安装]]></title>
    <url>%2F2019%2F04%2F09%2Fdocker-%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[卸载旧版本123$ sudo apt-get remove docker \ docker-engine \ docker.io安装使用APT安装1.https依赖123456$ sudo apt update$ sudo apt-get install \ apt-transport-https \ ca-certificates \ curl \ software-properties-common2.添加国内源为了确认所下载软件包的合法性，需要添加软件源的 GPG 密钥1$ curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -​ 向 source.list 中添加 Docker 软件源1234$ sudo add-apt-repository \ "deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \ $(lsb_release -cs) \ stable"3.安装docker-ce12$ sudo apt-get update$ sudo apt-get install docker-ce使用脚本自动安装在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，Ubuntu 系统上可以使用这套脚本安装：12$ curl -fsSL get.docker.com -o get-docker.sh$ sudo sh get-docker.sh --mirror Aliyun启动 docker-ce12$ sudo systemctl enable docker$ sudo systemctl start docker默认情况下，docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组。1.建立 docker 组：1$ sudo groupadd docker2.将当前用户加入 docker 组：1$ sudo usermod -aG docker $USER3.重启 docker 服务1$ sudo systemctl restart docker4.切换当前会话到新 group 或者重启 X 会话注意:最后一步是必须的，否则因为 groups 命令获取到的是缓存的组信息，刚添加的组信息未能生效，所以 docker images 执行时同样有错。1$ newgrp - docker镜像加速对于使用 systemd 的系统，请在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件）12345&#123; "registry-mirrors": [ "https://reg-mirror.qiniu.com/" ]&#125;注意，一定要保证该文件符合 json 规范，否则 Docker 将不能启动。之后重新启动服务。12$ sudo systemctl daemon-reload$ sudo systemctl restart docker]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker -- 网络访问]]></title>
    <url>%2F2019%2F04%2F09%2Fdocker-%E7%BD%91%E7%BB%9C%E8%AE%BF%E9%97%AE%2F</url>
    <content type="text"><![CDATA[分类外部访问容器或容器访问外部（一般是容器间相互访问）外部访问容器由于docker容器的封闭性，外部要访问容器内资源，必须借助host主机的端口映射，相关命令如下：系统随机分配主机端口给容器，完成映射1$ docker run -P &lt;image ID&gt;-p 则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有1$ docker run -p ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort第一种格式是外部指定ip固定端口，第二种是外部指定ip随机端口，第三种是外部所有ip指定端口查看端口映射使用 docker port 来查看当前映射的端口配置，也可以查看到绑定的地址使用 docker container ls通过 docker logs 命令来查看应用的信息容器互联新建网络先创建一个新的 Docker 网络。1$ docker network create -d bridge my-net-d 参数指定 Docker 网络类型，有 bridge、 overlay运行一个容器并加入到 my-net 网络，使用--network1$ docker run -it --rm --name busybox1 --network my-net busybox sh以这样的方式可以加入多个容器]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker -- 容器操作]]></title>
    <url>%2F2019%2F04%2F09%2FDocker-%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Docker之容器操作启动容器启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（stopped）的容器重新启动。新建并启动所需的命令主要为 docker run例如，下面的命令输出一个 “Hello World”，之后终止容器。12$ docker run ubuntu:18.04 /bin/echo 'Hello world'Hello world下面的命令则启动一个 bash 终端，允许用户进行交互。12$ docker run -t -i ubuntu:18.04 /bin/bashroot@af8bae53bdd3:/#当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括：检查本地是否存在指定的镜像，不存在就从公有仓库下载利用镜像创建并启动一个容器分配一个文件系统，并在只读的镜像层外面挂载一层可读写层从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去从地址池配置一个 ip 地址给容器执行用户指定的应用程序执行完毕后容器被终止启动已终止容器利用 docker container start 命令，直接将一个已经终止的容器启动运行。守护态运行使用命令docker run -d启动容器，即使容器在后台运行。使用 -d 参数启动后会返回一个唯一的 id，这和bash中command &amp;命令类似。两个有用的命令：查看容器信息123$ docker container lsCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES77b2dc01fe0f ubuntu:18.04 /bin/sh -c &apos;while tr 2 minutes ago Up 1 minute agitated_wright获取容器的输出信息1$ docker container logs [container ID or NAMES]进入容器容器进入后台运行后，如何再次进入该容器？使用 docker attach 命令或 docker exec 命令，推荐使用docker exec，原因如下：使用docker attach进入容器后，若再次退出，会导致该后台容器stop而使用docker exec 进入容器后，若再次退出，不会导致后台容器stop，容器会依旧后台运行12345$ docker run -dit ubuntu69d137adef7a8a689cbcb059e94da5489d3cddd240ff675c640c8d96e84fe1f6$ docker exec -it 69d1 bashroot@69d137adef7a:/#终止容器使用 docker container stop 来终止一个运行中的容器。此外，当 Docker 容器中指定的应用终结时，容器也自动终止。终止状态的容器可以用 docker container ls -a 命令看到1234docker container ls -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESba267838cc1b ubuntu:18.04 "/bin/bash" 30 minutes ago Exited (0) About a minute ago trusting_newton98e5efa7d997 training/webapp:latest "python app.py" About an hour ago Exited (0) 34 minutes ago backstabbing_pike导出和导入容器导出容器如果要导出本地某个容器，可以使用 docker export 命令。1234$ docker container ls -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES7691a814370e ubuntu:18.04 "/bin/bash" 36 hours ago Exited (0) 21 hours ago test$ docker export 7691a814370e &gt; ubuntu.tar这样将导出容器快照到本地文件。导入容器快照可以使用 docker import 从容器快照文件中再导入为镜像，例如1234$ cat ubuntu.tar | docker import - test/ubuntu:v1.0$ docker image lsREPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZEtest/ubuntu v1.0 9d37a6082e97 About a minute ago 171.3 MB此外，也可以通过指定 URL 或者某个目录来导入，例如1$ docker import http://example.com/exampleimage.tgz example/imagerepo删除容器可以使用 docker container rm 来删除一个处于终止状态的容器。例如12$ docker container rm trusting_newtontrusting_newton如果要删除一个运行中的容器，可以添加 -f 参数。Docker 会发送 SIGKILL 信号给容器清理所有处于终止状态的容器用 docker container ls -a 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。1$ docker container prune]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker -- 初识]]></title>
    <url>%2F2019%2F04%2F08%2Fdocker-%E5%88%9D%E8%AF%86%2F</url>
    <content type="text"><![CDATA[什么是docker传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。​ 传统虚拟化​ docker容器docker优点资源利用率高启动速度更快一致的运行环境持续交付和部署更轻松的迁移、维护和拓展……]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git -- 常用操作总结(一)]]></title>
    <url>%2F2018%2F11%2F26%2FGit-%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[1 git初识1.1 git 安装与登陆安装(linux)：1sudo apt-get install git登陆：由于git的分布式特性，每一个使用其的电脑都必须注册自己，如下：12git config --global user.name "Your name"git ocnfig --global user.email "Your email"1.2 git创建版本库创建一个空目录12mkdir learngitcd ./learngit将该目录初始化为git仓库1git init #git的初始化，即将当前目录与git仓库进行关联，当前目录会自动生成一个.git文件夹把文件添加到版本库123echo "Git is a version control system" &gt;&gt; readme.txtgit add readme.txt #将文件由workdirctory添加到stage(暂存区)git commit -m "wrote a readme file" #将stage的修改添加到版本库2 git版本控制2.1 版本回退提交历史显示命令，用于查看提交历史记录，以便确定要回退到哪个版本1git log #查看提交历史回退命令，其中HEAD指向当前版本，HEAD^指向上一个版本，HEAD^^指向上上个版本123git reset --hard commit_id #将仓库回退到指定id版本# orgit reset --hard HEAD^ #将仓库回退到上一版本当版本回退成功后，原来的版本丢失，通过 git log 无法查看其commit _id ，这时候可以使用git reflog1git reflog #查看命令历史2.2 工作区 暂存区 版本库工作区：可以理解为自己的本机工作目录，并且这个目录是还未进入git版本库管理的。在这个状态下，我们可以进行增、删、改各种操作。暂存区：是所有操作真正提交到版本库的前一步，主要是追踪各种操作，以及为多次操作后的批量提交作准备，避免频繁提交。版本库：可以简单理解为仓库，进入版本库也就意味着已经登记入库了。版本库还可以进一步分为多个分支，一般有一个master主分支，多个次分支，这样可以进行多个版本的跟踪。2.3 新增、修改与删除不管是文件的新增，还是修改，我们在工作区完成操作后，都是通过add命令完成向暂存区提交的1git add readme.txt若是删除文件，我们同样要向暂存区报备，通过rm命令记录删除操作1git rm readme.txt最后通过commit命令提交到分支使操作真正生效1git commit -m "add readme.txt/del readme.txt"2.4 操作回滚操作回滚分为三类场景：（1）如果你只是误操作，还未进行add提交到暂存区，那么只需一步操作就可以反悔1git checkout -- "readme.txt" #由于还未add，即意味暂存区还保留着该操作在工作区的上一状态，直接checkout就行（2）如果你手残地add到了暂存区，那就要分两步完成回滚12git reset HEDA "readme.txt" #将暂存区的该次误操作丢弃，并重置为分支中的最新版本状态，其他操作不受影响git checkout -- "readme.txt" #将此时暂存区的状态映射到工作区，即将误操作回复为版本库状态（3）如果你不幸到已经commit了误操作，那即意味着误操作已经进入分支中，成为了最新版本，这时候只能通过版本回退的方式来补救1git reset --hard HEAD^ #后退到误操作之前的那个版本，这样可能丢失除误操作以外的其他有用操作从以上操作我们不难发现，暂存区的存在确保了工作区的不当操作不会直接影响分支；同时，我们可以将多次add/rm操作进行一次commit提交，可以起到对操作的分组效果；最后，如果你只是在场景(1)(2)回退，那么可以最大程度的减小对其他add/rm操作的影响，不至于在回滚某个操作时，丢失其他操作。而(3)版本回退显然不是针对某个特定操作，这种回退的代价是难以估量的。3 git远程操作3.1 与github进行连接通过SSH协议将本地git仓库与github进行配对，首先生成SSH key1ssh-keygen -t rsa -C "youremail"执行过后，生成.ssh 目录，其中id_rsa 和id_rsa_pub 分别代表私钥和公钥。我们只需将公钥中的字符串添加到github账户的”AccountSetting”的”SSH Keys”页面中，就OK了。3.2 添加远程仓库添加github仓库命令1git remote add orgin 仓库地址 #orgin为默认远程仓库地址别名将本地库推送到远程仓库1git push -u origin master #第一次将本地的master分支推送到远程，以后可以省略'-u'3.3 克隆远程库直接从远程克隆git仓库，也可以完成本地与远程的关联1git clone &lt;ssh/https&gt;远程库地址]]></content>
      <categories>
        <category>版本控制</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
</search>
