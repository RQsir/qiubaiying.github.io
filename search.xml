<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CommonIO总结]]></title>
    <url>%2F2019%2F07%2F06%2Fjavase-CommonIO%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[作为J2SE中”三大核心”之一的IO操作，我们虽然在学习时可以忽略“重复造轮子”的禁忌；但在实际开发当中，还是应本着“业务第一，有轮子就用的”原则来指导我们的日常工作。java代码的规模当我们刚开始接触java时，无一例外的会从其基本语法入手。这时，我们也会跟着教程写几个简单demo，看看效果，并因此而小激动一会。随着学习的深入，我们会逐渐了解到我们平时练手的这些小代码块，编译后无非是一些class文件，它们的运行需要java虚拟机的加载与相关环境的支持。后来我们会接触到一些有用的工具包，它们一般是以jar压缩包的形式提供给我们；jar包中一般会包含一到多个class文件，换句话说，jar包将一些有用的、经过开发者实践的代码整合到了一起。照上述类推，许多的jar又一道构成了功能更强大的component组件（常见的如：我们接下来要谈到的CommonIO）；在此基础上又一次聚合，就得到了所谓的framework框架（如Spring、Commons等）。graph LR id1(class文件)-->|组成|id2(jar包); id2(jar包)-->|组成|id3(component组件); id3(component组件)-->|组成|id4(framework框架);下载与配置graph TB id1["进入Apache官网Commons页面(http://commons.apache.org/)"]==>id2["进入CommonIO项目页(http://commons.apache.org/proper/commons-io/)"]; id2["进入CommonIO项目页(http://commons.apache.org/proper/commons-io/)"]==>id3["下载最新CommonsIO_jdk"];下载完CommonsIO_jar包后，我们只需按照相应IDE的lib引入方法，完成对jar包的引入设置。这里以idea为例，我们只需先进入project structure 面板，然后点击左侧的Libraries选项，最后点击添加按钮并添加想要的jar包。CommonsIO常用接口文件及目录大小获取获取文件大小12方法: public static long sizeOf(final File file);调用形式: FileUtils.sizeOf(file);获取目录大小12方法:public static long sizeOfDirectory(final File directory);调用形式: FileUtils.sizeOfDirectory(dir);遍历及筛选目录1234567891011121314151617181920212223/** * 遍历指定目录的第一层子目录，过滤条件为：内容非空 */Collection&lt;File&gt; files = FileUtils.listFiles(new File("/home/rqsir/IdeaProjects/CommonIODemo"), EmptyFileFilter.NOT_EMPTY,null);for (File file:files ) &#123; System.out.println(file.getAbsolutePath());&#125;System.out.println("-------------------------------");/** * 遍历指定目录的所有子目录，过滤条件为：内容非空 */Collection&lt;File&gt; files1 = FileUtils.listFiles(new File("/home/rqsir/IdeaProjects/CommonIODemo"), EmptyFileFilter.NOT_EMPTY, DirectoryFileFilter.INSTANCE);for (File file:files1) &#123; System.out.println(file.getAbsolutePath());&#125;System.out.println("-------------------------------");/** * 遍历指定目录的所有子目录，过滤条件为：后缀为：java */Collection&lt;File&gt; files2 = FileUtils.listFiles(new File("/home/rqsir/IdeaProjects/CommonIODemo"), new SuffixFileFilter("java"), DirectoryFileFilter.INSTANCE);for (File file:files2) &#123; System.out.println(file.getAbsolutePath());&#125;System.out.println("-------------------------------");/** * 遍历指定目录的所有子目录，过滤条件为：后缀为：java或者class */Collection&lt;File&gt; files3 = FileUtils.listFiles(new File("/home/rqsir/IdeaProjects/CommonIODemo"), FileFilterUtils.or(new SuffixFileFilter("java"),new SuffixFileFilter("class")), DirectoryFileFilter.INSTANCE);for (File file:files3) &#123; System.out.println(file.getAbsolutePath());&#125;System.out.println("-------------------------------");/** * 遍历指定目录的所有子目录，过滤条件为：后缀为：java且不为空 */Collection&lt;File&gt; files4 = FileUtils.listFiles(new File("/home/rqsir/IdeaProjects/CommonIODemo"), FileFilterUtils.and(new SuffixFileFilter("java"),EmptyFileFilter.NOT_EMPTY), DirectoryFileFilter.INSTANCE);for (File file:files4) &#123; System.out.println(file.getAbsolutePath());&#125;读取文件内容1234567891011121314151617181920212223242526//读取文件内容方式一:(一次性读取)String content = FileUtils.readFileToString(new File("a.txt"),"utf8");System.out.println(content);System.out.println("------------------------------");//读取文件内容方式二:(按行读取)List&lt;String&gt; lines = FileUtils.readLines(new File("a.txt"),"utf8");for (String line:lines ) &#123; System.out.println(line);&#125;System.out.println("------------------------------");//读取文件大小byte[] bys = FileUtils.readFileToByteArray(new File("a.txt"));System.out.println("fileSize:"+bys.length);System.out.println("------------------------------");//读取文件内容方式三:(通过迭代器读取)LineIterator lineIterator = FileUtils.lineIterator(new File("a.txt"),"utf8");while (lineIterator.hasNext())&#123; System.out.println(lineIterator.next());&#125;写文件操作12345678910111213//写字符串到文件FileUtils.write(new File("b.txt"),"学习很伟大\n","utf8",true);FileUtils.writeStringToFile(new File("b.txt"),"学习很辛苦\n","utf8",true);//写字节数组到文件FileUtils.writeByteArrayToFile(new File("b.txt"),"学习很幸福\n".getBytes("utf8"),true);//写String类型的线性表到文件List&lt;String&gt; lines = new ArrayList&lt;String&gt;();lines.add("昨天");lines.add("今天");lines.add("明天");FileUtils.writeLines(new File("b.txt"),"utf8",lines,"---&gt;",true);//"---&gt;"为每一行的分隔符拷贝操作12345678910111213141516//copy fileFileUtils.copyFile(new File("avatar.jpg"),new File("avatar_copy.jpg"));//copy file to directoryFileUtils.copyFileToDirectory(new File("avatar.jpg"),new File("out"));//copy dirFileUtils.copyDirectory(new File("out"),new File("out_copy"));//copy dir to dirFileUtils.copyDirectoryToDirectory(new File("out"),new File("outContainer"));//copy URL to fileString url = "https://raw.githubusercontent.com/RQsir/blog_pic_bed/master/img/81a5cfb3ly1g279yehw2kj21hc0t8457.jpg?token=AKZRZC5LDP5TBBMWU5JBQ4K4YQIPI";FileUtils.copyURLToFile(new URL(url),new File("JDK_debug.gif"));//copy URL to StringString webPage = IOUtils.toString(new URL("http://www.baidu.com"),"utf8");System.out.println(webPage);String webPage2 = IOUtils.toString(new URL("http://www.163.com"),"gbk");System.out.println(webPage2);]]></content>
      <categories>
        <category>java-se</category>
      </categories>
      <tags>
        <tag>CommonIO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VirtualBox 网络模式总结]]></title>
    <url>%2F2019%2F05%2F23%2FVirtualBox-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[今天在装MySQL的过程中，突然想尝试一下通过VirtualBox虚拟机模拟远端服务器，为本地win10提供数据服务器访问业务。那问题来了，如何正确配置VirtualBox的网络设置，来实现win10主机与虚拟机互通互联的需求呢？五种网络模式首先，让我们来看一下VirtualBox中的5中网络配置模式：如上图所示，在VirtualBox中我们可能用到的就5种网络模式，下面对它们分别简介如下：网络模式解释网络地址转换（NAT）NAT协议通过具有公网ip的host主机作为代理，实现了无公网ip的guest虚拟机的互联网访问需求NAT网络本质上也是NAT，不同的是这种模式下不支持host和guest主机之间的端口转发桥接网卡桥接有点类似物理设备中的交换机，通过它，guest虚拟机可以和host主机在链路层互联，构成一个局域网；这样的话，guest虚拟机由于加入了host主机所在的物理局域网会由DHCP自动分配到一个ip内部网络在这种模式下，VirtualBox会生成一个虚拟局域网供虚拟机集群使用；虚拟机间可以相互通信，但host主机无法与虚拟机进行通信host-only模式guest虚拟机通过host上的虚拟网卡与host主机处于同一局域网中，guest和host可以相互通信，但guest虚拟机无法访问外网分类详解对于上述五种模式（除去内部网络外），我在win10和虚拟机中分别做了ping通测试，现记录如下：桥接网卡如上面表格总结的那样，在桥接模式下，guest虚拟机获得了和host一样的，位于同一局域物理网络中的独立的ip地址。我们此时，可以将其视作一台真实的物理机，它与host地位对等。在实际的测试过程当中，我发现自己笔记本的无线网卡似乎并不支持桥接模式下的混杂模式，具体表现是：guest虚拟机可以和host机相互ping通，但guest虚拟机却死活也ping不通外网。通过多方搜索，我总算是在一篇博文中发现了这个问题，特地mark一下。简要步骤是：先在win10的设备管理器中添加一个Microsoft KM-TEST 环回适配器，然后将物理无线网卡的网络共享给该虚拟网络配适器，最后在VirtualBox网络桥接模式配置界面中找到名称选择选项，选择Microsoft KM-TEST 环回适配器就可以了。详情请参考VirtualBox与笔记本无线网卡桥接NAT网络（不带端口转发）NAT协议，最初是为了解决公网ip地址有限，但又必须让每台不具有公网ip的计算机实现上网目的这一问题而提出的。实现思路可以大致理解为：位于同一局域网中的无公网ip主机，通过一个具有公网ip的计算机去间接访问所需资源；这个具有公网ip的计算机在这里起到了一个代理的作用（这一点很类似我们今天的海外商品代购中心），它首先将这些无公网ip主机的请求进行转换（主要是将请求中的原ip地址换成自己的公网ip），然后再次转发给互联网中的目的主机；但收到回复后，它再按照NAT转换表进行转发回复，将响应最终发给每一个无公网ip主机。根据这一思路，VirtualBox中使用NAT网络模式，guest虚拟机所在局域网中必然存在一个具有公网ip的代理主机。为验证这一理论，我在虚拟机中通过路由跟踪命令traceroute，成功发现了这个代理主机的身影，如下所示：相关主机间的ping图如下：网络地址转换（NAT 带端口转发）上面刚介绍了不带端口转发的NAT模式，通过相关的ping图我们不难发现，这种模式存在着很大缺陷：那便是Host主机无法访问Guest虚拟机。这样一来，我们希望的win10主机请求虚拟机中数据库服务器的初衷就泡汤了。针对这种问题，VirtualBox特地为我们推出了带端口转发的NAT网络模式，相关设置描述如下：首先我们进入VirtualBox的网络设置界面，如下所示!进入端口转发设置子界面按照图示指南，完成相应设置后，点击确认即可。这里，我们再来看看host主机与guest主机之间的相关ping通情况：host-only模式这一网络模式下，默认仅允许guest虚拟机之间互相访问，不能连外网，没有配置DNS无法解析域名，无法ping通host主机。但另一方面，它也是VirtualBox网络配置中可玩性最高的一种模式，按理说只要是其他模式能够实现的功能，通过正确的配置，在这种模式下都能实现。我们可以认为，VirtualBox默认为这一模式虚拟化出了一张网卡，用于连接所有的虚拟主机；我们可以通过对这块虚拟网卡手动设定ip，或者是桥接其他物理网卡、网络共享等操作，来达到我们想要的各种网络需求。方案确定通过上述分析，我大致确定了两套可行的方案：通过VirtualBox的网桥模式，使guest虚拟机获得与host主机同一局域网下的真实ip，进而达到host主机自由请求guest虚拟机上数据库服务的目的。利用NAT端口转发模式，实现guest虚拟机访问外网的目标，同时host主机通过端口映射技术，可以最终请求到guest虚拟机上数据库的相关服务，完成数据库的远程调用。]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>VirtualBox-网络模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java -- 变量相加和常量相加的区别]]></title>
    <url>%2F2019%2F05%2F21%2Fjava-%E5%8F%98%E9%87%8F%E7%9B%B8%E5%8A%A0%E5%92%8C%E5%B8%B8%E9%87%8F%E7%9B%B8%E5%8A%A0%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[偶然看到了一道有关java基本数据类型中变量相加和常量相加的面试题，觉得很有意思，先总结如下题目1234byte b1=1, b2=2, b3, b4;b3 = b1 + b2;b4 = 1 + 2;//问哪一条语句会编程失败？题目咋一看，似乎很简单。两个数相加，不就是考虑数据类型是否一致，以及运算结果是否会溢出的问题吗？照着这一思路，我首先判断第2行的代码应该是没有问题的，理由如下：（1）变量b1和b2都是byte类型变量；（2）b1+b2结果为3，没有超出byte的存储空间-128~127。至于第3行代码，是两个常量相加，再将结果赋值给变量b4，应该也不存在编译问题。编译编译输出结果如下：1Error(3):java: incompatible types: possible lossy conversion from int to byte第3行编译报错，第4行通过编译分析初步断定是数据类型转换失败，因为int向byte转换时，会存在精度丢失的问题。那么，这里的int数据又是哪里来的呢？难道byte类型的b1和b2相加，结果被自动转成了int？带着这些疑问，我查阅了相关资料，发现原来在java中基本数据类型在进行运算时，普遍存在着所谓自动数据类型转化问题。之间的转化图可以总结如下：其中红线表示可以在不丢失精度的情况下完成转化，而蓝线则意味着转化后可能会损失部分精度；不管怎样，图中所有转化，都是java编译器所允许的自动类型转换。相关规则是：当byte、short、int、long、char等数据类型在一起运算，即只有整型数据参与运算时：无long型，所有非int类型转成int类型；有long类型，都转成long类型。当float、double等数据类型一起运算，即只有浮点型数据参与运算时：一律转为double类型进行运算。当所有数据类型混在一起运算，即整数和浮点数据类型同时存在时：一律转为double类型进行运算。另外还需要注意的是：整型数据的默认类型为int，浮点型则为double。一般数据运算都先转为默认数据类型，然后才开始运算；除非有更高级别的数据类型存在，比如规则1中存在long型，则都转为long（虽然默认数据类型是int）再回到那道面试题，两个byte类型的变量进行加法运算，编译器在编译这行代码时会自动将其类型转换为整型默认数据类型int，这种现象也叫做java的自动类型提升。从反编译看数据类型转换另外，借助反编译工具procyon.jar，我们可以从代码执行的底层进一步窥探到java数据类型转换的过程。由于b3 = b1 + b2;编译不通过，现将原始代码修改如下：1234byte b1=1, b2=2, b3, b4;//b3 = b1 + b2;int i1 = b1 + b2;b4 = 1 + 2;反编译如下：123456789b1 : byteb2 : bytei1 : intb4 : byteb1 = ldc:byte(1)b2 = ldc:byte(2)i1 = add:int(b1:byte, b2:byte)b4 = ldc:byte(3)从第8行，我们可以知道b1+b2，结果是以int类型保存的，故源码中我们企图将其运算结果赋值给b3会报数据类型不匹配的错误。而1+2这个常量运算式，编译器是先将其结果计算出后，再根据其要被赋值的变量类型（这里被赋值的变量类型是byte），动态分配存储空间的。总结变量相加：一般是先开辟内存空间（根据参与运算的变量类型决定，规则见上面的分析），然后进行相关操作。常量相加：一般是编译器先帮我们算出结果，然后根据所要赋值的变量类型开辟相应内存空间。]]></content>
      <categories>
        <category>java-se</category>
      </categories>
      <tags>
        <tag>java-变量相加和常量相加的区别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java -- HashMap详解]]></title>
    <url>%2F2019%2F05%2F14%2Fjava-HashMap%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[什么是hash比较官方的解释是将任意长度数据映射到到固定长度的域中。例如我们要将1~100编号的苹果放在10个篮子中，怎么做才能尽可能均匀地分散这100个苹果，使得每个篮子苹果个数大致相当。最简单的办法就是通过模运算来解决，把每一个苹果的编号num对篮子数n进行取模得到该苹果要放入篮子的编号index，即index=num%n。这样，可以保证每个篮子都将放入10个苹果。hash在Map中的应用HashMap的底层是HashTable，通过Node[]进行数据存储；每一个Node是一个key-value键值对，在进行Node存放，即确定节点在Node[]中的存储index时，采用了Hash散列的思想。由于Hash散列的随机性，有时候会出现不同Node同一index的情况，这时候HashMap采用了同一index处采用链表的形式来存储相同index的不同Node。HashMap所在包HashMap位于java.util包下，使用它必须导包。HashMap构造函数HashMap有4个构造函数，源码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 /** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity * (16) and the default load factor (0.75). */ public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted &#125;/** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial * capacity and load factor. * * @param initialCapacity the initial capacity * @param loadFactor the load factor * @throws IllegalArgumentException if the initial capacity is negative * or the load factor is nonpositive */ public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal load factor: " + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); &#125;/** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial * capacity and the default load factor (0.75). * * @param initialCapacity the initial capacity. * @throws IllegalArgumentException if the initial capacity is negative. */ public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR); &#125;/** * Constructs a new &lt;tt&gt;HashMap&lt;/tt&gt; with the same mappings as the * specified &lt;tt&gt;Map&lt;/tt&gt;. The &lt;tt&gt;HashMap&lt;/tt&gt; is created with * default load factor (0.75) and an initial capacity sufficient to * hold the mappings in the specified &lt;tt&gt;Map&lt;/tt&gt;. * * @param m the map whose mappings are to be placed in this map * @throws NullPointerException if the specified map is null */ public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false); &#125;一般情况下，我们默认使用空参构造函数，只有在特殊情况需要调节HashMap性能时会使用包含initialCapacity或loadFactor含参构造函数。HashMap的底层实现]]></content>
      <categories>
        <category>java-se</category>
      </categories>
      <tags>
        <tag>java - HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java -- IO流]]></title>
    <url>%2F2019%2F05%2F14%2Fjava-IO%E6%B5%81%2F</url>
    <content type="text"><![CDATA[java中对于输入输出相关操作进行了抽象，统称为java的IO流操作。这里，我们在以往java文件读写操作（FileWriter和FileReader）基础上，进一步深入学习java的IO流概念。IO流分类根据不同的分类标准，我们可以对IO流进行不同的的划分。现暂以IO流向、IO操作数据类型和IO流功能这三个基准，来对IO流进行大致分类，如下：按流向分名称作用举例输入流读取数据FileReader输出流写出数据FileWriter按数据类型分名称作用举例字节流以byte为单位读写InputStream OutputStream字符流以char为单位读写FileReader FileWriter按功能分（是否直接操作数据源）名称说明举例节点流可以直接从数据源或目的地读写数据FileReaderFileInputStream包装流不直接连接数据源或目的地，是其他流的封装，目的是简化操作或提高效率InputStreamReaderPrintWriterIO流读写操作按照上面的IO流分类，我们也可以将IO流操作分为字节流操作和字符流操作，下面将分别进行介绍：字节流读写 – 二进制文件搬运工计算机文件，本质上就是对一连串“0101XXX”等二进制数据的存储。正因为如此，一切文件（不管是视频、音频、图片，还是普通文本文件）都可以通过对底层二进制数据的读写，以实现特定的复制、修改操作。这里以图片的复制操作为例，相关代码如下：1234567891011121314//1.创建FileInputStream对象和FileOutputStream对象FileInputstream fis = new FileInputStream("hill.jpg");FileOutputStream fos = new FileOutStream("hill_copy.jpg");//2.通过字节数组进行复制int len;byte[] bytes = new byte[1024];while((len = fis.read(bytes)) != -1)&#123; fos.write(bytes, 0, len);&#125;//3.关闭InputStream和OutputStream，释放资源fis.close();fos.close();字符流读写 – 文本文件好帮手特别的，除了像上面那样通过字节流完成读写外，文本文件还可以通过字符流的方式完成读写操作。这是因为文本文件的二进制存储，都是以特定的的编码方式实现的（例如unicode编码）；这意味着当这些二进制数据被读入内存，并存入char型数组时，计算机可以正确地完成相应的编解码工作，不会发生数据丢失的状况。而普通的二进制文件（比如一张图片），由于其二进制存储并未遵循字符编码规则；一旦其被读入内存，并存入字符数组时，计算机会依照相应的编码规则进行解码操作；这时候就会发生有些二进制bit被误当作编码的标志位而丢弃，造成了数据的损坏。下面我们对字符的编解码进行相关总结：编码表可以简单的理解为：一张字符与数值的映射表。根据这张表，计算机可以将内存中存储的数值所对应的字符进行渲染显示。最早的编码表是ASCII，其只覆盖了阿拉伯数字、英文字母和一些常用符号，主要供英语使用；随后各国根据本国语言，相继推出了本国的编码表：例如中国的GBK。由于各国编码表不一致，常常出现文件移动到不同编码的计算机后出现乱码现象，于是一种兼容所有编码规则的编码表Unicode出现了。最先推出Unicode编码时，是将2个字节作为每个字符的存储单元，但很快就不够用了；于是乎推出了用4个字节存储每个字符的规则，这种方案虽然解决了存储单元空间不足的问题，但也同时造成了存储空间的大量浪费（比如用4个字节去存储只占一个字节的字符）。在这样背景下，一种可变单元存储空间的编码规则UTF-8出现了，它本质上还是Unicode，只不过改进了前者的存储规则。另外我们还要提一下ANSI编码，它又叫本地编码表；和上面提到的编码不同，它并不是一种具体的编码规则，而是本地编码的代指。如果你的本地编码是GBK，那么ANSI就是GBK；如果你的本地编码是UTF-8，那么ANSI就是UTF-8。字符串编码要保证字符串写入文件或打印到console时不乱码，基本思路是：编解码前后一致，包括字符集与字节长度123456789101112//以GBK编码写入数据到文件String str = "你好吗？";byte[] bys = str.getBytes("GBK");FileOutputStream fos = new FileOutputStream("a.txt"); //打开文件时必须以GBK编码打开，才能保证不出现乱码fos.write(bys);fos.close();//读取文件中GBK编码数据，并打印到控制台FileInputStream fis = new FileInputStream("a.txt");byte[] bys = new byte[1024];int len = fis.read(bys);System.out.println(new String(bys,0,len,"GBK"));//必须以GBK编码进行解码操作，不然会出现乱码字符流编码字符流 = 字节流 + 编码123456OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream("b.txt"),"GBK");String s = "你好呀";osw.write(s);//这里使用GBK对字符串进行了编码，转为字节流后，然后写入了文件中osw.close();相关文本文件操作详情可以参考之前的总结java – 文本文件读写相关unicode等字符编码可以参考字符编码笔记：ASCII，Unicode 和 UTF-8常用IO流类介绍标准输入输出流有关标准输入输出流，我们在之前的日常编码中经常用到，只不过没有引起我们的关注罢了。诸如向控制台打印System.out.println(&quot;xxxxx&quot;)或者是键盘录入new Scanner(System.in)，我们都可以发现Systemm类的身影。事实上，System中的类字段out以及in就是我们要谈到的标准输出输入流对象。12345678910111213141516171819202122232425262728293031323334/** * The "standard" input stream. This stream is already * open and ready to supply input data. Typically this stream * corresponds to keyboard input or another input source specified by * the host environment or user. */ public final static InputStream in = null; /** * The "standard" output stream. This stream is already * open and ready to accept output data. Typically this stream * corresponds to display output or another output destination * specified by the host environment or user. * &lt;p&gt; * For simple stand-alone Java applications, a typical way to write * a line of output data is: * &lt;blockquote&gt;&lt;pre&gt; * System.out.println(data) * &lt;/pre&gt;&lt;/blockquote&gt; * &lt;p&gt; * See the &lt;code&gt;println&lt;/code&gt; methods in class &lt;code&gt;PrintStream&lt;/code&gt;. * * @see java.io.PrintStream#println() * @see java.io.PrintStream#println(boolean) * @see java.io.PrintStream#println(char) * @see java.io.PrintStream#println(char[]) * @see java.io.PrintStream#println(double) * @see java.io.PrintStream#println(float) * @see java.io.PrintStream#println(int) * @see java.io.PrintStream#println(long) * @see java.io.PrintStream#println(java.lang.Object) * @see java.io.PrintStream#println(java.lang.String) */ public final static PrintStream out = null;相关JDK源码如上，不管是in还是out都是字节流对象；其中in用于读取键盘录入数据，而out用于向屏幕输出数据。OutputStreamWriter &amp;&amp; InputStreamReader由于标准输入输出流处理的都是字节流数据，而我们人类可以识别的只能是字符流数据；一旦我们打算将所谓的字符流数据打印到屏幕，或者是把键盘输入的字节流数据保存为文本文件时，都会不可避免地遇到数据流间相互转化的问题。例如，我们打算将文本文件的字符流数据打印到console，可以采用如下的办法：12345678910111213//read fileBufferedReader br = new BufferedReader(new FileReader("a.txt"));//OutputStreamOutputStream os = System.out;String line;while((line = br.readLine()) != null)&#123; //read file content,and print to console os.write(line.getBytes()); //由于标准输出流对象只能接收字节流，必须得手动将字符流转为字节流 os.write("\n".getBytes());&#125;br.close();os.close();以上方法的不便之处显而易见，这种手动的转换极容易被忽视，进而导致错误。从这一痛点出发，java为我们引入了OutputStreamWriter类，帮助我们自动完成字符流向字节流的转换。使用OutputStreamWriter重写以上方法如下：1234567891011121314//read fileBufferedReader br = new BufferedReader(new FileReader("a.txt"));//print fileBufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));String line = null;while((line = br.readLine()) != null)&#123; //read file content,and print to console bw.write(line); //同OutputStream相比，使用OutputStreamWriter我们只需传入想要打印的字符流对象，而完全不要操心字符流与字节流的转换问题 bw.newLine();&#125;br.close();bw.close();和将文本文件的字符流数据打印到console中类似，我们从键盘录入字节流数据并将其存储在文本文件当中，可以使用InputStreamReader完成字节流向字符流的自动转换。相关代码如下：使用手动转换123456789101112FileWriter fw = new FileWriter("a.txt");InputStream is = System.in;byte[] bys = new byte[1024];int len;while ((len=is.read(bys)) != -1)&#123; fw.write(new String(bys,0,len)); //这里需要手动将键盘录入的字节流转化为字符流 fw.flush();&#125;fw.close();is.close();使用InputStreamReader自动转换123456789101112BufferedWriter bw = new BufferedWriter(new FileWriter("a.txt"));BufferedReader br = new BufferedReader(new InputStreamReader(System.in));String line;while ((line=br.readLine()) != null)&#123; //这里直接通过readLine()读出了字符流，而字节流向字符流的转化由InputStreamReader内部完成 bw.write(line); bw.newLine(); bw.flush();&#125;bw.close();br.close();打印流打印流大体可以分为两类：字符打印流PrintWriter和字节打印流PrintStream。和其他IO流不同的是，打印流仅仅存在输出流类，没有对应的输入流类。由于PrintStream就是我们之前一直谈到到的System.out，这里不再赘述。事实上，PrintWriter已经完全可以取代PrintStream的角色，两者的区别就在于：自动flush，PrintStream一般可以自动刷新，而PrintWriter只有特定方法（如print()）才有PrintStream不能包装一个Writer，即无法读入字符流之所以现在还存在PrintStream，是因为其出现要早于JDK1.1，并且JDK中大量使用了它，例如System.out；如果弃用PrintSteam会给JDK带来巨大的重构麻烦。构造方法至于PrintWriter，它是一个字符流输出类。这里我们一起看一下它的构造函数：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364 public PrintWriter(File file) throws FileNotFoundException &#123; this(new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file))), false); &#125; public PrintWriter(File file, String csn) throws FileNotFoundException, UnsupportedEncodingException &#123; this(toCharset(csn), file); &#125; public PrintWriter(OutputStream out, boolean autoFlush) &#123; this(new BufferedWriter(new OutputStreamWriter(out)), autoFlush); // save print stream for error propagation if (out instanceof java.io.PrintStream) &#123; psOut = (PrintStream) out; &#125; &#125; public PrintWriter(OutputStream out, boolean autoFlush) &#123; this(new BufferedWriter(new OutputStreamWriter(out)), autoFlush); // save print stream for error propagation if (out instanceof java.io.PrintStream) &#123; psOut = (PrintStream) out; &#125; &#125; public PrintWriter(String fileName, String csn) throws FileNotFoundException, UnsupportedEncodingException &#123; this(toCharset(csn), new File(fileName)); &#125; public PrintWriter(String fileName) throws FileNotFoundException &#123; this(new BufferedWriter(new OutputStreamWriter(new FileOutputStream(fileName))), false); &#125;public PrintWriter(Writer out, boolean autoFlush) &#123; super(out); this.out = out; this.autoFlush = autoFlush; lineSeparator = java.security.AccessController.doPrivileged( new sun.security.action.GetPropertyAction("line.separator")); &#125; public PrintWriter(Writer out, boolean autoFlush) &#123; super(out); this.out = out; this.autoFlush = autoFlush; lineSeparator = java.security.AccessController.doPrivileged( new sun.security.action.GetPropertyAction("line.separator")); &#125; private PrintWriter(Charset charset, File file) throws FileNotFoundException &#123; this(new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file), charset)), false); &#125;PrintWriter基本上都是有参构造函数，传入的参数有File对象、Writer字符输出流对象、以及OutputStream字节输出流对象。其中传入的File对象通过调用new BufferedWriter(new OutputStreamWriter(new FileOutputStream(fileName))，最终转为了Writer对象；而OutputStream字节输出流对象，通过new BufferedWriter(new OutputStreamWriter(out))也最终转为了Writer对象。这里我们可以稍微总结一下：PrintWriter由于自身并不具备字符输出功能，因此是一个包装流，它内部通过调用基本流Writer对象完成字符流IO操作。特有成员函数这里我们主要介绍一下PrintWriter有关自动换行和自动刷新的方法。相关代码如下：12PrintWriter pw = new PrintWriter(new FileWriter("a.txt"),true);pw.println("how do u do?");如上所示，我们可以通过构造函数中的第二个boolean参数手动开启自动刷新功能。另外，同System.out.println()类似，PrintWriter同样可以使用println()实现输出换行的目的。注意：即使手动开启了自动刷新，也并不是说PrintWriter中的所有方法调用时都有效果。JDK特别指出，只有当调用print()、println()以及format()方法时，才存在自动刷新效果利用PrintWriter进行文件复制12345678PrintWriter pw = new PrintWriter(new FileWriter("dest.txt"),true);BufferedReader br = new BufferedReader(new FileReader("src.txt"));String line;while ((line=br.readLine()) != null)&#123; pw.println(line);&#125;pw.close();br.close();数据操作流和InputStreamReader、OutputStreamWriter比较类似，都是非字节数组的数据与字节数组之间的转换。不同的是 DataInputStream、DataOutputStream 能够处理的范围更广。例如：InputStreamReader 只能将输入字节流转化为字符串；而DataInputStream 可以将字节流按输入顺序，依次转为int、boolean、String、char类型数据。下面分别从各种数据类型与二进制文件的相互转换以及各种数据类型与字节数组的相互转换两方面来加以介绍：12345678910111213141516171819202122232425262728/** * 各种数据类型与二进制文件的相互转换 *///构造数据输出流对象DataOutputStream dos = new DataOutputStream(new BufferedOutputStream(new FileOutputStream("a.txt")));//通过数据输出流对象，写数据dos.writeBoolean(true);//以UTF-8编码写字符串dos.writeUTF("谁解其中味");dos.writeChar('a');dos.writeInt(0);//这个刷新缓存不用忘记写，不然会报java.io.EOFExceptiondos.flush();//构造数据输入流对象DataInputStream dis = new DataInputStream(new BufferedInputStream(new FileInputStream("a.txt")));//通过数据输入流对象，读数据；注意：必须按写入顺序读取boolean flag = dis.readBoolean();String str = dis.readUTF();char c = dis.readChar();int num = dis.readInt();System.out.println(flag);System.out.println(str);System.out.println(c);System.out.println(num);1234567891011121314151617181920212223242526272829303132/** * 各种数据类型与字节数组的相互转换 *///构造数据输出流对象ByteArrayOutputStream baos = new ByteArrayOutputStream();DataOutputStream dos = new DataOutputStream(new BufferedOutputStream(baos));//通过数据输出流对象，写数据dos.writeBoolean(true);//以UTF-8编码写字符串dos.writeUTF("谁解其中味");dos.writeChar('a');dos.writeInt(0);//这个刷新缓存不用忘记写，不然会报java.io.EOFExceptiondos.flush();//输出字节数组byte[] src = baos.toByteArray();//构造数据输入流对象DataInputStream dis = new DataInputStream(new BufferedInputStream(new ByteArrayInputStream(src)));//通过数据输入流对象，读数据；注意：必须按写入顺序读取boolean flag = dis.readBoolean();String str = dis.readUTF();char c = dis.readChar();int num = dis.readInt();System.out.println(flag);System.out.println(str);System.out.println(c);System.out.println(num);对象操作流顾名思义，这是一个用于读写对象的IO流。按照惯例，我们同样可以将其分为两类：对象输入流ObjectInputStream以及对象输出流ObjectOutputStream下面对这两个类进行详细介绍：类名构造方法常用成员方法ObjectOutputStreamObjectOutputStream(OutputStream out)void writeObject(Object obj)ObjectInputStreamObjectInputStream(InputStream in)Object readObject()注意事项需要指出的是，我们在使用对象操作流进行对象读写时，需要注意对象所在类是否实现了Serializable接口，不然会报java.io.NotSerializableException。除此之外，我们在对象类中还需手动指定序列化IDserialVersionUID，以防止读取已经保存的对象流文件时，由于对象所属类的修改，产生的文件中保存的序列化ID和类中自动计算的序列化ID不一致的异常。这种情况下，通常会报java.io.InvalidClassException xxxxxx local class incompatible等异常。比较稳妥的写法如下：123456789101112131415161718192021222324252627282930313233343536public class ObjectOutputStream&#123; public static void main()&#123; ObjectOutputStream oos = new ObjectOutputStream((new FileOutputStream("a.txt"))); Student stu = new Student("ZhangSan",19); Student stu2 = new Student("LiSi",20); oos.writeObject(stu); oos.writeObject(stu2); oos.close(); &#125;&#125;class Student implements Serializable&#123; //要操作的对象流所在类需要实现Serializable接口 //这里手动指定了类的序列化IDenumerate private static final long serialVersionUID = 480241723845934527L; private String name; private int age; private String gender; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public String toString() &#123; return "Student&#123;" + "name='" + name + '\'' + ", age=" + age + ", gender='" + gender + '\'' + '&#125;'; &#125;&#125;最后还需注意的是：我们在上面代码中用对象操作流输出了两个对象到文件中，但当我们需要从文件中读取这些对象时，很自然的会遇到需要确定读取对象个数的问题。比如下面代码：123456789101112ObjectInputStream ois = new ObjectInputStream(new FileInputStream("a.txt"));Object o = ois.readObject();System.out.println(o);Object o2 = ois.readObject();System.out.println(o2);//Exception in thread "main" java.io.EOFExceptionObject o3 = ois.readObject();System.out.println(o3);ois.close();在执行到Object o3 = ois.readObject()，会抛出异常java.io.EOFException，原因是此时文件已经读到尾了。和之前读取文件中的字符或字节流不同的是，之前一旦读到文件末尾我们可以通过返回-1的方式获知情况并终止读取操作；而在读取对象输出流文件中却没有这种机制，我们只能通过捕获异常手动处理方式来解决。事实上，像这种读取多对象输出流文件的问题，我们可以考虑用一个集合存储多个对象，再将集合以对象流的形式写入文件；这样一来，在读取文件时就不用关系读取对象个数的问题了。本着这个思想，将上述代码重构如下：1234567891011ObjectOutputStream oos = new ObjectOutputStream((new FileOutputStream("b.txt")));ArrayList&lt;Student&gt; stus = new ArrayList&lt;Student&gt;();stus.add(new Student("WangWu",30));stus.add(new Student("ZhaoLiu",23));oos.writeObject(stus);oos.close();ObjectInputStream ois = new ObjectInputStream(new FileInputStream("b.txt"));Object obj = ois.readObject();System.out.println(obj);ois.close();Properties – 配置文件读写能手一种特殊的双列集合，实现了Map接口，继承了Hashtable。不同于HashMap，Properties中的键值对都为String类型。另外，由于Properties实现了属性集的持久化，故又称之为属性列表。构造方法123456789101112131415/** * Creates an empty property list with no default values. */ public Properties() &#123; this(null); &#125; /** * Creates an empty property list with the specified defaults. * * @param defaults the defaults. */ public Properties(Properties defaults) &#123; this.defaults = defaults; &#125;如上，Properties提供了两个构造方法；空参的构造方法用于实例化一个空的属性列表，有参的构造方法可以生成一个指定默认值的属性列表。常用成员方法由于Properties实现了Map接口，理论上Map的方法其都可以调用。例如增加属性，我们可以使用put(key,value)；删除属性，则可以使用remove(key)。但Properties类的官方注释并不推荐我们这么做，理由是使用Map接口的put(key,value)方法可以增加非字符串的属性行，这将导致Properties中storehesava方法的调用失败。这里我们将Properties中的常用方法总结如下：方法名描述Object setProperty(String key, String value)新增Properties属性行getProperty(String key)查询指定key的属性值String getProperty(String key, String defaultValue)查询指定key的属性值，没有则返回默认值另外，日常工作中我们会经常使用Properties来进行属性文件的读写，因此特将Properties的IO操作总结如下：使用Properties中的void list(PrintWriter out)或void store(Writer writer, String comments)将属性写入文本文件：​ 使用list()123456789Properties prop = new Properties();prop.setProperty("001","LiSi");prop.setProperty("002","ZhangSan");prop.setProperty("003","ZhaoSi");System.out.println(prop);PrintWriter pw = new PrintWriter("a.txt");prop.list(pw);pw.close();​ 使用store()123456789101112131415161718Properties prop = new Properties();prop.setProperty("001","ZhangSan");prop.setProperty("002","LiSi");prop.setProperty("003","WangWu");prop.setProperty("004","ZhaoLiu");System.out.println(prop);OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream("b.txt"));FileOutputStream fos = new FileOutputStream("c.txt");PrintStream ps = System.out;prop.store(osw,null);prop.store(fos,null);prop.store(ps,null);osw.close();fos.close();ps.close();使用Properties中的void load(Reader reader)从文件中读取属性：12345Properties prop = new Properties();FileReader fr = new FileReader("a.txt");prop.load(fr);fr.close();System.out.println(prop);]]></content>
      <categories>
        <category>java-se</category>
      </categories>
      <tags>
        <tag>java - IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java -- 增强for循环]]></title>
    <url>%2F2019%2F05%2F14%2Fjava-%E5%A2%9E%E5%BC%BAfor%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[是什么增强for循环是JDK1.5后引入java的一种语法，其目的主要是方便遍历集合中的元素。干什么对于集合的遍历，我们先看一个例子：12345678910111213Collection&lt;String&gt; c = new ArrayList&lt;String&gt;();c.add("I");c.add("love");c.add("java");for(String str:c)&#123; System.out.println(str);&#125;输出为：Ilovejava这种方法相对于以前的将集合转数组，抑或是通过迭代器遍历，都显得更为简单直接。什么时候可以用在JDK文档中指出，凡是实现了iterable接口的子类对象都可以使用增强for循环。注意如果我们在增强for中，同时修改了遍历集合，就会抛出ConcurrentModificationException异常。这里为深入了解其中机制，我们有必要知道增强for在遍历时，到底做了什么？利用反编译工具procyon.jar，我们对上述代码进行了反编译，过程如下：12345678910111213141516171819202122rqsir@rqsir-TM1604:~/IdeaProjects/EnhancedForLoop/out/production/EnhancedForLoop$ java -jar /opt/procyon.jar -b EnhancedForLoopTest.classpublic class EnhancedForLoopTest &#123; public void EnhancedForLoopTest() &#123; invokespecial:Object(Object::&lt;init&gt;, this:EnhancedForLoopTest) &#125; public static void main(java.lang.String[] args) &#123; c : Collection&lt;String&gt; var_2_29 : Iterator&lt;String&gt; str : String c = initobject:ArrayList&lt;String&gt;[expected:Collection&lt;String&gt;](ArrayList&lt;E&gt;::&lt;init&gt;) invokeinterface:boolean(Collection&lt;String&gt;::add, c:Collection&lt;String&gt;, ldc:String("I")) invokeinterface:boolean(Collection&lt;String&gt;::add, c:Collection&lt;String&gt;, ldc:String("love")) invokeinterface:boolean(Collection&lt;String&gt;::add, c:Collection&lt;String&gt;, ldc:String("java")) var_2_29 = invokeinterface:Iterator&lt;String&gt;(Collection&lt;String&gt;::iterator, c:Collection&lt;String&gt;) while (invokeinterface:boolean(Iterator&lt;E&gt;::hasNext, var_2_29:Iterator&lt;String&gt;)) &#123; str = checkcast:String(java.lang.String.class, invokeinterface:String(Iterator&lt;String&gt;::next, var_2_29:Iterator&lt;String&gt;)) invokevirtual:void(PrintStream::println, getstatic:PrintStream(System::out), str:String) &#125; &#125;从上面的反编译结果中，我们不能发现，所谓的增强for循环，实际上是由编译器在底层帮我们装换成了iterator的while遍历。既然调用了iterator，那么并发修改就需要上心了，详情可以参考java – 迭代器并发修改异常]]></content>
      <categories>
        <category>java-se</category>
      </categories>
      <tags>
        <tag>java - 增强for</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java -- 文件管家File类]]></title>
    <url>%2F2019%2F05%2F14%2Fjava-%E6%96%87%E4%BB%B6%E7%AE%A1%E5%AE%B6File%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[类初识File是java中文件管理工具类，主要负责文件和目录的相关操作。JDK1.8中对其描述如下：12345678910111213* An abstract representation of file and directory pathnames.** &lt;p&gt; User interfaces and operating systems use system-dependent &lt;em&gt;pathname* strings&lt;/em&gt; to name files and directories. This class presents an* abstract, system-independent view of hierarchical pathnames. An* &lt;em&gt;abstract pathname&lt;/em&gt; has two components:** &lt;ol&gt;* &lt;li&gt; An optional system-dependent &lt;em&gt;prefix&lt;/em&gt; string,* such as a disk-drive specifier, &lt;code&gt;"/"&lt;/code&gt;&amp;nbsp;for the UNIX root* directory, or &lt;code&gt;"\\\\"&lt;/code&gt;&amp;nbsp;for a Microsoft Windows UNC pathname, and* &lt;li&gt; A sequence of zero or more string &lt;em&gt;names&lt;/em&gt;.* &lt;/ol&gt;需要指出的是 ，File对象并不一定是一个实际存在的物理对象，它仅表示对指定path的文件或目录的抽象描述；最终生成文件和目录，还得依赖于相关的成员函数如createNewFile()或mkdir()等。所在包File类位于java.io包下，使用时需要导包。构造函数File共有6个构造方法，其中2个为私有构造方法，主要供其类部使用，这里不谈；剩余的4个公有构造函数，详情见下表所示：构造方法名介绍File(File parent, String child)通过父目录File对象和待创建目录或文件名，生成一个File对象File(String parent, String child)通过父目录名和待创建目录或文件名，生成一个File对象File(String pathname)通过指定完整路径名，生成一个File对象File(URI uri)通过指定完整路径的URI，生成一个File对象常用成员方法由于File类中方法比较多，我们这里简单地分类如下：负责创建文件和目录的方法创建的方法描述boolean createNewFile()创建新文件boolean mkdir()创建新单级目录boolean mkdirs()创建新多级目录负责删除文件和目录的方法删除的方法描述boolean delete()删除指定文件和目录（目录必须为空）负责获取文件和目录属性的方法获取的方法描述File getAbsoluteFile()获取绝对路径的File对象String getAbsolutePath()获取File对象的绝对路径String getParent()获取File对象的父路径File getParentFile()获取File对象的父File对象String getName()获取文件或目录名称String getPath()获取文件或目录创建时指定的路径（绝对或相对路径）long lastModified()以毫秒值返回文件或目录最后修改时间long length()返回文件的字节数负责判断文件和目录行为的方法判断的方法描述boolean exists()判断文件或目录是否存在boolean isAbsolute()判断文件或目录路径是否为绝对路径boolean isDirectory()判断是否为目录对象boolean isFile()判断是否为文件对象boolean isHidden判断是否为隐藏文件或目录负责修改文件和目录属性的方法修改的方法描述boolean renameTo(File dest)将文件或目录路径修改为dest的路径除此之外，有一些与文件遍历有关的方法，我们需重点掌握，总结如下：遍历的方法描述String[] list()获取目录下所有文件和目录，以String类型返回File[] listFiles()获取目录下所有文件和目录，以File类型返回File[] listRoots()获取文件系统的根目录，win下为盘符，linux下为“\”，以File类型返回]]></content>
      <categories>
        <category>java-se</category>
      </categories>
      <tags>
        <tag>java - File类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java -- 泛型]]></title>
    <url>%2F2019%2F05%2F14%2Fjava-%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[为什么要引入泛型先看一个例子，有如下代码：123456789101112131415161718192021222324252627282930public class Demo&#123; public static void main(String[] args)&#123; Student stu = new Student("zhangsan", 32); Student stu2 = new Student("lisi", 24); Collection c = new ArrayList(); c.add(stu); c.add(stu2); Iterator it = c.iterator(); while(it.hasNext())&#123; String str = (String)it.next(); System.out.println(str); &#125; &#125;&#125;class Student&#123; String name; int age; public Student()&#123; &#125; public Studnet(String name, int age)&#123; this.name = name; this.age = age; &#125;&#125;输出结果如下：12Exception in thread "main" java.lang.ClassCastException: Student cannot be cast to java.lang.String at GenericTest.main(GenericTest.java:16)这是一个java中的类型转换异常，发生的原因是我们无法将一个Student类强转为String类，因为它们之间没有继承关系。针对这种问题，java为我们提供了一种叫做泛型的机制，在编译期间就明确集合中存储元素类型，规避掉了这种不安全的转换情景。修改如下：1234567891011121314151617181920212223242526272829303132public class GenericTest &#123; public static void main(String[] args)&#123; Student stu = new Student("zhangsan", 32); Student stu2 = new Student("lisi", 24); //在声明及初始化集合变量时，就通过“&lt;Student&gt;”指明元素类型 Collection&lt;Student&gt; c = new ArrayList&lt;Student&gt;(); c.add(stu); c.add(stu2); //由于迭代器的底层操作的是集合的副本，也可以通过泛型机制指明元素类型 Iterator&lt;Student&gt; it = c.iterator(); while(it.hasNext())&#123; Student s = it.next(); System.out.println(s.name+"---"+s.age); &#125; &#125;&#125;class Student&#123; String name; int age; public Student()&#123; &#125; public Student(String name, int age)&#123; this.name = name; this.age = age; &#125;&#125;泛型给我们带来了什么泛型的好处归纳起来，有如下几点：规避了不安全类型转换问题减少IDE警告可以简化代码书写（不用手动进行类型转换）什么时候可以使用泛型是否可以使用泛型，具体以API为准；原理上只要带有&lt;E&gt;标志的类或接口，都可以使用泛型。]]></content>
      <categories>
        <category>java-se</category>
      </categories>
      <tags>
        <tag>java - 泛型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java -- 迭代器并发修改异常]]></title>
    <url>%2F2019%2F05%2F14%2Fjava-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%B9%B6%E5%8F%91%E4%BF%AE%E6%94%B9%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[问题描述我们在使用iterator对象遍历集合时，时常会遇到ConcurrentModificationException这类的错误例如：123456789101112Collection c = new ArrayList(); c.add("I"); c.add("love"); c.add("java"); Iterator&lt;String&gt; it = c.iterator(); while (it.hasNext())&#123; if(it.next().equals("love")) c.add("Oracle"); //在使用迭代器遍历集合时，修改了原集合 &#125;输出为1234Exception in thread "main" java.util.ConcurrentModificationException at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:909) at java.util.ArrayList$Itr.next(ArrayList.java:859) at IteratorTest.main(IteratorTest.java:15)这主要是因为，迭代器遍历集合，实际上是对集合的副本进行操作；这期间，如果迭代器发现自己和集合不一样了，就会报ConcurrentModificationException异常。原因 – 迭代器的并发检测我们可以从JDK源码的获知，当程序执行到it.next()，实际上调用了如下代码：1234567891011public E next() &#123; checkForComodification(); //在这里迭代器将自己与原始集合进行了比较 int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i];&#125;对于第一个函数checkForComodification()，其源码如下：1234final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException();&#125;这个方法主要是通过比较modConut和expectedModCount是否相等，来判断迭代器运行期间，原集合是否发生了变化。其中modCount为ArrayList的类成员变量，用来记录其变化次数；而expectedModCount作为迭代器成员变量，则存储了iterator初始化时记录到的ArrayList中的modCount值。两者相比，即可判断集合是否在迭代器操作期间发生了变化。解决方法为了解决这个并发修改异常，最直接的方法就是在iterator运行期间，不要修改原集合。但万一我们业务需要，必须得修改，又该怎么办呢？既然不允许我们直接修改原集合，那么我们可以考虑通过迭代器去间接操作原集合。通过查询API文档，我们在Iterator接口中并未发现add()方法。既然根类Iterator中没有，我们就到其子接口中去寻找。不出所料，在其Iterator子接口ListIterator中，我们发现了add()方法。首先看一下它的源码：12345678910111213public void add(E e) &#123; checkForComodification(); try &#123; int i = cursor; ArrayList.this.add(i, e); //调用了ArrayList当前对象的成员方法 cursor = i + 1; lastRet = -1; expectedModCount = modCount; //这里将expectedModCount与modCount进行了同步 &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125;从源码中，我们可以看到，虽然仍然存在并发检测函数checkForComodification()，但add()在内部为我们完成了集合元素的添加，最最关键的是它还进行了expectedModCount与modCount同步操作，这就保证了并发修改异常不会被触发。终上所述，最开始的问题代码可以修改如下：12345678910111213//这里将c的引用类型从Collection换成List，是因为Collection接口中没有listIterator()方法，多态无法调用父接口中没有的方法 List c = new ArrayList(); c.add(&quot;I&quot;); c.add(&quot;love&quot;); c.add(&quot;java&quot;); ListIterator&lt;String&gt; it = c.listIterator();//理由同上，Iterator中没有add方法 while (it.hasNext())&#123; if(it.next().equals(&quot;love&quot;)) it.add(&quot;Oracle&quot;); &#125;]]></content>
      <categories>
        <category>java-se</category>
      </categories>
      <tags>
        <tag>java - 迭代器并发修改异常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中的常用数据结构]]></title>
    <url>%2F2019%2F05%2F14%2Fjava%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[java中为我们提供了很多实用的数据结构，常用的大体上分为两大类：根类为AbstractCollection的单集合容器，以及根类为AbstractMap&lt;K，V&gt;的双集合容器。我们一般本着从最顶层（顶层包含该数据结构的所有公共方法和字段）开始学习，从最底层（顶层包含数据结构的具体实现和特有方法）开始使用的原则，来总结以上两大数据容器。AbstractCollection – 单集合容器如上图所示：AbstractCollection这个抽象类实际上实现了对应接口Collection，在Collection中定义了所有单集合容器都应具有的特性。首先我们一起看一下Collection接口的JDK注释12345678* The root interface in the &lt;i&gt;collection hierarchy&lt;/i&gt;. A collection* represents a group of objects, known as its &lt;i&gt;elements&lt;/i&gt;. Some* collections allow duplicate elements and others do not. Some are ordered* and others unordered. The JDK does not provide any &lt;i&gt;direct&lt;/i&gt;* implementations of this interface: it provides implementations of more* specific subinterfaces like &lt;tt&gt;Set&lt;/tt&gt; and &lt;tt&gt;List&lt;/tt&gt;. This interface* is typically used to pass collections around and manipulate them where* maximum generality is desired.从中，我们可以总结出Collection的几大特点：子类中既存在允许重复值（如LinkedList、ArrayList），也存在不允许重复值（如HashSet）子类中既存在有序的（如LinkedList、ArrayList），也存在无序的（如HashSet）子类中既存在不包含index的（如HashSet），也存在包含index的（如LinkedList、ArrayList）对应Collection的一些共有的抽象方法，如下图所示：其中Collection的增、删,分别对应着add(E element)、remove(Object)、clear()（清空集合）另外，集合的遍历涉及到的两个函数toArray()以及iterator()，我们需重点掌握。使用toArray()遍历集合1234567891011//利用了向上多态转型Collection c = new ArrayList(); c.add("I");c.add("love");c.add("java");//利用数组遍历集合，使用toArray()函数Object[] arr = c.toArray();for(int i=0; i&lt;arr.length; i++)&#123; System.out.println(arr[i]);&#125;使用迭代器Iterator遍历集合1234567891011//利用了向上多态转型Collection c = new ArrayList();c.add("I");c.add("love");c.add("java");//利用迭代器遍历集合，使用iterator()函数Iterator it = c.iterator();while(it.hasNext())&#123; System.out.println(it.next());&#125;注意：使用迭代器时不要对原集合进行操作，否则会出现并发修改异常Collection子类精讲说完了Collection父类的的共有特性和通用操作，现在聊聊其具体子类的一些独有特点。通过继承关系图，我们可以知道Collection可以分为四类：Queue、Deque、List和Set。下面我们主要谈谈List和Set：List接口先来一段JDK说明123456789101112* An ordered collection (also known as a &lt;i&gt;sequence&lt;/i&gt;). The user of this* interface has precise control over where in the list each element is* inserted. The user can access elements by their integer index (position in* the list), and search for elements in the list.&lt;p&gt;** Unlike sets, lists typically allow duplicate elements. More formally,* lists typically allow pairs of elements &lt;tt&gt;e1&lt;/tt&gt; and &lt;tt&gt;e2&lt;/tt&gt;* such that &lt;tt&gt;e1.equals(e2)&lt;/tt&gt;, and they typically allow multiple* null elements if they allow null elements at all. It is not inconceivable* that someone might wish to implement a list that prohibits duplicates, by* throwing runtime exceptions when the user attempts to insert them, but we* expect this usage to be rare.&lt;p&gt;其特点可以用如下关键词形容：有序、存在索引、允许重复常用方法有add(int index, E element)、remove(int index)、set(int index, E element)、get(int index)，这些是不同于Collection，List所特有的方法。LinkList和ArrayList之大比拼在父接口List下，我们接触最多的就是LinkList和ArrayList了。下表是对它们的总结：类名特点特有方法ArrayList底层用可变数组对List进行了实现按index查找很快–O(1)但按值进行查找速度很慢–O(n)修改元素–O(1)删除涉及到数组的移位，也很慢–O(n)尾部添加元素，需要扩大数组–O(n)指定位置添加，需要移动其他元素–O(n)没有，方法基本和List一样LinkedList底层用双向链表实现按index查找不能像数组那样，还是得一个节点一个节点遍历–O(n)按值查找同上–O(n)修改元素和删除很快–O(1)尾部添加元素–O(1)指定位置添加元素–O(1)addFirst(E e)addLast(E e)getFirst( )getLast( )removeFirst( )removeLast( )使用指南：如果业务查询多，添加和删除少，优先考虑ArrayList如果业务添加和删除多，查询少，优先考虑LinkedList一般情况，使用ArrayList就可以了set接口首先看一下其JDK注释：1234* A collection that contains no duplicate elements. More formally, sets* contain no pair of elements &lt;code&gt;e1&lt;/code&gt; and &lt;code&gt;e2&lt;/code&gt; such that* &lt;code&gt;e1.equals(e2)&lt;/code&gt;, and at most one null element. As implied by* its name, this interface models the mathematical &lt;i&gt;set&lt;/i&gt; abstraction.set的概念和数学上集合的概念基本一致，即：无序、无重复、无索引其常用方法和Collection一样：add(E element)、remove(Object)和clear()HashSet – 存储自定义对象先看一下JDK中对其的定义：12345* This class implements the &lt;tt&gt;Set&lt;/tt&gt; interface, backed by a hash table* (actually a &lt;tt&gt;HashMap&lt;/tt&gt; instance). It makes no guarantees as to the* iteration order of the set; in particular, it does not guarantee that the* order will remain constant over time. This class permits the &lt;tt&gt;null&lt;/tt&gt;* element.从以上注释可知，HaseSet的底层是由HashMap实现的。这里我们可以看一下其源码实现：123456789101112131415161718 * Adds the specified element to this set if it is not already present. * More formally, adds the specified element &lt;tt&gt;e&lt;/tt&gt; to this set if * this set contains no element &lt;tt&gt;e2&lt;/tt&gt; such that * &lt;tt&gt;(e==null&amp;nbsp;?&amp;nbsp;e2==null&amp;nbsp;:&amp;nbsp;e.equals(e2))&lt;/tt&gt;. * If this set already contains the element, the call leaves the set * unchanged and returns &lt;tt&gt;false&lt;/tt&gt;. * * @param e element to be added to this set * @return &lt;tt&gt;true&lt;/tt&gt; if this set did not already contain the specified * element * public boolean add(E e) &#123; return map.put(e, PRESENT)==null; //这里调用了成员变量map的put方法 &#125; private transient HashMap&lt;E,Object&gt; map;// Dummy value to associate with an Object in the backing Map private static final Object PRESENT = new Object();AbstractMap – 双集合容器如图，AbstractMap是相对于AbstractCollection而言，又一抽象数据结构的顶层父类。不同于AbstractCollection单集合特点，在AbstractMap结构中存在着两个集合，且维护着这两个集合之间的对应关系。先看一段JDK注释：12345678910111213* An object that maps keys to values. A map cannot contain duplicate keys;* each key can map to at most one value.** &lt;p&gt;This interface takes the place of the &lt;tt&gt;Dictionary&lt;/tt&gt; class, which* was a totally abstract class rather than an interface.** &lt;p&gt;The &lt;tt&gt;Map&lt;/tt&gt; interface provides three &lt;i&gt;collection views&lt;/i&gt;, which* allow a map's contents to be viewed as a set of keys, collection of values,* or set of key-value mappings. The &lt;i&gt;order&lt;/i&gt; of a map is defined as* the order in which the iterators on the map's collection views return their* elements. Some map implementations, like the &lt;tt&gt;TreeMap&lt;/tt&gt; class, make* specific guarantees as to their order; others, like the &lt;tt&gt;HashMap&lt;/tt&gt;* class, do not.从中，我们可以总结Map的几大特点：keys –&gt;value映射、key是set、value是CollectionMap中常用方法有：方法作用void clear()清空mapSet&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()返回map中键值对集合boolean equals(Object o)比较两个map是否相等int hashCode()计算map的hash值V get(Object key)根据key获取map中valueV put(K key, V value)map中添加key-value对V remove(Object key)根据key移除键值对SetkeySet()获取map所有的keyCollectionvalues()获取map所有的valueSet&lt;Entry&lt;K,V&gt;&gt; entrySet()获取键值对集合Map内部接口Entry&lt;K,V&gt;中常用方法：方法作用K getKey()获取键值对中的keyV getValue()获取键值对中valueV setValue(V value)设置键值对中的valueboolean equals(Object o)比较两个键值对是否相等int hashCode()返回键值对的hash值同上，map的遍历我们也有两种方法：使用keySet()和get(Object key)进行map遍历整个过程可以简单理解成：先获取“key集合”，再通过key找value，获取全部键值对，代码如下：12345Set&lt;K&gt; keys = map.keySet();for(K key:keys)&#123; V value = map.get(key); System.out.println(key + "----" + value);&#125;使用entrySet()进行遍历整个过程可以理解为：先获取”键值对集合“，再通过键值对，获取key和value123456Set&lt;Map.Entry&lt;K,V&gt;&gt; entries = map.enrtySet();for(Map.Entry&lt;K,V&gt; entry:entries)&#123; K key = entry.getKey(); V value = entry.getValue(); System.out.println(key + "----" + value);&#125;Map子类精讲这里我们主要总结HashMap的常用操作，详情请参考java – HashMap详解]]></content>
      <categories>
        <category>java-se</category>
      </categories>
      <tags>
        <tag>java - 数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux中的SysRq魔术键]]></title>
    <url>%2F2019%2F05%2F02%2Flinux%E4%B8%AD%E7%9A%84SysRq%E9%AD%94%E6%9C%AF%E9%94%AE%2F</url>
    <content type="text"><![CDATA[接触SysRq完全是一种巧合。由于平时手比较欠，总是冷不丁地就将ubuntu给整死机了，这要是在以前我大概是选择按下电源键重启了。但这样做的危害也是显而易见的，轻则数据丢失，重则系统直接挂掉重启一片黑。于是乎，我给自己告诫再三：死机切记不要暴力重启。linux应对死机三步骤经过多方查阅与实践总结，我大致摸索出了如下应对系统死机的解决方案，流程如下：如果死机是由xwindow等窗口程序引起的，如因为gnome导致的假死机，这时候可以按下alt+F2调出gnome运行窗口，接着输入r回车，来刷新gnome。如果第一步不奏效，可能是xwindow已经挂掉了，这时候可以选择进入tty终端。按下快捷键组合ctrl+alt+F3就进入了tty3（类似的还可以进入tty4、tty5等）。这是一个类似shell的界面，在这里我们可以先通过top命令获取高cpu占用进程，再通过pkill 进程名或者kill -9 pid的方式杀死死锁进程。最后通过ctrl+alt+F2返回xwindow界面。如果以上都无效，那大概率是系统定底层出现了问题，这时候就要祭出SysRq魔术键了。什么是SysRqSysRq 经常被称为 Magic System Request，它被定义为一系列按键组合。当系统因为某种原因已经停止对大部分正常服务的响应，但是系统仍然可以响应键盘的按键中断请求。在这种情况下，SysRq 的按键组合将发挥它的神奇作用。通过它，不但可以在保证磁盘数据安全的情况下重启一台挂起的服务器，避免数据丢失和重启后长时间的文件系统检查，还可以收集包括系统内存使用，CPU 任务处理，进程运行状态等系统运行信息，甚至还可能在无需重启的情况下挽回一台已经停止响应的服务器。启动SysRq首先检查SysRq是否开启1cat /proc/sys/kernel/sysrq若输出为0，则还未开启。可以通过systcl命令开启SysRq，命令如下：1sudo sysctl -w kernel.sysrq=1由于以上操作只在本次开机运行时有效，为保证下次开机SysRq服务自动启用，需进行如下配置：编辑/etc/sysctl.conf，添加如下一行内容(或去掉其前注释)1kernel.sysrq = 1常用SysRq组合键R-E-I-S-U-B – 安全重启万精油1234567891011121314151617R - 把键盘设置为 ASCII 模式 (用于接收后面键盘输入) SysRq: Keyboard mode set to XLATE E - 向除 init 以外所有进程发送 SIGTERM 信号 (让进程自己正常退出) SysRq: Terminate All Tasks I - 向除 init 以外所有进程发送 SIGKILL 信号 (强制结束进程) SysRq: Kill All Tasks S - 磁盘缓冲区同步 SysRq : Emergency Sync U - 重新挂载为只读模式 SysRq : Emergency Remount R/O B - 立即重启系统 SysRq: Resetting由于系统环境与后台进程个数的不确定性，每一步按键操作执行完成所费时间无法确定。为保险起见，一般采用R – 1 秒 – E – 30 秒 – I – 10 秒 – S – 5 秒 – U – 5 秒 – B，而不是一气呵成地按下这六个键。E-I-K – 解决系统假死利器有时候系统的死机仅仅是因为个别进程过分消耗cpu或内存等系统资源所引发的，这时候就没有必要非得重启来解决问题。我们需要做的就是找出“幕后黑手”，结束掉该进程就行了。123456789101112E - 向除 init 以外所有进程发送 SIGTERM 信号 (让进程自己正常退出) SysRq: Terminate All Tasks I - 向除 init 以外所有进程发送 SIGKILL 信号 (强制结束进程) SysRq: Kill All Tasks K - 结束与当前控制台相关的全部进程 SysRq : SAK F - 人为触发 OOM Killer (可选，除非可以确认是内存使用问题，尽量避免使用这个组合键) SysRq : Manual OOM execution (OOM Killer 将根据各进程的内存处理情况选取最合适的“凶手”进程，并向其发送 SIGKILL 信 号，中 止其运行。)M-P-T-W – 系统死机证据收集机SysRq 提供了 M-P-T-W 序列，在恢复系统挂起之前，这是一个推荐执行的序列。它会记录下当前系统的内存使用情况，当前 CPU 寄存器的状态，进程运行状态，以及所有 CPU 及寄存器的状态。通过这些信息，可以对挂起的原因做粗略的分析。1234567891011M - 打印内存使用信息 SysRq : Show Memory P - 打印当前 CPU 寄存器信息 SysRq : Show Regs T - 打印进程列表 SysRq : Show State W - 打印 CPU 信息 SysRq : Show CPUs其它功能键组合12345678H - 帮助 它显示了当前系统支持的所有 SysRq 组合，所有的按键均用大写字母表示。 C - 触发 Crashdump 更详细系统挂起的诊断和数据收集 N - 降低实时任务运行优化级 这对于由实时任务消耗 CPU 引起的系统挂起会起到立竿见影的作用。查看SysRq输出输出到本地终端SysRq 默认会根据console_loglevel输出到本地终端。只要 console_loglevel 大于 default_message_loglevel，SysRq信息就会输出到本地控制台终端。输出到 syslog根据 syslog 的默认配置，SysRq默认会记录到 /var/log/messages，并且这里记录的信息与console_loglevel 无关，基本是完整的。但是由于负责记录日志的 syslogd 本身也是一个用户进程，在执行后面即将介绍的 SysRq-E, SysRq-I 时也会被终结，这就意味着 syslog 记录的信息在一定情况下将不再完整。通过 netconsole 输出输出到串口终端附录 – SysRq.txt123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173Linux Magic System Request Key HacksDocumentation for sysrq.c version 1.15Last update: $Date: 2001/01/28 10:15:59 $* What is the magic SysRq key?~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~It is a &apos;magical&apos; key combo you can hit which the kernel will respond toregardless of whatever else it is doing, unless it is completely locked up.* How do I enable the magic SysRq key?~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~You need to say &quot;yes&quot; to &apos;Magic SysRq key (CONFIG_MAGIC_SYSRQ)&apos; whenconfiguring the kernel. When running a kernel with SysRq compiled in,/proc/sys/kernel/sysrq controls the functions allowed to be invoked viathe SysRq key. By default the file contains 1 which means that everypossible SysRq request is allowed (in older versions SysRq was disabledby default, and you were required to specifically enable it at run-timebut this is not the case any more). Here is the list of possible valuesin /proc/sys/kernel/sysrq: 0 - disable sysrq completely 1 - enable all functions of sysrq &gt;1 - bitmask of allowed sysrq functions (see below for detailed function description): 2 - enable control of console logging level 4 - enable control of keyboard (SAK, unraw) 8 - enable debugging dumps of processes etc. 16 - enable sync command 32 - enable remount read-only 64 - enable signalling of processes (term, kill, oom-kill) 128 - allow reboot/poweroff 256 - allow nicing of all RT tasksYou can set the value in the file by the following command: echo &quot;number&quot; &gt;/proc/sys/kernel/sysrqNote that the value of /proc/sys/kernel/sysrq influences only the invocationvia a keyboard. Invocation of any operation via /proc/sysrq-trigger is alwaysallowed.* How do I use the magic SysRq key?~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~On x86 - You press the key combo &apos;ALT-SysRq-&lt;command key&gt;&apos;. Note - Some keyboards may not have a key labeled &apos;SysRq&apos;. The &apos;SysRq&apos; key is also known as the &apos;Print Screen&apos; key. Also some keyboards cannot handle so many keys being pressed at the same time, so you might have better luck with &quot;press Alt&quot;, &quot;press SysRq&quot;, &quot;release Alt&quot;, &quot;press &lt;command key&gt;&quot;, release everything.On SPARC - You press &apos;ALT-STOP-&lt;command key&gt;&apos;, I believe.On the serial console (PC style standard serial ports only) - You send a BREAK, then within 5 seconds a command key. Sending BREAK twice is interpreted as a normal BREAK.On PowerPC - Press &apos;ALT - Print Screen (or F13) - &lt;command key&gt;, Print Screen (or F13) - &lt;command key&gt; may suffice.On other - If you know of the key combos for other architectures, please let me know so I can add them to this section.On all - write a character to /proc/sysrq-trigger. eg: echo t &gt; /proc/sysrq-trigger* What are the &apos;command&apos; keys?~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&apos;r&apos; - Turns off keyboard raw mode and sets it to XLATE.&apos;k&apos; - Secure Access Key (SAK) Kills all programs on the current virtual console. NOTE: See important comments below in SAK section.&apos;b&apos; - Will immediately reboot the system without syncing or unmounting your disks.&apos;c&apos; - Will perform a kexec reboot in order to take a crashdump.&apos;o&apos; - Will shut your system off (if configured and supported).&apos;s&apos; - Will attempt to sync all mounted filesystems.&apos;u&apos; - Will attempt to remount all mounted filesystems read-only.&apos;p&apos; - Will dump the current registers and flags to your console.&apos;t&apos; - Will dump a list of current tasks and their information to your console.&apos;m&apos; - Will dump current memory info to your console.&apos;v&apos; - Dumps Voyager SMP processor info to your console.&apos;0&apos;-&apos;9&apos; - Sets the console log level, controlling which kernel messages will be printed to your console. (&apos;0&apos;, for example would make it so that only emergency messages like PANICs or OOPSes would make it to your console.)&apos;f&apos; - Will call oom_kill to kill a memory hog process&apos;e&apos; - Send a SIGTERM to all processes, except for init.&apos;i&apos; - Send a SIGKILL to all processes, except for init.&apos;l&apos; - Send a SIGKILL to all processes, INCLUDING init. (Your system will be non-functional after this.)&apos;h&apos; - Will display help ( actually any other key than those listed above will display help. but &apos;h&apos; is easy to remember :-)* Okay, so what can I use them for?~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Well, un&apos;R&apos;aw is very handy when your X server or a svgalib program crashes.sa&apos;K&apos; (Secure Access Key) is useful when you want to be sure there are notrojan program is running at console and which could grab your passwordwhen you would try to login. It will kill all programs on given consoleand thus letting you make sure that the login prompt you see is actuallythe one from init, not some trojan program.IMPORTANT:In its true form it is not a true SAK like the one in :IMPORTANTIMPORTANT:c2 compliant systems, and it should be mistook as such. :IMPORTANT It seems other find it useful as (System Attention Key) which isuseful when you want to exit a program that will not let you switch consoles.(For example, X or a svgalib program.)re&apos;B&apos;oot is good when you&apos;re unable to shut down. But you should also &apos;S&apos;yncand &apos;U&apos;mount first.&apos;C&apos;rashdump can be used to manually trigger a crashdump when the system is hung.The kernel needs to have been built with CONFIG_KEXEC enabled.&apos;S&apos;ync is great when your system is locked up, it allows you to sync yourdisks and will certainly lessen the chance of data loss and fscking. Notethat the sync hasn&apos;t taken place until you see the &quot;OK&quot; and &quot;Done&quot; appearon the screen. (If the kernel is really in strife, you may not ever get theOK or Done message...)&apos;U&apos;mount is basically useful in the same ways as &apos;S&apos;ync. I generally &apos;S&apos;ync,&apos;U&apos;mount, then re&apos;B&apos;oot when my system locks. It&apos;s saved me many a fsck.Again, the unmount (remount read-only) hasn&apos;t taken place until you see the&quot;OK&quot; and &quot;Done&quot; message appear on the screen.The loglevel&apos;0&apos;-&apos;9&apos; is useful when your console is being flooded withkernel messages you do not want to see. Setting &apos;0&apos; will prevent all butthe most urgent kernel messages from reaching your console. (They willstill be logged if syslogd/klogd are alive, though.)t&apos;E&apos;rm and k&apos;I&apos;ll are useful if you have some sort of runaway process youare unable to kill any other way, especially if it&apos;s spawning otherprocesses.* Sometimes SysRq seems to get &apos;stuck&apos; after using it, what can I do?~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~That happens to me, also. I&apos;ve found that tapping shift, alt, and controlon both sides of the keyboard, and hitting an invalid sysrq sequence againwill fix the problem. (ie, something like alt-sysrq-z). Switching to anothervirtual console (ALT+Fn) and then back again should also help.* I hit SysRq, but nothing seems to happen, what&apos;s wrong?~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~There are some keyboards that send different scancodes for SysRq than thepre-defined 0x54. So if SysRq doesn&apos;t work out of the box for a certainkeyboard, run &apos;showkey -s&apos; to find out the proper scancode sequence. Thenuse &apos;setkeycodes &lt;sequence&gt; 84&apos; to define this sequence to the usual SysRqcode (84 is decimal for 0x54). It&apos;s probably best to put this command in aboot script. Oh, and by the way, you exit &apos;showkey&apos; by not typing anythingfor ten seconds.* I want to add SysRQ key events to a module, how does it work?~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~In order to register a basic function with the table, you must first includethe header &apos;include/linux/sysrq.h&apos;, this will define everything else you need.Next, you must create a sysrq_key_op struct, and populate it with A) the keyhandler function you will use, B) a help_msg string, that will print when SysRQprints help, and C) an action_msg string, that will print right before yourhandler is called. Your handler must conform to the protoype in &apos;sysrq.h&apos;.After the sysrq_key_op is created, you can call the macro register_sysrq_key(int key, struct sysrq_key_op *op_p) that is defined insysrq.h, this will register the operation pointed to by &apos;op_p&apos; at tablekey &apos;key&apos;, if that slot in the table is blank. At module unload time, you mustcall the macro unregister_sysrq_key(int key, struct sysrq_key_op *op_p), whichwill remove the key op pointed to by &apos;op_p&apos; from the key &apos;key&apos;, if and only ifit is currently registered in that slot. This is in case the slot has beenoverwritten since you registered it.The Magic SysRQ system works by registering key operations against a key oplookup table, which is defined in &apos;drivers/char/sysrq.c&apos;. This key table hasa number of operations registered into it at compile time, but is mutable,and 4 functions are exported for interface to it: __sysrq_lock_table,__sysrq_unlock_table, __sysrq_get_key_op, and __sysrq_put_key_op. Thefunctions __sysrq_swap_key_ops and __sysrq_swap_key_ops_nolock are definedin the header itself, and the REGISTER and UNREGISTER macros are built fromthese. More complex (and dangerous!) manipulations of the table are possibleusing these functions, but you must be careful to always lock the table beforeyou read or write from it, and to unlock it again when you are done. (And ofcourse, to never ever leave an invalid pointer in the table). Null pointers inthe table are always safe :)If for some reason you feel the need to call the handle_sysrq function fromwithin a function called by handle_sysrq, you must be aware that you are ina lock (you are also in an interrupt handler, which means don&apos;t sleep!), soyou must call __handle_sysrq_nolock instead.* I have more questions, who can I ask?~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~You may feel free to send email to myrdraal@deathsdoor.com, and I willrespond as soon as possible. -MyrdraalAnd I&apos;ll answer any questions about the registration system you got, alsoresponding as soon as possible. -Crutcher* Credits~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Written by Mydraal &lt;myrdraal@deathsdoor.com&gt;Updated by Adam Sulmicki &lt;adam@cfar.umd.edu&gt;Updated by Jeremy M. Dolan &lt;jmd@turbogeek.org&gt; 2001/01/28 10:15:59Added to by Crutcher Dunnavant &lt;crutcher+kernel@datastacks.com&gt;]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>SysRq魔术键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java -- 包装类]]></title>
    <url>%2F2019%2F05%2F01%2Fjava-%E5%8C%85%E8%A3%85%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[什么是包装类包装类可以简单理解为对基本数据类型的功能拓展，最终以封装为class的形式呈现。这是因为八大基本数据类型只能完成基本的算术或逻辑操作，无法实现诸如“字符串转换”等特殊操作。在以上背景下，包装类应运而生。包装类分类根据八大基本数据类型，包装类相应的可以分为八类，具体如下：基本数据类型对应包装类intIntegerbyteByteshortShortlongLongcharCharacterfloatFloatdoubleDoublebooleanBoolean包装类详解（以Integer为例）所在包该类位于java.lang包下，使用时无需导包。简述先看一段JDK关于Integer的注释12345678910/** * The &#123;@code Integer&#125; class wraps a value of the primitive type * &#123;@code int&#125; in an object. An object of type &#123;@code Integer&#125; * contains a single field whose type is &#123;@code int&#125;. * * &lt;p&gt;In addition, this class provides several methods for converting * an &#123;@code int&#125; to a &#123;@code String&#125; and a &#123;@code String&#125; to an * &#123;@code int&#125;, as well as other constants and methods useful when * dealing with an &#123;@code int&#125;. */大体上是说，这是一个包含唯一类字段的类；类字段为int型，用来存储int型变量。除此之外，该类还提供了一些诸如int与String之间相互转换的方法，用于实现一些常见操作。构造方法有2个有参构造方法，分别为：Integer(int)和Integer(String)。JDK源码如下：123456789101112131415161718192021222324252627 /** * Constructs a newly allocated &#123;@code Integer&#125; object that * represents the specified &#123;@code int&#125; value. * * @param value the value to be represented by the * &#123;@code Integer&#125; object. */ public Integer(int value) &#123; this.value = value; &#125;/** * Constructs a newly allocated &#123;@code Integer&#125; object that * represents the &#123;@code int&#125; value indicated by the * &#123;@code String&#125; parameter. The string is converted to an * &#123;@code int&#125; value in exactly the manner used by the * &#123;@code parseInt&#125; method for radix 10. * * @param s the &#123;@code String&#125; to be converted to an * &#123;@code Integer&#125;. * @exception NumberFormatException if the &#123;@code String&#125; does not * contain a parsable integer. * @see java.lang.Integer#parseInt(java.lang.String, int) */ public Integer(String s) throws NumberFormatException &#123; this.value = parseInt(s, 10); &#125;首先来看Integer(int)，该方法是根据一个形参int实例化一个Integer对象，内部细节就是将形参int赋值给Integer的类字段value。再来看Integer(String)，该方法使用一个String类型对象实例化Integer。内部实现稍微复杂一点点，先是用Integer静态成员方法将String转化为对应int值，然后再将获得的int值赋值给Integer类字段value。成员方法由于在实际开发中，我们用的最多的无非就是String与int的相互转化。因此，接着来我们主要总结一下这方面的成员方法。用途静态成员方法非静态成员方法String –&gt; intparseInt(String s)parseInt(String s, int radix)int –&gt; StringtoString(int i)toString(int i, int radix)String –&gt; IntegervalueOf(String s)valueOf(String s, int radix)Integer –&gt; StringtoString()int –&gt; IntegervalueOf(int i)Integer –&gt; intintValue()另外，在阅读Integer源码中，发现了两个好玩的成员方法reverse(int i)和rotateLeft(int i, int distance)，其中对于bit的操作很有启发性，现直接将源码贴在下方：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Returns the value obtained by reversing the order of the bits in the * two's complement binary representation of the specified &#123;@code int&#125; * value. * * @param i the value to be reversed * @return the value obtained by reversing order of the bits in the * specified &#123;@code int&#125; value. * @since 1.5 */ public static int reverse(int i) &#123; // HD, Figure 7-1 // 举个例子：对于一个字节"abcdefgh" i = (i &amp; 0x55555555) &lt;&lt; 1 | (i &gt;&gt;&gt; 1) &amp; 0x55555555; // abcd efgh --&gt; badc fehg i = (i &amp; 0x33333333) &lt;&lt; 2 | (i &gt;&gt;&gt; 2) &amp; 0x33333333; // badc fehg --&gt; dcba hgfe i = (i &amp; 0x0f0f0f0f) &lt;&lt; 4 | (i &gt;&gt;&gt; 4) &amp; 0x0f0f0f0f; // dcba hgfe --&gt; hgfe dcba // 下面是完成4个字节的反向 1 &lt;--&gt; 4 以及 2 &lt;--&gt; 3 i = (i &lt;&lt; 24) | ((i &amp; 0xff00) &lt;&lt; 8) | ((i &gt;&gt;&gt; 8) &amp; 0xff00) | (i &gt;&gt;&gt; 24); return i; &#125; /** * Returns the value obtained by rotating the two's complement binary * representation of the specified &#123;@code int&#125; value left by the * specified number of bits. (Bits shifted out of the left hand, or * high-order, side reenter on the right, or low-order.) * * &lt;p&gt;Note that left rotation with a negative distance is equivalent to * right rotation: &#123;@code rotateLeft(val, -distance) == rotateRight(val, * distance)&#125;. Note also that rotation by any multiple of 32 is a * no-op, so all but the last five bits of the rotation distance can be * ignored, even if the distance is negative: &#123;@code rotateLeft(val, * distance) == rotateLeft(val, distance &amp; 0x1F)&#125;. * * @param i the value whose bits are to be rotated left * @param distance the number of bit positions to rotate left * @return the value obtained by rotating the two's complement binary * representation of the specified &#123;@code int&#125; value left by the * specified number of bits. * @since 1.5 */ public static int rotateLeft(int i, int distance) &#123; return (i &lt;&lt; distance) | (i &gt;&gt;&gt; -distance); // i &gt;&gt;&gt; -distance 意思是 // 如果 distance &gt; 0: i &gt;&gt;&gt; -distance = i &gt;&gt;&gt; (32-(distance % 32)) // 如果 distance &lt; 0: 与普通 i &gt;&gt;&gt; 正数 并无二致 &#125;]]></content>
      <categories>
        <category>java-se</category>
      </categories>
      <tags>
        <tag>java - 包装类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java -- 自动拆装箱 && 正则表达式]]></title>
    <url>%2F2019%2F05%2F01%2Fjava-%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[自动拆装箱基本概念自动拆装箱是jdk-1.５引入的新特性，目的是为了简化包装类与对应基本数据类型之间的相互转化，这点有点类似java值类型的自动转换。举例如下：12345//在java中我们可以进行如下赋值(自动装箱)Integer i = 1;//而实际上，java底层为我们完成了如下操作：Integer i = new Integer(1);123456//也可以进行如下算术运算(自动拆箱)Integer i = new Integer(1);int j = i + 1;//实际上，java会将i自动转换为intint j = i.intValue() + 1;面试中相关问题12345678910111213141516171819public class Main &#123; public static void main(String[] args) &#123; Integer i1 = 100; Integer i2 = 100; Integer i3 = 200; Integer i4 = 200; System.out.println(i1==i2); System.out.println(i3==i4); &#125;&#125;输出结果：true //这里比较的是两个对象内存地址是否一样，因为Integer自动装箱的缓存机制([-128,127])，所以100自动装箱，指向的是同一个对象。 false//由于200已经超出[-128,127]范围，故重新new了两个对象，地址不一致1234567891011121314151617181920public class Main &#123; public static void main(String[] args) &#123; Double i1 = 100.0; Double i2 = 100.0; Double i3 = 200.0; Double i4 = 200.0; System.out.println(i1==i2); System.out.println(i3==i4); &#125;&#125;输出结果：falsefalse//因为Double中不存在像Integer那样的缓存机制//总结：//Integer、Short、Byte、Character、Long这几个类的valueOf方法的实现是类似的(存在缓存)//Double、Float的valueOf方法的实现是类似的(不存在缓存)12345678910111213141516171819public class Main &#123; public static void main(String[] args) &#123; Boolean i1 = false; Boolean i2 = false; Boolean i3 = true; Boolean i4 = true; System.out.println(i1==i2); System.out.println(i3==i4); &#125;&#125;输出结果：truetrue//Boolean的自动装箱，生成的对象都是预先定义好的静态成员变量，如下：public static final Boolean TRUE = new Boolean(true);public static final Boolean FALSE = new Boolean(false);1234567891011121314151617181920212223242526272829303132333435363738394041public class Main &#123; public static void main(String[] args) &#123; Integer a = 1; Integer b = 2; Integer c = 3; Integer d = 3; Integer e = 321; Integer f = 321; Long g = 3L; Long h = 2L; System.out.println(c==d); System.out.println(e==f); System.out.println(c==(a+b)); System.out.println(c.equals(a+b)); System.out.println(g==(a+b)); System.out.println(g.equals(a+b)); System.out.println(g.equals(a+h)); &#125;&#125;//这里对双目运算符“==”总结如下：1.当“==”两端是同一数据类型时：若都为类类型，则比较地址；若都为值类型，则比较数值大小2.当“==”两端数据类型不一致时：将“类类型”拆箱为“值类型”，即Integer转为int//对“+”、“-”、“*”、“/”算术运算符总结如下：所有“类类型”统一转为“值类型”(统一拆箱)参与运算//对equals()总结如下： 满足2点，才返回true：1.数据类型一致（由于equals中形参类型是Object，若传入基本数据类型，会自动装箱，int—&gt;Integer double -&gt; Double,以此类推）2.value相等输出为：truefalsetruetruetruefalsetrue正则表达式什么是正则表达式可以简单的理解为：一种用于检测给定字符串是否满足特定规则的表达式常用正则表达式正则表达式匹配规则x字符x\反斜线字符[abc]a、b或c[^abc]除了a、b和c以外的任何字符[a-zA-Z]a 到 z 或 A 到 Z（两头字母包含在内）.任何字符（与行结束符可能匹配也可能不匹配）\d 或 [0-9]数字\D 或 [ ^0-9 ]非数字\s 或 [\t\n\x0B\f\r]空白字符\S 或 [ ^\s ]非空白字符\w 或 [a-zA-Z_0-9]单词字符\W 或 [ ^\w ]非单词字符X?X，一次或一次也没有X*X，零次或多次X+X，一次或多次X{n}X，恰好n次X{n, }X，至少n次X{n,m}X，至少n次，但是不超过m次使用一般在String的成员函数matches(String regex) 中使用，例如：123String QQ = "12345678";//要求QQ不能以零开头，只能包含数字，位数不少于5不大于15；boolean isValid = QQ.matches("[1-9][0-9]&#123;4,14&#125;")]]></content>
      <categories>
        <category>java-se</category>
      </categories>
      <tags>
        <tag>java - 自动拆装箱</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode 使用技巧]]></title>
    <url>%2F2019%2F05%2F01%2Fvscode-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[神器vscode，无需多言，但其默认配置往往有许多让人不满意的地方；本文着力于收集总结自己在使用vscode中遇到到一些配置设置和使用技巧，分享如下，同时会不定期更新vscode 如何在新的tab打开文件问题描述：​ 每次在vscode中打开文件都会覆盖之前打开的标签解决方法：​ 按ctrl+p打开快速文件窗口，找到settings.json，在其中添加如下内容：1"workbench.editor.enablePreview": false,vscode 如何修改所在行背景颜色问题描述：​ vscode默认选中行背景色过浅，无法很好的识别解决方法：​ 按ctrl+p打开快速文件窗口，找到settings.json，在其中添加如下内容：1234"workbench.colorCustomizations": &#123; "editor.lineHighlightBackground": "#00000000", "editor.lineHighlightBorder": "#FF7F50CC" &#125;,“editor.lineHighlightBackground”对应的是行背景十六进制：#000000(前6位为颜色)00(后2位为透明度)“editor.lineHighlightBorder”对应边框色，其余设置一样链接：RGB颜色值与十六进制颜色码转换工具透明度与十六进制代码转vscode常用快捷键快捷键作用ctrl+shift+p打开命令行窗口ctrl+p打开快速文件窗口ctrl+shift+f在所有文件中查找vscode关闭标题栏按ctrl+p打开快速文件窗口，找到settings.json，在其中添加如下内容：1"window.menuBarVisibility": "toggle",通过alt键进行切换]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java API -- Date && SimpleDateFormat && Calendar]]></title>
    <url>%2F2019%2F04%2F29%2Fjava-API-Date-SimpleDateFormat-Calendar%2F</url>
    <content type="text"><![CDATA[java中有一种特殊的对象，我们平时都是通过字符串的形式使用它，但在底层却时不时涉及到一些数字运算；除此之外，我们对它的字符串输出形式，往往还是百般挑剔，猜猜它是谁？：-）没错，它就是java中的Date对象java API下为我们封装了有关时间和日期操作了相关函数，总结如下：Date类 – 日期获取的好帮手首先，学习一个类，大致分为以下几个步骤：看类所在package，如果在java.lang包下，则使用时可以省去导包操作。接着看类的说明，了解类的大致用途即可。查看类的构造函数查看类的常用成员方法好，我们按照上述步骤，来学习一下Date。所在package由package java.util;可知，Date包位于java.util包下，所有使用时需要导包。类的介绍查看源码注释123456789101112131415/** * The class &lt;code&gt;Date&lt;/code&gt; represents a specific instant * in time, with millisecond precision. * &lt;p&gt; * Prior to JDK&amp;nbsp;1.1, the class &lt;code&gt;Date&lt;/code&gt; had two additional * functions. It allowed the interpretation of dates as year, month, day, hour, * minute, and second values. It also allowed the formatting and parsing * of date strings. Unfortunately, the API for these functions was not * amenable to internationalization. As of JDK&amp;nbsp;1.1, the * &lt;code&gt;Calendar&lt;/code&gt; class should be used to convert between dates and time * fields and the &lt;code&gt;DateFormat&lt;/code&gt; class should be used to format and * parse date strings. * The corresponding methods in &lt;code&gt;Date&lt;/code&gt; are deprecated. * &lt;p&gt; */首先，它告诉我们：Date是用来表示一个以毫秒为单位的确定时刻的类。Date可以表征“年”、“月”、“日”、“时”、“分”和“秒”。构造方法由于一些方法已经过时，这里我们只提及两个常用的构造方法。1234567891011121314151617181920212223/** * Allocates a &lt;code&gt;Date&lt;/code&gt; object and initializes it so that * it represents the time at which it was allocated, measured to the * nearest millisecond. * * @see java.lang.System#currentTimeMillis() */ public Date() &#123; this(System.currentTimeMillis()); &#125;/** * Allocates a &lt;code&gt;Date&lt;/code&gt; object and initializes it to * represent the specified number of milliseconds since the * standard base time known as "the epoch", namely January 1, * 1970, 00:00:00 GMT. * * @param date the milliseconds since January 1, 1970, 00:00:00 GMT. * @see java.lang.System#currentTimeMillis() */ public Date(long date) &#123; fastTime = date; // fastTime 是成员变量 &#125;空参构造方法Date()用来初始化一个Date对象，其时间基准线为jvm运行环境的当前时间，也就是说这个Date对象的时间值与当前时间一致。有参构造方法Date(long date)用来初始化一个相对时间基准线，时间值为long date的Date对象。其中，时间基准线为1970-1-1 00:00:00，俗称“计算机元年”。举个例子，Date(1000)代表的是1970-1-1 00:00:01这个时刻。常用成员方法这里我们介绍两个常用成员函数setTime()和getTime()：12345678910111213141516171819202122232425262728/** * Sets this &lt;code&gt;Date&lt;/code&gt; object to represent a point in time that is * &lt;code&gt;time&lt;/code&gt; milliseconds after January 1, 1970 00:00:00 GMT. * * @param time the number of milliseconds. */ public void setTime(long time) &#123; fastTime = time; cdate = null; &#125;/** * Returns the number of milliseconds since January 1, 1970, 00:00:00 GMT * represented by this &lt;tt&gt;Date&lt;/tt&gt; object. * * @return the number of milliseconds since January 1, 1970, 00:00:00 GMT * represented by this date. */ public long getTime() &#123; return getTimeImpl(); &#125; private final long getTimeImpl() &#123; if (cdate != null &amp;&amp; !cdate.isNormalized()) &#123; normalize(); &#125; return fastTime; &#125;其中setTime(long time)用来设置时间，参数time为相对于“1970-1-1 00:00:00”的时间值，单位为毫秒。而getTime()代表的是当前时间的毫秒值，同样是相对于“1970-1-1 00:00:00”。SimpleDateFormat类 – 日期格式化&amp;解析神器所在包SimpleDateFormat位于包java.text下，使用前需要导包。类概述123456/** * &lt;code&gt;SimpleDateFormat&lt;/code&gt; is a concrete class for formatting and * parsing dates in a locale-sensitive manner. It allows for formatting * (date &amp;rarr; text), parsing (text &amp;rarr; date), and normalization. * * &lt;p&gt;大意是说：SimpleDateFormat是一个用来格式化Date（输入为Date，输出为String），以及解析Date字符串（输入为String，输出为Date）的具体类。SimpleDateFormat特色是支持用户自定义格式，格式化Date。构造方法这里我们主要讲解两个常用构造方法，分别是：空参构造方法SimpleDateFormat()，以及有参构造方法SimpleDateFormat(String)。下面是它们的jdk源码：123456789101112131415161718192021222324252627282930313233/** * Constructs a &lt;code&gt;SimpleDateFormat&lt;/code&gt; using the default pattern and * date format symbols for the default * &#123;@link java.util.Locale.Category#FORMAT FORMAT&#125; locale. * &lt;b&gt;Note:&lt;/b&gt; This constructor may not support all locales. * For full coverage, use the factory methods in the &#123;@link DateFormat&#125; * class. */ public SimpleDateFormat() &#123; this("", Locale.getDefault(Locale.Category.FORMAT)); applyPatternImpl(LocaleProviderAdapter.getResourceBundleBased().getLocaleResources(locale).getDateTimePattern(SHORT, SHORT, calendar)); &#125;/** * Constructs a &lt;code&gt;SimpleDateFormat&lt;/code&gt; using the given pattern and * the default date format symbols for the default * &#123;@link java.util.Locale.Category#FORMAT FORMAT&#125; locale. * &lt;b&gt;Note:&lt;/b&gt; This constructor may not support all locales. * For full coverage, use the factory methods in the &#123;@link DateFormat&#125; * class. * &lt;p&gt;This is equivalent to calling * &#123;@link #SimpleDateFormat(String, Locale) * SimpleDateFormat(pattern, Locale.getDefault(Locale.Category.FORMAT))&#125;. * * @see java.util.Locale#getDefault(java.util.Locale.Category) * @see java.util.Locale.Category#FORMAT * @param pattern the pattern describing the date and time format * @exception NullPointerException if the given pattern is null * @exception IllegalArgumentException if the given pattern is invalid */ public SimpleDateFormat(String pattern) &#123; this(pattern, Locale.getDefault(Locale.Category.FORMAT)); &#125;其中，空参构造方法SimpleDateFormat()是以默认格式Sun Apr 28 20:45:54 CST 2019构造SimpleDateFormat对象，在之后的format过程中，会以这个格式来生成对应的字符串。而有参构造方法SimpleDateFormat(String)，则是用给定的格式（如：yyyy:MM:dd HH:mm:ss）来生成对应SimpleDateFormat对象，在之后的format过程中，会以这个格式来生成对应的字符串。常用成员方法这里要注意一下，我们一般不怎么使用SimpleDateFormat自己特有的成员方法；相反，我们比较爱用其继承于父类DateFormat的方法formate(Date)和parse(String)。相关源码如下：123456789101112131415161718192021222324252627282930313233/** * Formats a Date into a date/time string. * @param date the time value to be formatted into a time string. * @return the formatted time string. */ public final String format(Date date) &#123; return format(date, new StringBuffer(), DontCareFieldPosition.INSTANCE).toString(); &#125; /** * Parses text from the beginning of the given string to produce a date. * The method may not use the entire text of the given string. * &lt;p&gt; * See the &#123;@link #parse(String, ParsePosition)&#125; method for more information * on date parsing. * * @param source A &lt;code&gt;String&lt;/code&gt; whose beginning should be parsed. * @return A &lt;code&gt;Date&lt;/code&gt; parsed from the string. * @exception ParseException if the beginning of the specified string * cannot be parsed. */ public Date parse(String source) throws ParseException &#123; ParsePosition pos = new ParsePosition(0); Date result = parse(source, pos); if (pos.index == 0) throw new ParseException("Unparseable date: \"" + source + "\"" , pos.errorIndex); return result; &#125;从以上代码可知，方法format主要完成了Date对象到指定格式字符串的转换；而parse方法主要完成了String对象到Date对象的转化。Calendar类 – 日期操作的手术刀所在包位于java.util包下，使用前需执行导包操作。类简述见看一段jdk英文注解：123456789/** * The &lt;code&gt;Calendar&lt;/code&gt; class is an abstract class that provides methods * for converting between a specific instant in time and a set of &#123;@link * #fields calendar fields&#125; such as &lt;code&gt;YEAR&lt;/code&gt;, &lt;code&gt;MONTH&lt;/code&gt;, * &lt;code&gt;DAY_OF_MONTH&lt;/code&gt;, &lt;code&gt;HOUR&lt;/code&gt;, and so on, and for * manipulating the calendar fields, such as getting the date of the next * week. An instant in time can be represented by a millisecond value that is * an offset from the &lt;a name="Epoch"&gt;&lt;em&gt;Epoch&lt;/em&gt;&lt;/a&gt;, January 1, 1970 * 00:00:00.000 GMT (Gregorian).翻译过来，大致意思就是：Calendar是一个在“年”、“月”、“日”、“时”等日历属性，以及时间点（以毫秒为单位）之间进行转化的一个工具类。它可以对“年”、“月”、“日”、“时”等日历属性进行相关算术运算，最终反应在Date中的就是属性值fastTime的变化（即毫秒值的变化）。构造方法Calendar构造函数有两个，分别为Calendar()以及Calendar(TimeZone zone, Locale aLocale)，但平时使用中我们基本不用。实例化Calendar类，我们一般选择使用ta的静态成员方法getInstance()，实例化的是其子类对象。原因是：我们使用的某些成员方法如add(int, int)，它的实现是在Calendar的子类中完成的，这里用到了多态的向上转型。相应源码如下：123456789101112/** * Gets a calendar using the default time zone and locale. The * &lt;code&gt;Calendar&lt;/code&gt; returned is based on the current time * in the default time zone with the default * &#123;@link Locale.Category#FORMAT FORMAT&#125; locale. * * @return a Calendar. */ public static Calendar getInstance() &#123; return createCalendar(TimeZone.getDefault(), Locale.getDefault(Locale.Category.FORMAT)); &#125;需要注意的是：通过getInstance()方法获取的Calendar子类对象，其时间值是相对“计算机元年”而言的。常用成员方法这里，我们主要讲解“查询”、“设置”、“修改”calendar指定字段(filed)的成员方法。它们分别对应为：get(int)方法、set(int,int)方法、add(int,int)方法。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 /** * Returns the value of the given calendar field. In lenient mode, * all calendar fields are normalized. In non-lenient mode, all * calendar fields are validated and this method throws an * exception if any calendar fields have out-of-range values. The * normalization and validation are handled by the * &#123;@link #complete()&#125; method, which process is calendar * system dependent. * * @param field the given calendar field. * @return the value for the given calendar field. * @throws ArrayIndexOutOfBoundsException if the specified field is out of range * (&lt;code&gt;field &amp;lt; 0 || field &amp;gt;= FIELD_COUNT&lt;/code&gt;). * @see #set(int,int) * @see #complete() */ public int get(int field) &#123; complete(); return internalGet(field); &#125;/** * Sets the given calendar field to the given value. The value is not * interpreted by this method regardless of the leniency mode. * * @param field the given calendar field. * @param value the value to be set for the given calendar field. * @throws ArrayIndexOutOfBoundsException if the specified field is out of range * (&lt;code&gt;field &amp;lt; 0 || field &amp;gt;= FIELD_COUNT&lt;/code&gt;). * in non-lenient mode. * @see #set(int,int,int) * @see #set(int,int,int,int,int) * @see #set(int,int,int,int,int,int) * @see #get(int) */ public void set(int field, int value) &#123; // If the fields are partially normalized, calculate all the // fields before changing any fields. if (areFieldsSet &amp;&amp; !areAllFieldsSet) &#123; computeFields(); &#125; internalSet(field, value); isTimeSet = false; areFieldsSet = false; isSet[field] = true; stamp[field] = nextStamp++; if (nextStamp == Integer.MAX_VALUE) &#123; adjustStamp(); &#125; &#125; /** * Adds or subtracts the specified amount of time to the given calendar field, * based on the calendar's rules. For example, to subtract 5 days from * the current time of the calendar, you can achieve it by calling: * &lt;p&gt;&lt;code&gt;add(Calendar.DAY_OF_MONTH, -5)&lt;/code&gt;. * * @param field the calendar field. * @param amount the amount of date or time to be added to the field. * @see #roll(int,int) * @see #set(int,int) */ abstract public void add(int field, int amount);先说get(int)方法，这个方法主要通过指定int型字段来获取相应字段的整数型值。例如，get(Calendar.YEAR)返回的就是当前系统的年份值。常用的字段总结如下：字段名含义YEAR年份MONTH月份DAY_OF_MONTH月份中的日子HOUR_OF_DAY一天中的小时MINUTE小时中的分钟SECOND分钟中的秒接着谈谈set(int field, int value)方法，这个方法是给指定字段设置给定值。例如，我们可以将月份设置为一月，即set(Calendar.MONTH, Calendar.JANUARY)或者set(Calendar.MONTH, 0)（因为这里采用的是格里高利纪年法，0表示一月）。最后轮到add(int field, int amount)了，这个方法和set(int ,int )方法的区别有点类似“绝对路径”和“相对路径”的关系。add方法更加偏向于通过运算（相对与当前字段而言）来更改字段值。举个栗子：如果当前月份是二月，我们向将其改为三月，可以这样add(Calendar.MONTH, 1)；如果我们想将其改为一月，可以这样add(Calendar.MONTH, -1)。]]></content>
      <categories>
        <category>java-se</category>
      </categories>
      <tags>
        <tag>java - Date</tag>
        <tag>java - SimpleDateFormat</tag>
        <tag>java - Calendar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java API -- System类]]></title>
    <url>%2F2019%2F04%2F29%2Fjava-API-System%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[System类是我们一开始学习java就接触到的一个常用类，在这个类中封装了许多和系统底层有关的方法供我们调用。所属包首先，查看jdk我们可以知道，System类是位于java.lang包下的。因此，是无需导包就能直接使用的。类描述我们先看一段官方注解：12345678910111213/** * The &lt;code&gt;System&lt;/code&gt; class contains several useful class fields * and methods. It cannot be instantiated. * * &lt;p&gt;Among the facilities provided by the &lt;code&gt;System&lt;/code&gt; class * are standard input, standard output, and error output streams; * access to externally defined properties and environment * variables; a means of loading files and libraries; and a utility * method for quickly copying a portion of an array. * * @author unascribed * @since JDK1.0 */大意就是，System这个类一个基础工具类，它无法被实例化。它主要用于标准输入、输出流的控制，以及数组的操作等。构造函数123/** Don't let anyone instantiate this class */ private System() &#123; &#125;由于构造函数的私有属性，因此System类是无法实例化的。常用成员方法输出方法这里介绍两个方法，分别是：System.out.println()以及System.err.println()。实际上，这两个方法都是通过System内的静态不可变成员变量out或err，并且它们都是PrintStream类的的对象引用，然后通过对象调用类中方法。数组操作方法12345678910111213141516* @param src the source array. * @param srcPos starting position in the source array. * @param dest the destination array. * @param destPos starting position in the destination data. * @param length the number of array elements to be copied. * @exception IndexOutOfBoundsException if copying would cause * access of data outside array bounds. * @exception ArrayStoreException if an element in the &lt;code&gt;src&lt;/code&gt; * array could not be stored into the &lt;code&gt;dest&lt;/code&gt; array * because of a type mismatch. * @exception NullPointerException if either &lt;code&gt;src&lt;/code&gt; or * &lt;code&gt;dest&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;. */ public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length);从源数组src向目的数组dest，复制给定长度length的数据。退出jvm方法1234567891011121314151617181920212223/** * Terminates the currently running Java Virtual Machine. The * argument serves as a status code; by convention, a nonzero status * code indicates abnormal termination. * &lt;p&gt; * This method calls the &lt;code&gt;exit&lt;/code&gt; method in class * &lt;code&gt;Runtime&lt;/code&gt;. This method never returns normally. * &lt;p&gt; * The call &lt;code&gt;System.exit(n)&lt;/code&gt; is effectively equivalent to * the call: * &lt;blockquote&gt;&lt;pre&gt; * Runtime.getRuntime().exit(n) * &lt;/pre&gt;&lt;/blockquote&gt; * * @param status exit status. * @throws SecurityException * if a security manager exists and its &lt;code&gt;checkExit&lt;/code&gt; * method doesn't allow exit with the specified status. * @see java.lang.Runtime#exit(int) */ public static void exit(int status) &#123; Runtime.getRuntime().exit(status); &#125;方法描述为：终止正在运行的jvm，并返回一个状态码。依照惯例：返回‘0’，代表正常退出 ；其他值，代表异常退出。垃圾回收方法123456789101112131415161718192021/** * Runs the garbage collector. * &lt;p&gt; * Calling the &lt;code&gt;gc&lt;/code&gt; method suggests that the Java Virtual * Machine expend effort toward recycling unused objects in order to * make the memory they currently occupy available for quick reuse. * When control returns from the method call, the Java Virtual * Machine has made a best effort to reclaim space from all discarded * objects. * &lt;p&gt; * The call &lt;code&gt;System.gc()&lt;/code&gt; is effectively equivalent to the * call: * &lt;blockquote&gt;&lt;pre&gt; * Runtime.getRuntime().gc() * &lt;/pre&gt;&lt;/blockquote&gt; * * @see java.lang.Runtime#gc() */ public static void gc() &#123; Runtime.getRuntime().gc(); &#125;调用jvm的垃圾回收机制，去尽可能的回收系统资源。一般与Object类的finalize()方法配套使用1234567/** * Called by the garbage collector on an object when garbage collection * determines that there are no more references to the object. * A subclass overrides the &#123;@code finalize&#125; method to dispose of * system resources or to perform other cleanup. * &lt;p&gt; protected void finalize() throws Throwable &#123; &#125;流程是：12345678910111213public class Test&#123; public static void main(String[] args)&#123; new Student(); //创建匿名对象，方便gc回收 System.gc(); //调用jvm回收机制 &#125;&#125;class Student&#123; @override void finalize()&#123; System.out.println("在这里完成一些收尾工作"); &#125;&#125;运行结果是：可能打印出“在这里完成一些收尾工作”。因为gc不能保证每次都能回收Student资源（the Java Virtual Machine has made a best effort to reclaim space from all discarded）。]]></content>
      <categories>
        <category>java-se</category>
      </categories>
      <tags>
        <tag>java - System</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java -- 内部类]]></title>
    <url>%2F2019%2F04%2F29%2Fjava-%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[java中的内部类，按类型看大致可以分为3类，分别是：成员内部类、局部内部类以及匿名内部类成员内部类形式如下：1234567891011121314class Outer&#123; int num = 10; void speak()&#123; System.out.println("我是外部内中的方法speak"); &#125; class Inner&#123; void tell()&#123; System.out.println("我是成员内部类中的方法tell"); &#125; &#125;&#125;外部类Outer中位于成员位置，再定义一个类Inner，这个类就是Outer的内部类。内部类在编译时，会生成自己对应的class文件，但它的访问要通过其外部类完成。这里，我们要运行内部类Inner中的tell方法，流程如下：12345678910111213public class Test&#123; public static void main(String[] args)&#123; //1.首先，要访问成员内部类，我们得先得到外部类`Outer`的对象 Outer o = new Outer(); //2.然后，通过外部类对象`o`得到内部类`Inner` Inner i = o.new Inner(); //3.通过内部类对象`i`调用内部类方法`tell` i.tell(); //以上可以简写为 new Outer().new Inner().tell(); &#125;&#125;如果，我们给Inner加上static修饰符，那么我们就能通过Outer.Inner调用内部类的class。进一步，要想获得Inner的对象，可以通过Outer.new Inner()获得。如果，Inner中的tell方法也加上static修饰符，我们直接通过Outer.Inner.tell()，就可以执行tell方法，整个过程没有实例化任何对象。局部内部类顾名思义，和局部变量类似，局部内部类是存在与方法体中的类，形式如下：12345678910111213141516class Outer&#123; int num = 10; void speak()&#123; System.out.println("我是外部内中的方法speak"); class Inner&#123; void tell()&#123; System.out.println("我是成员内部类中的方法tell"); &#125; &#125; //实例化局部内部类`Inner`，并调用其中的方法`tell` Inner i = new Inner(); i.tell(); &#125;&#125;局部内部类的作用域范围仅局限于方法内部，出了方法之后就无法使用了因此，无法在其他类，例如测试类Test中实例化局部内部类Inner，更不用说调用其中的tell方法了。唯一的途径是，直接在Inner所在的方法体中，实例化Inner对象i，然后调用tell方法，如上所示。匿名内部类特点可以看做是一种没有名字的局部内部类定义在方法中必须在定义匿名内部类时创建它的对象格式1234new 类/接口()&#123; 如果是创建了继承这个类的子类对象，我们可以重写父类的方法 如果是创建了实现这个接口的子类对象，我们必须实现接口的全部抽象方法&#125;原理：创建了继承了这个类的子类对象或者实现了这个接口的子类对象应用场景​ 作为参数进行传递，因为只使用一次，无需专门写一个java文件继承父类或接口，直接通过匿名内部类的方式比较简洁。]]></content>
      <categories>
        <category>java-se</category>
      </categories>
      <tags>
        <tag>java - 内部类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中根类Object的常用方法]]></title>
    <url>%2F2019%2F04%2F29%2Fjava%E4%B8%AD%E6%A0%B9%E7%B1%BBObject%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Object类，一般我们习惯称之为超类或根父类，这代表了它至高无上的低位。它是所有类的父类，它当中的一些属性将被所有类继承。这里我主要总结了toString()、equals()以及hashCode()这3个方法。toString()方法这里首先引入一段jdk源码：123456789101112131415161718192021222324/** * Returns a string representation of the object. In general, the * &#123;@code toString&#125; method returns a string that * "textually represents" this object. The result should * be a concise but informative representation that is easy for a * person to read. * It is recommended that all subclasses override this method. * &lt;p&gt; * The &#123;@code toString&#125; method for class &#123;@code Object&#125; * returns a string consisting of the name of the class of which the * object is an instance, the at-sign character `&#123;@code @&#125;', and * the unsigned hexadecimal representation of the hash code of the * object. In other words, this method returns a string equal to the * value of: * &lt;blockquote&gt; * &lt;pre&gt; * getClass().getName() + '@' + Integer.toHexString(hashCode()) * &lt;/pre&gt;&lt;/blockquote&gt; * * @return a string representation of the object. */ public String toString() &#123; return getClass().getName() + "@" + Integer.toHexString(hashCode()); &#125;这个方法主要完成Object对象的文本化输出。输出内容由getClass().getName()和Integer.toHexString(hashCode())两部分组成。第一部分是：对象所属的包名加类名，第二个部分是：对象地址的hash表示。在实际的开发中，我们一般会通过IDE自动重写该方法。equals()方法二话不说，上jdk源码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Indicates whether some other object is "equal to" this one. * &lt;p&gt; * The &#123;@code equals&#125; method implements an equivalence relation * on non-null object references: * &lt;ul&gt; * &lt;li&gt;It is &lt;i&gt;reflexive&lt;/i&gt;: for any non-null reference value * &#123;@code x&#125;, &#123;@code x.equals(x)&#125; should return * &#123;@code true&#125;. * &lt;li&gt;It is &lt;i&gt;symmetric&lt;/i&gt;: for any non-null reference values * &#123;@code x&#125; and &#123;@code y&#125;, &#123;@code x.equals(y)&#125; * should return &#123;@code true&#125; if and only if * &#123;@code y.equals(x)&#125; returns &#123;@code true&#125;. * &lt;li&gt;It is &lt;i&gt;transitive&lt;/i&gt;: for any non-null reference values * &#123;@code x&#125;, &#123;@code y&#125;, and &#123;@code z&#125;, if * &#123;@code x.equals(y)&#125; returns &#123;@code true&#125; and * &#123;@code y.equals(z)&#125; returns &#123;@code true&#125;, then * &#123;@code x.equals(z)&#125; should return &#123;@code true&#125;. * &lt;li&gt;It is &lt;i&gt;consistent&lt;/i&gt;: for any non-null reference values * &#123;@code x&#125; and &#123;@code y&#125;, multiple invocations of * &#123;@code x.equals(y)&#125; consistently return &#123;@code true&#125; * or consistently return &#123;@code false&#125;, provided no * information used in &#123;@code equals&#125; comparisons on the * objects is modified. * &lt;li&gt;For any non-null reference value &#123;@code x&#125;, * &#123;@code x.equals(null)&#125; should return &#123;@code false&#125;. * &lt;/ul&gt; * &lt;p&gt; * The &#123;@code equals&#125; method for class &#123;@code Object&#125; implements * the most discriminating possible equivalence relation on objects; * that is, for any non-null reference values &#123;@code x&#125; and * &#123;@code y&#125;, this method returns &#123;@code true&#125; if and only * if &#123;@code x&#125; and &#123;@code y&#125; refer to the same object * (&#123;@code x == y&#125; has the value &#123;@code true&#125;). * &lt;p&gt; * Note that it is generally necessary to override the &#123;@code hashCode&#125; * method whenever this method is overridden, so as to maintain the * general contract for the &#123;@code hashCode&#125; method, which states * that equal objects must have equal hash codes. * * @param obj the reference object with which to compare. * @return &#123;@code true&#125; if this object is the same as the obj * argument; &#123;@code false&#125; otherwise. * @see #hashCode() * @see java.util.HashMap */ public boolean equals(Object obj) &#123; return (this == obj); &#125;如注释所述，equals方法主要用于判断非空对象与另一给定对象，是否为同一对象（在堆内存中位于同一地址空间）。在实际开发中，我们一般会选择重写该方法去完成更具体的功能。例如，在jdk中的String类中，就重写了equals方法，去判断两个字符串是否相等。hashCode()方法jdk源码如下：123456789101112131415161718192021222324252627282930313233343536/** * Returns a hash code value for the object. This method is * supported for the benefit of hash tables such as those provided by * &#123;@link java.util.HashMap&#125;. * &lt;p&gt; * The general contract of &#123;@code hashCode&#125; is: * &lt;ul&gt; * &lt;li&gt;Whenever it is invoked on the same object more than once during * an execution of a Java application, the &#123;@code hashCode&#125; method * must consistently return the same integer, provided no information * used in &#123;@code equals&#125; comparisons on the object is modified. * This integer need not remain consistent from one execution of an * application to another execution of the same application. * &lt;li&gt;If two objects are equal according to the &#123;@code equals(Object)&#125; * method, then calling the &#123;@code hashCode&#125; method on each of * the two objects must produce the same integer result. * &lt;li&gt;It is &lt;em&gt;not&lt;/em&gt; required that if two objects are unequal * according to the &#123;@link java.lang.Object#equals(java.lang.Object)&#125; * method, then calling the &#123;@code hashCode&#125; method on each of the * two objects must produce distinct integer results. However, the * programmer should be aware that producing distinct integer results * for unequal objects may improve the performance of hash tables. * &lt;/ul&gt; * &lt;p&gt; * As much as is reasonably practical, the hashCode method defined by * class &#123;@code Object&#125; does return distinct integers for distinct * objects. (This is typically implemented by converting the internal * address of the object into an integer, but this implementation * technique is not required by the * Java&amp;trade; programming language.) * * @return a hash code value for this object. * @see java.lang.Object#equals(java.lang.Object) * @see java.lang.System#identityHashCode */ public native int hashCode();hashCode方法，返回的是对象在内存中地址的hash编码。这在HashTable中会用到，主要是用作对象存储的index使用。]]></content>
      <categories>
        <category>java-se</category>
      </categories>
      <tags>
        <tag>java - Object</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java -- 修饰符总结]]></title>
    <url>%2F2019%2F04%2F26%2Fjava-%E4%BF%AE%E9%A5%B0%E7%AC%A6%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[权限修饰符public：所有类都可以访问private：当前类可以访问default（默认，什么都不写）：同一包下，可以访问protected：子类可以访问修饰符总结修饰符类成员变量成员方法构造方法public√√√√default√√√√protected√√√private√√√abstract√√static√√final√√√修饰符使用常用规则：一般使用public修饰类，一个java文件中最好只有一个类。如果一个文件中有多个类，类名和文件名相同的类，必须用public修饰；其余类不能用public修饰。一般用private修饰成员变量，并提供相应的get、set方法一般用public修饰成员方法，除非那些你不想让人调用的方法，可以用private修饰。一般用public修饰构造方法，除非你不想让别人实例化这个类，可以用private修饰。]]></content>
      <categories>
        <category>java-se</category>
      </categories>
      <tags>
        <tag>java修饰符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java -- 多态]]></title>
    <url>%2F2019%2F04%2F26%2Fjava-%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[基本概念多态的前提：存在子父类继承关系（或子类和父类接口实现关系）存在方法重写父类（或父接口）引用指向子类对象动态绑定：​ 运行期间调用的方法，是根据具体的类型决定的。多态的成员特点成员分类特点成员变量编译时看的是左边，运行时看的是左边成员方法编译时看的是左边，运行时看的是右边（动态绑定）静态成员方法编译时看的是左边，运行时看的也是左边举例说明先定义父类和子类1234567891011121314151617181920212223class Dad &#123; int num = 20; public void method() &#123; System.out.println("我是父类方法"); &#125; public static void function() &#123; System.out.println("我是父类静态方法"); &#125;&#125;class Kid extends Dad &#123; int num = 10; public void method() &#123; System.out.println("我是子类方法"); &#125; public static void function() &#123; System.out.println("我是子类静态方法"); &#125;&#125;1 对于成员变量12345678910public class PoymorphicDemo &#123; public static void main(String[] args) &#123; Dad d = new Kid(); //d.num 编译时，首先会查看父类Dad中是否存在num成员变量，如不存在，则会报错，这就是“编译看左边” System.out.println(d.num); &#125;&#125;//输出 20//这就说明最后输出的是父类Dad中的成员变量，即所谓“运行看左边”2 对于成员方法1234567891011public class PoymorphicDemo2 &#123; public static void main(String[] args) &#123; Dad d = new Kid();//d.method()编译时，首先会查看父类Dad中是否存在method成员方法，不存在，就会报错，即“编译看左边” d.method(); &#125;&#125;//输出 我是子类方法//最后执行的是子类成员方法，即所谓的“运行看右边”，这里涉及运行期间的编译器“动态绑定”3 对于静态成员方法与成员变量类似，这里不在赘述。多态中的向上转型和向下转型本质上属于引用数据类型的转型问题。可以和基本数据类型转型进行对比基本数据类型引用数据类型自然转型小存储空间向大存储空间转型子类向父类转型（向上转型）强制转型大存储空间向小存储空间转型父类向子类转型（向下转型）说明：向上转型，只能调用父类中存在并被重写的方法；向下转型，可以调用子类中特有的方法多态的优缺点优点：由于多态基于继承和接口，故继承和接口所具有的优点，它都具有（如减少代码冗余，可维护，模块化编程等）缺点：无法访问子类特有成员和方法]]></content>
      <categories>
        <category>java-se</category>
      </categories>
      <tags>
        <tag>java多态</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中的接口 && 匿名对象]]></title>
    <url>%2F2019%2F04%2F26%2Fjava%E4%B8%AD%E7%9A%84%E6%8E%A5%E5%8F%A3-%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[java中的接口接口是为了解决java中继承的单一局限性，而提出来的。接口是一个比抽象类还要抽象的类，其中所有成员方法都是抽象方法，类通过关键字implements来实现接口接口可以看做是拓展类的各种功能的一个全抽象父类，它可以实现针对不同功能，开发不同接口，最后再将接口合并，实现了模块化独立编程的目的。接口的成员特点成员分类特点成员方法全部为抽象方法默认使用public abstract修饰只能使用public abstract修饰成员变量默认使用public static final修饰，相当于常量构造方法没有构造方法，因为不需要初始化成员变量注意：接口不能实例化，实现接口需重写其中所有方法接口与类之间的关系分类关系类与类继承关系，单一继承，多层继承类与接口实现关系，可以一对多，一个类实现多个接口接口与接口继承关系，单一继承，多层继承类与接口的综合举例匿名对象匿名对象：没有名字的对象。应用场景：当方法只调用一次时，可以使用匿名对象可以当作参数传递，但是无法在传参之前做其他事。注意：匿名对象可以调用成员变量进行赋值，但由于无法在后续操作中使用，所有没有意义]]></content>
      <categories>
        <category>java-se</category>
      </categories>
      <tags>
        <tag>java匿名对象</tag>
        <tag>java接口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中的静态 && 代码块]]></title>
    <url>%2F2019%2F04%2F25%2Fjava%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81-%E4%BB%A3%E7%A0%81%E5%9D%97%2F</url>
    <content type="text"><![CDATA[java中的静态修饰符修饰符static： 是一个关键字，用于修饰成员变量和成员方法特点被所有对象共享可以使用类名调用静态加载优先于对象随着类的加载而加载注意事项静态方法静态方法只可以调用静态的成员（包括方法和变量）非静态方法既可以调用非静态方法和变量，也可以调用静态的方法和变量由于静态方法优先于对象创建，故静态方法中没有this对象使用场景static常用来修饰工具类中的方法和变量，例如JDK中Math工具类等。java中的代码块基本概念形式如下：12345&#123; System.out.println("这是一个java代码块"); ......&#125;分类：局部代码块和局部变量类似，出现在方法内部，主要用于限制变量和方法的作用域，即代码块外不能访问代码块中的变量和方法构造代码块和类中的构造方法类似，出现在类内部，用来存放基于类的所有对象的公共代码部分，可以降低代码冗余度，会随着对象的创建自动调用静态代码块和静态方法类似，出现在类内部，用来存放类中需要初始化的一些代码（如驱动），随着类的加载而加载，并且自动调用同步代码块用于不同线程间的同步问题一个static和代码块的面试题123456789101112131415161718192021222324252627282930313233343536public class BlockTest &#123; static &#123; System.out.println("BlockTest静态代码块执行"); &#125; &#123; System.out.println("BlockTest构造代码块执行"); &#125; public BlockTest()&#123; System.out.println("BlockTest无参构造执行了"); &#125; public static void main(String[] args) &#123; System.out.println("BlockTest的主函数执行了"); Coder c = new Coder(); Coder c2 = new Coder(); &#125;&#125;class Coder &#123; static &#123; System.out.println("Coder静态代码块执行"); &#125; &#123; System.out.println("Coder构造代码块执行"); &#125; public Coder() &#123; System.out.println("Coder无参空构造执行"); &#125;&#125;问题：代码如上，请写出程序的执行顺序分析如下：​ 首先，程序启动，JVM会加载main函数所在类，即BlockTest这个类，这时候它的静态代码块随之加载并自动执行，打印&quot;BlockTest静态代码块执行&quot;。由于main的调用是基于类的加载，并未实例化BlockTest，故其局部代码块和构造方法都不会执行。​ 接着，调用main函数，打印&quot;BlockTest的主函数执行了&quot;。接着执行Coder c = new Coder()，会加载Coder类，调用其静态代码块，打印&quot;Coder静态代码块执行&quot;。随后，在生成c对象中，首先调用其类中代码块，打印&quot;Coder构造代码块执行&quot;，然后调用其构造方法，打印&quot;Coder无参空构造执行&quot;。​ 最后，执行Coder c2 = new Coder()，和上面类似。不同的是，这时Coder类已经加载，故不会再次调用其静态代码块。但再次生成了一个新的对象c2，因此会调用其类中代码块，打印&quot;Coder构造代码块执行&quot;，接着调用其构造方法，打印&quot;Coder无参空构造执行&quot;。​ 总结：整个程序的打印输出为：1234567BlockTest静态代码块执行BlockTest的主函数执行了Coder静态代码块执行Coder构造代码块执行Coder无参空构造执行Coder构造代码块执行Coder无参空构造执行]]></content>
      <categories>
        <category>java-se</category>
      </categories>
      <tags>
        <tag>java静态</tag>
        <tag>java代码块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中的继承 && abstract && final]]></title>
    <url>%2F2019%2F04%2F25%2Fjava%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF-abstract-final%2F</url>
    <content type="text"><![CDATA[java中的继承java中的继承问题分为两类：一是成员变量的继承；二是成员方法的继承。成员变量的继承特点​ 子类只能继承父类的非私有成员变量成员变量引用原则（就近原则）​ 变量名相同，引用顺序为：局部变量 -&gt; 子类成员变量 -&gt; 父类成员变量变量之间的区别调用​ this调用子类的成员变量，super调用父类的成员变量成员方法的继承特点子类只能继承父类的非私有成员方法子类重写方法的权限修饰符要大于等于其父类，即父类方法是默认权限修饰，则子类方法可以是默认修饰符或者public修饰符成员方法的调用原则（就近原则）​ 方法名相同，调用顺序为：子类方法 -&gt; 父类方法子父类方法之重写与重载方法重写：子类方法与父类方法，不仅方法名相同，而且参数列表相同，返回值也相同，基本上一模一样。只是方法执行代码不同。方法重载：两个方法方法名相同，而参数列表不同，这是函数的重载，要与成员函数的重写加以区分。继承的优缺点继承的优点：提高了代码的复用度，减少了代码冗余提高了代码的可维护性，只用修复父类，则所有子类都修复了增强了类与类之间的联系，也是多态的前提条件继承的缺点：增加了类之间的耦合性，违反了java设计中的“低耦合，高内聚”原则this和super总结关键词含义应用场景this指向调用方法的当前对象1.调用子类的成员变量2.调用子类的成员方法3.在子类的构造函数的第一行调用子类的其他构造函数super指向当前对象的父类对象1.调用父类的成员变量2.调用父类的成员方法3.在子类的构造函数的第一行调用父类的构造函数java关键字之abstractabstract可以用来修饰类和方法，被修饰的类和方法分别被称之为“抽象类”和“抽象方法”概念解析​ 抽象类：只有含有抽象方法的类，肯定是抽象类；抽象类也可以没有抽象方法，不过这样就失去了抽象类的意义。另外，抽象类中可以含有非抽象方法。抽象类无法实例化，但这并不是因为抽象类没有构造方法，只是因为抽象类中存在抽象函数。​ 抽象方法：没有方法体，由关键词abstract修饰的方法叫做抽象方法。注意：一个类继承了抽象类，需要重写其中的所有抽象方法。否则，可以将其声明为抽象类抽象类的成员特点分类特点成员变量1. 可以有成员变量2. 可以有常量成员方法1.可以有抽象方法2.可以有非抽象方法构造方法有构造方法，需要对抽象类成员变量进行初始化构造方法会在对象实例化时，自动调用；如果调用失败，则实例化也失败。java关键字之finalfinal修饰的类，无法被继承final修饰的变量为常量，无法修改。且必须初始化，可以显示初始化（即声明时就初始化）或在构造函数初始化final修饰的成员方法，无法被重写类无法实例化的两种方法给类加上abstract关键字，使其成为抽象类。给类的构造函数加上private关键字，使其在new时，由于构造方法私有不可访问的特性，导致类实例化失败。]]></content>
      <categories>
        <category>java-se</category>
      </categories>
      <tags>
        <tag>java继承</tag>
        <tag>java - abstract</tag>
        <tag>java - fianl</tag>
        <tag>this &amp;&amp; super</tag>
        <tag>java中类无法实例化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java -- 文本文件读写]]></title>
    <url>%2F2019%2F04%2F24%2Fjava-%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%2F</url>
    <content type="text"><![CDATA[文本文件写操作基本流程1、创建FileWriter对象12345FileWriter fw = new FileWriter("~/a.txt"); //覆盖写入或FileWriter fw = new FileWriter("~/a.txt",true); //追加写入2、写入字符串及刷新缓冲区12fw.write("HelloWorld!");fw.flush();3、关闭IO，通知系统释放相关资源1fw.close();换行不同操作系统的换行转义字符存在差异，总结如下：系统换行转义字符windows\r\nmactintosh\rlinux\n文本文件读操作通过字符进行读取12345678910//1.创建FileReader对象FileReader fr = new FileReader("a.txt");//2.读取单个字符int c;//3.循环读取，结束标志为“-1”while (-1 != (c = fr.read()))&#123; System.out.print((char)c);&#125;通过字符数组读取123456789101112//1.创建FileReader对象FileReader fr = new FileReader("a.txt");//2.读取文件到字符数组char[] str = new char[1024];// len记录读取长度int len;//3.循环读取，结束标志为“-1”while ((len = fr.read(str)) != -1)&#123; System.out.print(str,0,len); // 这里必须指定str长度&#125;文本文件高效读写——BufferedReader &amp; BufferedWriter基本操作基本读写方法和流程相同，只不过构造函数略有差异1234567//BufferedReader构造函数BufferedReader br = new BufferedReader(new FileReader("a.txt"));//本质上是将字符暂存在输入流缓冲区，加快读取速率//BufferedWriter构造函数BufferedWriter bw = new BufferedWriter(new FileWriter("a.txt"));//本质上是将字符暂存在输出流缓冲区，加快写入速率特殊函数12345//BufferedWritervoid newLine(); //写一个换行符，由系统决定//BufferedReaderString readLine(); //读取并返回一行数据，不包括换行符，为空则返回NULL]]></content>
      <categories>
        <category>java-se</category>
      </categories>
      <tags>
        <tag>文本文件读写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中为何任何对象都可以和String进行拼接？]]></title>
    <url>%2F2019%2F04%2F24%2Fjava%E4%B8%AD%E4%B8%BA%E4%BD%95%E4%BB%BB%E4%BD%95%E5%AF%B9%E8%B1%A1%E9%83%BD%E5%8F%AF%E4%BB%A5%E5%92%8CString%E8%BF%9B%E8%A1%8C%E6%8B%BC%E6%8E%A5%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[问题引入在学习java-se中偶然对以下代码产生了兴趣，如下：1234 String s ="hello" + 123 + true + 1.32; System.out.println("拼接后的String为：" + s);//out:拼接后的String为：hello123true1.32由上可知，任何变量（不管是基本数据类型，还是引用数据类型）都可以自动向String进行转换，以完成最后的拼接。那么，这背后的操作是如何实现的呢？原理剖析引用数据类型向String的转换引用数据类型，也就是我们常说的类类型，在java中都共同拥有一个顶层父类Object，而在这个Object类中，我们可以发现这样一个方法toString()，其源码如下：123456789101112131415161718192021222324/** * Returns a string representation of the object. In general, the * &#123;@code toString&#125; method returns a string that * "textually represents" this object. The result should * be a concise but informative representation that is easy for a * person to read. * It is recommended that all subclasses override this method. * &lt;p&gt; * The &#123;@code toString&#125; method for class &#123;@code Object&#125; * returns a string consisting of the name of the class of which the * object is an instance, the at-sign character `&#123;@code @&#125;', and * the unsigned hexadecimal representation of the hash code of the * object. In other words, this method returns a string equal to the * value of: * &lt;blockquote&gt; * &lt;pre&gt; * getClass().getName() + '@' + Integer.toHexString(hashCode()) * &lt;/pre&gt;&lt;/blockquote&gt; * * @return a string representation of the object. */ public String toString() &#123; return getClass().getName() + "@" + Integer.toHexString(hashCode()); &#125;通过阅读方法注释，我们不难知道：这个方法是用来输出一个object对象的。所有Java类都是object类的子类，因此所有Java对象都具有toString方法。不仅如此，所有Java对象都可以和字符串进行连接运算，当Java对象和字符串进行连接运算时，系统自动调用Java对象toString()方法，返回值和字符串进行连接运算。基本数据类型向String的转换首先，我们知道在Java中，一切皆对象，但八大基本类型却不是对象。通过上述分析，我们可以解释对象通过toString()转换为字符串后与String对象完成拼接，那么基本数据类型又是如何完成这一过程的呢？要解释这一问题，就要涉及java中基本数据类型的自动装箱技术。所谓装箱，就是把基本类型用它们相对应的引用类型包起来，使它们可以具有对象的特质，如我们可以把int型包装成Integer类的对象，或者把double包装成Double，等等。J2SE5.0后提供了自动装箱与拆箱的功能，此功能事实上是编译器来帮您的忙，编译器在编译时期依您所编写的方法，决定是否进行装箱或拆箱动作。自动装箱的过程：每当需要一种类型的对象时，这种基本类型就自动地封装到与它相同类型的包装中。通过自动装箱，我们就可以很好的解释为什么基本数据类型int、float等能够完成向String的转换与拼接。整个过程就是，编译器检测到我们需要进行int与字符串的拼接，首先自动帮我们将int自动装箱成Integer对象，然后Integer对象调用自身的toString()方法转为字符串，最终完成拼接工作。参考文章Java 包装类 拆箱 装箱java打印对象和toString方法]]></content>
      <categories>
        <category>java-se</category>
      </categories>
      <tags>
        <tag>String拼接</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中数组是对象吗？]]></title>
    <url>%2F2019%2F04%2F22%2Fjava%E4%B8%AD%E6%95%B0%E7%BB%84%E6%98%AF%E5%AF%B9%E8%B1%A1%E5%90%97%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[最近在学习javaSE，其中印象最深的一句话便是“java中一切皆对象”；那么数组作为一种源自C语言的数据结构，在java中它也是对象吗？提出问题这个疑问主要源自对以下代码的疑问：12int[] arr = new int[3];int size = arr.length; #得到数组长度数组居然存在length这个属性，这很明显是对象才具有的特性。同时，数组也排除于8大基本数组类型之外，《java核心卷一》中对数组的定义是：一个数据容器，用来存储相同数据类型的数据集合。相应解释通过万能的Google，让我找到了一篇博文Java中数组的特性 ,恰到好处地诠释了这个问题，现总结如下：可以认定，java中的数组也是对象，它具有java中其他对象的一些基本特点：封装了一些数据，可以访问属性，也可以调用方法。所以，数组是对象。数组也是有类型的，例如int[]的类型是[I，String []的类型是[[Ljava.lang.String等。但是我们没有自己创建这个类，也没有在Java的标准库中找到这个类，这只能有一个解释，那就是虚拟机自动创建了数组类型数组的顶层父类为Object，虽然存在Object[] = 引用数据类型[]，这仅说明引用数据类型[]不继承自Object[]，但是我可以允许你向上转型到Object[]，这种特性是赋予你的一项特权。换一种思考方式，如果有两个类A和B，如果B继承（extends）了A，那么A[]类型的引用就可以指向B[]类型的对象。这种情况同样适用于多维数组，因为我们可以将n维数组看做一维数组中存放着(n-1)维数组几个易错点123456Object[] objArr = new int[3]; //错误因为int不是引用类型，Object不是int的父类，在这里自动装箱不起作用Object[] objArr2 = &#123;"aaa", 1, 2.5&#125;;//这种情况下自动装箱可以工作，也就是说，Object数组中可以存放任何值，包括基本数据类型。//这种特性主要是用于方法中多个参数的传递，方便方法内部访问或遍历数组中的各个元素]]></content>
      <categories>
        <category>java-se</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[成员变量 && 局部变量 && 构造方法 && 导包]]></title>
    <url>%2F2019%2F04%2F22%2F%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-%E5%AF%BC%E5%8C%85%2F</url>
    <content type="text"><![CDATA[java中的“成员变量”和“局部变量”成员变量局部变量声明位置不同在方法外在方法内或方法声明上（形参）存储空间不同在堆内存在栈内存生命周期不同随着对象的产生而产生，随着对象的销毁而销毁随着方法的产生而产生，随着方法的销毁而销毁初始化不同系统自动初始化（通过构造函数完成）手动初始化（不初始化会报错）java 中的构造方法java中的构造方法可以重载java中如果没有构造方法，编译器会自动补上无参构造方法；但一但编译器检测到有构造函数，则不会自动补上无参构造方法，如这时候再调用无参构造，则会报错，因此推荐手动书写无参构造方法。java中的导包属于java.lang包中的类，使用时无需导包，例如Object类、String类等。]]></content>
      <categories>
        <category>java-se</category>
      </categories>
      <tags>
        <tag>“成员变量”和“局部变量”</tag>
        <tag>构造方法</tag>
        <tag>导包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java内存管理 -- 栈 && 堆 && 方法区]]></title>
    <url>%2F2019%2F04%2F22%2Fjava%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E6%A0%88-%E5%A0%86-%E6%96%B9%E6%B3%95%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[“栈”——存储方法及其中的局部变量程序由数据和方法组成，而它们都可以用地址指代。栈便是存储这些地址的地方。栈中的内存是以方法为单位进行划分的，方法调用结束后，内存回收。我们在栈中调用某个方法，首先先开辟一块栈内存区，内存区的开头存储的是被调用方法地址，其他内存空间用于存储方法中的局部变量地址。然后cpu通过方法的地址，到方法区查找并执行对应代码。遇到变量，则存储在之前的栈内存中；遇到方法，则在栈中开辟新的内存空间。方法之间的调用是以“栈”的形式体现的，即“被调用”的方法，后入栈，先出栈。“堆”——存储New出来的对象由JVM的垃圾回收机制进行管理，空闲时回收“方法区”——存储方法代码在java中，方法区一般存储着class文件，而方法则包含在相应的class中举个栗子“堆”和“栈”的例子1int[] arr = new int[3];如上，我们声明并初始化了一个整型数组。其中整型数组 arr 就是“栈”变量，而 new int[3] 属于堆变量。“方法区”的例子如下图所示，当jvm调用方法时，无论是main方法还是change方法，其都是通过在方法区查找对应class文件中的对应方法，然后将对应代码加载到栈内存，最后由cpu去执行。]]></content>
      <categories>
        <category>java-se</category>
      </categories>
      <tags>
        <tag>java内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux -- 编译JDK源码]]></title>
    <url>%2F2019%2F04%2F19%2Flinux-%E7%BC%96%E8%AF%91JDK%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[获取JDK源码java 8 源代码地址：http://jdk.java.net/8/java 9 源代码地址：http://jdk.java.net/java-se-ri/9java 10 源代码地址：http://jdk.java.net/10/环境构建1 安装相关依赖123456#安装aptitude（在处理依赖问题上更佳。aptitude 在删除一个包时，会同时删除本身所依赖的包）sudo apt-get install aptitude#更新源信息sudo aptitude update#安装编译openjdk8所需依赖sudo aptitude install build-essential libx11-dev libxext-dev libxrender-dev libxtst-dev libxt-dev libcups2-dev libfreetype6-dev libasound2-dev ccache2 下载Bootstrap JDK一般选择落后一个大版本的JDK作为Bootstrap JDK，这里安装了OpenJDK 7。据说Ubuntu18.04已经去除了openJdk-7的源，所以本次进行了下载后手动安装：[openjdk-7-jdk](https://packages.debian.org/experimental/openjdk-7-jdk) [openjdk-7-jre](https://packages.debian.org/experimental/openjdk-7-jre) [openjdk-7-jre-headless](https://packages.debian.org/experimental/openjdk-7-jre-headless) [libjpeg62-turbo](https://packages.debian.org/sid/libjpeg62-turbo) [libfontconfig1](https://packages.debian.org/sid/libfontconfig1) [fontconfig-config](https://packages.debian.org/sid/fontconfig-config) 下载以上安装包，然后执行命令：sudo dpkg -i openjdk-7-* libjpeg62-turbo* libfontconfig1* fontconfig-config*如果在安装过程中报错，则执行以下命令：sudo apt --fix-broken install3 切换默认jdkupdate-alternatives是Debian系统中专门维护系统命令链接符的工具，通过它可以很方便的设置系统默认使用哪个命令、哪个软件版本，比如系统中同时安装了open jdk和sun jdk两个版本，而我们又希望系统默认使用sun jdk，通过update-alternatives就可以方便实现管理。通过sudo update-alternatives --config java进行java版本切换4 安装gcc-4.8 和g++ 4.8之前使用apt 默认安装了最新的gcc-7，导致jdk编译中语法大量报错，浪费了大量时间进行改错第一步：1sudo apt-get install gcc-4.8第二步：设置默认的gcc版本1sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.8 100如果用过此方法配置过多个gcc版本，会看到如下选项12345678910➜ openjdk update-alternatives --config gcc There are 2 choices for the alternative gcc (providing /usr/bin/gcc). Selection Path Priority Status------------------------------------------------------------ 0 /usr/bin/gcc-7 50 auto mode* 1 /usr/bin/gcc-4.8 20 manual mode 2 /usr/bin/gcc-7 50 manual modePress &lt;enter&gt; to keep the current choice[*], or type selection number:按同样的方法配置g++配置、编译OpenJDK 81 配置1bash ./configure --with-target-bits=64 --with-debug-level=slowdebug --enable-debug-symbols ZIP_DEBUGINFO_FILES=0一般没什么问题，有的话，按照提示进行fix2 编译及排错开始编译1make all ZIP_DEBUGINFO_FILES=0排错错误1123*** This OS is not supported: Linux ethan 4.4.0-133-generic #159~14.04.1-Ubuntu SMP Fri Aug 10 08:17:48 UTC 2018 x86_64 x86_64 x86_64 GNU/Linuxmake[5]: *** [check_os_version] 错误 1make[4]: *** [linux_amd64_compiler2/debug] 错误 2解决1修改文件 ./hotspot/make/linux/Makefile修改 SUPPORTED_OS_VERSION = 2.4% 2.5% 2.6% 2.7% 为SUPPORTED_OS_VERSION = 2.4% 2.5% 2.6% 2.7% 3% 4%错误212error: ‘int readdir_r(DIR*, dirent*, dirent**)’ is deprecated [-Werror=deprecated-declarations] if((status = ::readdir_r(dirp, dbuf, &amp;p)) != 0) &#123;解决2修改文件vim hotspot/make/linux/makefiles/gcc.make12# Compiler warnings are treated as errors# WARNINGS_ARE_ERRORS = -Werror3 编译成功123456789101112131415161718## Finished docs (build time 00:02:28)----- Build times -------Start 2019-04-15 01:48:49End 2019-04-15 02:04:0700:00:30 corba00:00:24 demos00:02:28 docs00:07:24 hotspot00:00:27 images00:00:17 jaxp00:00:26 jaxws00:03:04 jdk00:00:01 langtools00:00:16 nashorn00:15:18 TOTAL-------------------------Finished building OpenJDK for target 'all'参考资料mac下编译openjdk1.9及集成clion动态调试CentOS上编译OpenJDK8源码 以及 在eclipse上调试HotSpot虚拟机源码]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>编译JDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[openjdk-8 -- 使用Clion调试源码]]></title>
    <url>%2F2019%2F04%2F19%2Fopenjdk-8-%E4%BD%BF%E7%94%A8Clion%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[终端中gdb断点进入源码调试hotspot1 编译class12345678910vim ~/Test.java# 输入以下内容public class Test&#123; public static void main(String[] args)&#123; System.out.println("hello world !"); &#125;&#125;/root/openjdk/build/linux-x86_64-normal-server-slowdebug/jdk/bin/javac Test.java/root/openjdk/build/linux-x86_64-normal-server-slowdebug/jdk/bin/java Testhello world2 进入gdb测试12345678910# 第一步，启动gdbgdb --args /root/openjdk/build/linux-x86_64-normal-server-slowdebug/jdk/bin/java ~/Test# 第二步，设置断点(gdb) break init.cpp:95# 第三步，开始debug(gdb) run# debug会在断点处停止，可以查看断点处代码(gdb) l# 最后，退出gdb(gdb) quit整个操作如下图所示：在IDE中调试，这里选择Clion1 导入项目打开clion，选择 File-&gt;ImportProject，选择到 ~/ClionProjects/openjdk-8/hotspot作为jvm源码的根目录，这里导入的过程无脑点击next即可对于可能遇到的头文件不包含问题，解决如下：clion导入源码之后遇到头文件找不到的问题，而实际上这些头文件在源码里面是存在的，只不过在某些源文件里面是以相对路径的方式来搜索，可以在CMakeLists.txt里面添加一些根路径1234include_directories(./src/share/vm)include_directories(./src/cpu/x86/vm)include_directories(./src/share/vm/precompiled)include_directories(./src/share/vm/utilities)另外，如果某些头文件依然找不到，可以手工导入，然后把导入的头文件加到hotspot/src/share/vm/precompiled/precompiled.hpp里，因为大多数源文件都会包含这个源文件12345678# include &lt;cstdlib&gt;# include &lt;cstdint&gt;# include &quot;register_x86.hpp&quot;# include &quot;assembler_x86.hpp&quot;# include &quot;globalDefinitions.hpp&quot;# include &quot;globalDefinitions_x86.hpp&quot;# include &quot;assembler_x86.hpp&quot;#include &lt;stubRoutines_x86.hpp&gt;2 配置debug右上角，点击Edit Configuration进入如下界面，添加Application：jdk-8，Execuable中选择～/CLionProjects/openjdk-9/build/linux-x86_64-normal-serverANDclient-slowdebug/jdk/binBefore lauch: Activate tool window 下的预build项一定要去掉，我的已经去掉了3 设置断点，开始debug断点选在jni.cpp的创建vm处，然后开始debug这里如果报错，如下图所示：可以在点击LLDB，输入process handle SIGSEGV --stop=false即可，这里告诉编译器忽略错误一般Clion默认使用GDB进行debug，可以根据如下所示进行切换同理，若为GDB的话，点击输入handle SIGSEGV pass noprint nostop即可动图如下：参考资料深入jvm内部掌握java线程的运行原理]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Clion调试JDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux -- 编译命令总结]]></title>
    <url>%2F2019%2F04%2F13%2Flinux-%E7%BC%96%E8%AF%91%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[在平时的linux开发中，特别是非IDE开发 中，总是会或多或少的遇到相关开发命令，特点总结如下：分类编译命令 gcc g++gcc是linux平台中默认的c语言编译命令，g++则是对应c++编译命令编译批处理命令make如果源文件太多，一个一个编译时就会特别麻烦，于是人们想到可以通过批处理来编译源文件，make就是在这样的初衷下诞生的。但make命令有一个不方便的地方，就是你必须自己编辑makefile文件来指导make的编译过程，这在遇到大工程时，难度是不可想象的。make还支持增量编译，即当我们改变了一小部分的源码文件的时候重新执行make，它将不会重新编译整个程序，而是仅仅更新那些直接或者间接依赖这些改变了的源码文件的非源码文件。自动生成makefile的cmake尽管cmake命令也需要手动编辑CMakeLists.txt文件来指导cmake命令，但相较于 makefile的编辑，难度已大大降低。除此之外，cmake还支持跨平台makefile生成。它会自动辨别使用那种编译器去编译给出的源码种类，自动发现跨平台系统库。简而言之，就是cmake可以帮我们解决系统环境相关配置，解决跨平台编译难题。实践在平时的使用中，基本遵循一下流程：123456# 1.编辑CMakeLists.txt, 执行cmake &lt;path.CMakeList.txt&gt;, 生成makefilecmake ./CMakeLists.txt# 2.执行make，进行批量编译make# 3. 进入可执行文件所在目录，运行./runflie]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux - 编译命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux -- make install的安装与卸载]]></title>
    <url>%2F2019%2F04%2F13%2Flinux-make-install%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8D%B8%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[在ubuntu中安装程序时，并不能总能通过apt等包管理器完成；这时候就不得不通过编译源码，安装二进制程序解决。但如果make install默认安装的话，就会给之后的程序卸载带来隐患；基于这些问题，先记录如下：安装make install 一般会加上option参数--prefix ,表示安装对应目录。如：1make install --prefix=/opt/application如果不配置该选项，安装后可执行文件默认放在/usr/local/bin，库文件默认放在/usr/local/lib，配置文件默认放在/usr/local/etc，其它的资源文件放在/usr/local/share，比较凌乱。用--prefix选项的另一个好处是方便卸载软件或移植软件；当某个安装的软件不再需要时，只须简单的删除该安装目录，就可以把软件卸载得干干净净；而移植软件只需拷贝整个目录到另外一个机器即可（相同的操作系统下）。卸载如果按照上面的操作方式 ，即加上了--prefix参数，那么直接删除对应配置目录，卸载就完成了万一在make install时，忘记加上--prefix参数，那么可以采取1make install &amp; &gt; Log_install这样做，会重新覆盖安装，并且将对应的安装信息写入Log_install 文件中。我们只需根据日志文件，删除对应目录的文件，即可完成卸载。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux - make命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux -- 文件编码与转换]]></title>
    <url>%2F2019%2F04%2F12%2Flinux-%E6%96%87%E4%BB%B6%E7%BC%96%E7%A0%81%E4%B8%8E%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[使用vim进行文档识别（不改变编码）由于windows系统普遍采用GBK编码，这样导致在windows上编辑的文本转移到采用utf-8编码的linux上后，容易出现乱码现象。其中的原因是，GBK编码的文件在linux上以utf-8进行解码，会出错。于是，接下来打算在vim中以fileencodings的方式进行尝试解码，然后用vim的utf-8缓存编码进行显示操作如下：1.打开vimrc文件，没有则新建1vim ~/.vimrc2.在vimrc中添加12set encoding=utf-8set fileencodings=ucs-bom,utf-8,cp936知识补充vim 中通过底部命令set fileencoding显示当前编辑文件编码encoding: Vim 内部使用的字符编码方式，包括 Vim 的 buffer (缓冲区)、菜单文本、消息文本等。fileencoding: Vim 中当前编辑的文件的字符编码方式，Vim 保存文件时也会将文件保存为这种字符编码方式 (不管是否新文件都如此)。fileencodings: Vim自动探测fileencoding的顺序列表，启动时会按照它所列出的字符编码方式逐一探测即将打开的文件的字符编码方式，并且将 fileencoding 设置为最终探测到的字符编码方式。ermencoding: Vim 所工作的终端 (或者 Windows 的 Console 窗口) 的字符编码方式。如果vim所在的term与vim编码相同，则无需设置。如其不然，你可以用vim的termencoding选项将自动转换成term 的编码.这个选项在 Windows 下对我们常用的 GUI 模式的 gVim 无效，而对 Console 模式的Vim 而言就是 Windows 控制台的代码页，并且通常我们不需要改变它。使用iconv进行编码转换经过尝试，在vim中，通过底部命令set fileencoding=utf-8，即使将原GBK（也称cp936）编码的文档转码为utf-8，在vim中显示也依然存在乱码现象。问题分析：这种原因可能是在vim中set fileencoding=utf-8 仅仅是改变了文档编码标志，并未真正改变其编码。基予此，采用iconv进行转码操作。iconv命令是用来转换文件的编码方式的（Convert encoding of given files from one encoding to another），比如它可以将UTF8编码的转换成GB18030的编码，反过来也行。命令如下：1iconv -f &#123;&#123;from_encoding&#125;&#125; &#123;&#123;input_file&#125;&#125; &gt; &#123;&#123;output_file&#125;&#125;实际上vim的编码自适应显示，底层也是调用了iconv命令]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>文件乱码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux -- 软链接和硬链接]]></title>
    <url>%2F2019%2F04%2F12%2Flinux-%E8%BD%AF%E9%93%BE%E6%8E%A5%E5%92%8C%E7%A1%AC%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[文件名和数据文件名与数据，这在 Linux 上被分成两个部分：用户数据 (user data) 与元数据 (metadata)。如下所示：用户数据，即文件数据块（data block），是真正记录数据的地方；而元数据（metadata）是记录文件相关属性（如文件名、文件大小、索引节点inode）的地方。并且实际上，linux系统是通过inode进行文件查找等相关操作的。文件名主要是为了方便用户对文件的识记。显示inode节点可以使用stat或ls -i命令硬链接与软链接为解决文件共享，引入了软硬链接。链接为 Linux 系统解决了文件的共享使用，还带来了隐藏文件路径、增加权限安全及节省存储等好处。硬链接 硬链接文件除了文件名与所指向文件不同外，其余全部相同，即原被链接文件inode对应多个文件名。通过如下方式创建硬链接：1link oldfile hard.link特点如下：文件有相同的 inode 及 data block；只能对已存在的文件进行创建；不能交叉文件系统进行硬链接的创建；不能对目录进行创建，只可对文件创建；删除一个硬链接文件并不影响其他有相同 inode 号的文件。软链接 就是一个普通文件，只是数据块内容写有指向文件的inode信息。软链接也有自己的 inode 号以及用户数据块。通过如下方式创建软链接：1ln -s old.file soft.link特点如下：软链接有自己的文件属性及权限等；可对不存在的文件或目录创建软链接；软链接可交叉文件系统；软链接可对文件或目录创建；创建软链接时，链接计数 i_nlink 不会增加；删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接（即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接）。链接相关命令使用find 命令，其不仅可查找某文件的软链接，还可以用于查找相同 inode 的所有硬链接。12345678910// 查找目录下文件的软链接find &lt;directory&gt; -lname &lt;file&gt;// 查找目录下文件的硬链接find &lt;directory&gt; -samefile &lt;file&gt;orfind &lt;directory&gt; -inum &lt;inode&gt;// 列出目录下所有的软链接find &lt;directory&gt; -type l -ls]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>软链接和硬链接</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ruby -- 安装]]></title>
    <url>%2F2019%2F04%2F10%2FRuby-%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Ruby 安装分3中途径：官方下载源码，编译make，然后make install，优点是可以保持版本最新通过系统自带apt 安装，sudo apt install -y ruby-full ，简单快捷，但一般版本偏旧通过第三方包管理器安装，这里选择RVMRVM安装Ruby安装RVM12gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDBcurl -sSL https://get.rvm.io | bash -s stable安装过后，需要刷新一下bash环境1source /etc/profile.d/rvm.sh检查是否安装成功1rvm -v用RVM安装Ruby1.查看已发布Ruby1rvm list known2.安装指定版本的Ruby，完成后Ruby和RubyGems会同时安装好1rvm install 2.6.23.设置默认ruby版本1rvm 2.6.2 --default如果报错12345RVM is not a function, selecting rubies with 'rvm use ...' will not work.You need to change your terminal emulator preferences to allow login shell.Sometimes it is required to use `/bin/bash --login` as the command.Please visit https://rvm.io/integration/gnome-terminal/ for an example.只需执行/bin/zsh --login 即可解决，更多请看这里4.检查ruby和gem是否安装成功12ruby -vgem -vRVM常用命令查询已安装的ruby1rvm list卸载指定版本ruby1rvm remove 2.6.2Ruby中国源替换替换命令12gem source -r https://rubygems.org/gem source -a https://gems.ruby-china.com/查看当前源1gem sources -l]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>ruby</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux -- 程序安装]]></title>
    <url>%2F2019%2F04%2F10%2Flinux-%E7%A8%8B%E5%BA%8F%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[平时在linux使用当中，经常会碰到安装各种程序。但由于使用惯了windows系统，往往会反复的去Google；结果再次遇到时，又忘得一干二净了。基于此，特地总结如下：在linux中，一般存在3种程序安装的方法。二进制文件安装1.下载文件，解压到安装目录安装目录分为3类：/usr：系统级的目录，可以理解为C:/Windows/，/usr/lib理解为C:/Windows/System32。/usr/local：用户级的程序目录，可以理解为C:/Progrem Files/。这里主要存放那些手动安装的软件，即不是通过apt-get安装的软件。它和/usr目录具有相类似的目录结构。让软件包管理器来管理/usr目录，而把自定义的脚本(scripts)放到/usr/local目录下面，我想这应该是个不错的主意。/opt：用户级的程序目录，可以理解为D:/Software，opt有可选的意思，这里可以用于放置第三方大型软件（或游戏），当你不需要时，直接rm -rf掉即可。在硬盘容量不够时，也可将/opt单独挂载到其他磁盘上使用。2.添加软连接(以nodejs为例)12sudo ln -s /usr/local/node/bin/npm /usr/local/bin/npmsudo ln -s /usr/local/node/bin/node /usr/local/bin/node源码编译安装1.下载源码1sudo git clone https://github.com/nodejs/node.git2.修改目录权限1sudo chmod -R 755 node3.通过configure生成配置文件，并编译安装1234cd nodesudo ./configuresudo makesudo make install通过包管理器安装12sudo apt-get install nodejssudo apt-get install npm]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux - 程序安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu -- apt update error]]></title>
    <url>%2F2019%2F04%2F10%2Fubuntu-apt-update-error%2F</url>
    <content type="text"><![CDATA[最近在一次ubuntu的例行apt更新中，竟然报错了；在一阵疯狂Google后，总算是解决了，现总结如下：出现错误尝试sudo apt update，输出如下错误：12345$ Err:17 http://ppa.launchpad.net/a-v-shkop/chromium/ubuntu bionic Release 404 Not Found [IP: 91.189.95.83 80]Reading package lists... Done E: The repository 'http://ppa.launchpad.net/a-v-shkop/chromium/ubuntu bionic Release' does not have a Release file.N: Updating from such a repository can't be done securely, and is therefore disabled by default.解决方案根据错误提示，可知为ppa源问题，解决如下：1sudo add-apt-repository -r http://ppa.launchpad.net/a-v-shkop/chromium/ubuntu另外，网上还给出了额外的shell脚本解决方法1.touch ppa-remove 新建一个文本输入如下内容：12345678910111213141516#!/bin/bashsudo rm /tmp/update.txt; tput setaf 6; echo "Initializing.. Please Wait" sudo apt-get update &gt;&gt; /tmp/update.txt 2&gt;&amp;1; awk '( /W:/ &amp;&amp; /launchpad/ &amp;&amp; /404/ ) &#123; print substr($5,26) &#125;' /tmp/update.txt &gt; /tmp/awk.txt; awk -F '/' '&#123; print $1"/"$2 &#125;' /tmp/awk.txt &gt; /tmp/awk1.txt; sort -u /tmp/awk1.txt &gt; /tmp/awk2.txttput sgr0if [ -s /tmp/awk2.txt ]then tput setaf 1 printf "PPA's going to be removed\n%s\n" "$(cat /tmp/awk2.txt)" tput sgr0 while read -r line; do echo "sudo add-apt-repository -r ppa:$line"; done &lt; /tmp/awk2.txt &gt; out bash outelse tput setaf 1 echo "No PPA's to be removed" tput sgr0fi2.赋予文件执行权限1sudo chmod +x ppa-remove3.运行1sudo ./ppa-remove]]></content>
      <categories>
        <category>踩坑</category>
      </categories>
      <tags>
        <tag>linux - apt update error</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度anyQ -- 编译错误]]></title>
    <url>%2F2019%2F04%2F10%2F%E7%99%BE%E5%BA%A6anyQ-%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[偶然在github上发现了百度的anyQ智能对话框架，刚好自己也在研究这一块，遂决定重现一下这个模型。中途遇到不少编译错误，现记录下来错误执行mkdir build &amp;&amp; cd build &amp;&amp; cmake .. &amp;&amp; make 后报错如下：1234/home/AnyQ/build/third_party/include/dmlc/./logging.h:323:31: error: ‘DMLC_LOG_STACK_TRACE_SIZE’ was not declared in this scopemake[2]: *** [third_party/paddle/src/extern_paddle-stamp/extern_paddle-build] Error 2make[1]: *** [CMakeFiles/extern_paddle.dir/all] Error 2make: *** [all] Error 2解决方法：首先将原官方https://github.com/baidu/AnyQ.git 替换为 https://github.com/ljch2018/AnyQ.git然后修改如下两个文件，使之以单线程编译即可1234xgboost.cmake：INSTALL_COMMAND cd $&#123;XGBOOST_INSTALL_DIR&#125; &amp;&amp; make -j1paddle.cmakeBUILD_COMMAND cd $&#123;PADDLE_INSTALL_DIR&#125; &amp;&amp; make -j1建议尽量使用官方的docker镜像，避免不必用的环境问题12# paddle官方镜像docker pull paddlepaddle/paddle:latest-dev]]></content>
      <categories>
        <category>智能对话系统</category>
      </categories>
      <tags>
        <tag>anyQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker -- 容器操作]]></title>
    <url>%2F2019%2F04%2F09%2FDocker-%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Docker之容器操作启动容器启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（stopped）的容器重新启动。新建并启动所需的命令主要为 docker run例如，下面的命令输出一个 “Hello World”，之后终止容器。12docker run ubuntu:18.04 /bin/echo 'Hello world'Hello world下面的命令则启动一个 bash 终端，允许用户进行交互。12docker run -t -i ubuntu:18.04 /bin/bashroot@af8bae53bdd3:/#当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括：检查本地是否存在指定的镜像，不存在就从公有仓库下载利用镜像创建并启动一个容器分配一个文件系统，并在只读的镜像层外面挂载一层可读写层从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去从地址池配置一个 ip 地址给容器执行用户指定的应用程序执行完毕后容器被终止启动已终止容器利用 docker container start 命令，直接将一个已经终止的容器启动运行。守护态运行使用命令docker run -d启动容器，即使容器在后台运行。使用 -d 参数启动后会返回一个唯一的 id，这和bash中command &amp;命令类似。两个有用的命令：查看容器信息123docker container lsCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES77b2dc01fe0f ubuntu:18.04 /bin/sh -c 'while tr 2 minutes ago Up 1 minute agitated_wright获取容器的输出信息1docker container logs [container ID or NAMES]进入容器容器进入后台运行后，如何再次进入该容器？使用 docker attach 命令或 docker exec 命令，推荐使用docker exec，原因如下：使用docker attach进入容器后，若再次退出，会导致该后台容器stop而使用docker exec 进入容器后，若再次退出，不会导致后台容器stop，容器会依旧后台运行12345docker run -dit ubuntu69d137adef7a8a689cbcb059e94da5489d3cddd240ff675c640c8d96e84fe1f6docker exec -it 69d1 bashroot@69d137adef7a:/#终止容器使用 docker container stop 来终止一个运行中的容器。此外，当 Docker 容器中指定的应用终结时，容器也自动终止。终止状态的容器可以用 docker container ls -a 命令看到1234docker container ls -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESba267838cc1b ubuntu:18.04 "/bin/bash" 30 minutes ago Exited (0) About a minute ago trusting_newton98e5efa7d997 training/webapp:latest "python app.py" About an hour ago Exited (0) 34 minutes ago backstabbing_pike导出和导入容器导出容器如果要导出本地某个容器，可以使用 docker export 命令。1234docker container ls -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES7691a814370e ubuntu:18.04 "/bin/bash" 36 hours ago Exited (0) 21 hours ago testdocker export 7691a814370e &gt; ubuntu.tar这样将导出容器快照到本地文件。导入容器快照可以使用 docker import 从容器快照文件中再导入为镜像，例如1234cat ubuntu.tar | docker import - test/ubuntu:v1.0docker image lsREPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZEtest/ubuntu v1.0 9d37a6082e97 About a minute ago 171.3 MB此外，也可以通过指定 URL 或者某个目录来导入，例如1docker import http://example.com/exampleimage.tgz example/imagerepo删除容器可以使用 docker container rm 来删除一个处于终止状态的容器。例如12docker container rm trusting_newtontrusting_newton如果要删除一个运行中的容器，可以添加 -f 参数。Docker 会发送 SIGKILL 信号给容器清理所有处于终止状态的容器用 docker container ls -a 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。1docker container prune]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>docker - 容器操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker -- 镜像操作]]></title>
    <url>%2F2019%2F04%2F09%2FDocker-%E9%95%9C%E5%83%8F%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[获取镜像从 Docker 镜像仓库获取镜像的命令是 docker pull。其命令格式为：1docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]具体的选项可以通过 docker pull --help 命令看到，这里我们说一下镜像名称的格式。Docker 镜像仓库地址：地址的格式一般是 &lt;域名/IP&gt;[:端口号]。默认地址是 Docker Hub。仓库名：如之前所说，这里的仓库名是两段式名称，即 &lt;用户名&gt;/&lt;软件名&gt;。对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像。下载也是一层层的去下载，并非单一文件。下载过程中给出了每一层的 ID 的前 12 位。并且下载结束后，给出该镜像完整的 sha256 的摘要，以确保下载一致性。列出镜像要想列出已经下载下来的镜像，可以使用 docker image ls 命令。删除本地镜像如果要删除本地的镜像，可以使用 docker image rm 命令，其格式为：1docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]其中，&lt;镜像&gt; 可以是 镜像短 ID、镜像长 ID、镜像名 或者 镜像摘要容器对镜像的依赖如果有用这个镜像启动的容器存在（即使容器没有运行），那么同样不可以删除这个镜像。之前讲过，容器是以镜像为基础，再加一层容器存储层，组成这样的多层存储结构去运行的。因此该镜像如果被这个容器所依赖的，那么删除必然会导致故障。如果这些容器是不需要的，应该先将它们删除，然后再来删除镜像。]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>docker - 镜像操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker -- 安装]]></title>
    <url>%2F2019%2F04%2F09%2Fdocker-%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[卸载旧版本123sudo apt-get remove docker \ docker-engine \ docker.io安装使用APT安装1.https依赖123456sudo apt updatesudo apt-get install \ apt-transport-https \ ca-certificates \ curl \ software-properties-common2.添加国内源为了确认所下载软件包的合法性，需要添加软件源的 GPG 密钥1curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -​ 向 source.list 中添加 Docker 软件源1234sudo add-apt-repository \ "deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \ $(lsb_release -cs) \ stable"3.安装docker-ce12sudo apt-get updatesudo apt-get install docker-ce使用脚本自动安装在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，Ubuntu 系统上可以使用这套脚本安装：12curl -fsSL get.docker.com -o get-docker.shsudo sh get-docker.sh --mirror Aliyun启动 docker-ce12sudo systemctl enable dockersudo systemctl start docker默认情况下，docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组。1.建立 docker 组：1sudo groupadd docker2.将当前用户加入 docker 组：1sudo usermod -aG docker $USER3.重启 docker 服务1sudo systemctl restart docker4.切换当前会话到新 group 或者重启 X 会话注意:最后一步是必须的，否则因为 groups 命令获取到的是缓存的组信息，刚添加的组信息未能生效，所以 docker images 执行时同样有错。1newgrp - docker镜像加速对于使用 systemd 的系统，请在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件）123&#123; "registry-mirrors": ["https://docker.mirrors.ustc.edu.cn"]&#125;注意，一定要保证该文件符合 json 规范，否则 Docker 将不能启动。之后重新启动服务。12sudo systemctl daemon-reloadsudo systemctl restart docker]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>docker - 安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker -- 网络访问]]></title>
    <url>%2F2019%2F04%2F09%2Fdocker-%E7%BD%91%E7%BB%9C%E8%AE%BF%E9%97%AE%2F</url>
    <content type="text"><![CDATA[分类外部访问容器或容器访问外部（一般是容器间相互访问）外部访问容器由于docker容器的封闭性，外部要访问容器内资源，必须借助host主机的端口映射，相关命令如下：系统随机分配主机端口给容器，完成映射1docker run -P &lt;image ID&gt;-p 则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有1docker run -p ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort第一种格式是外部指定ip固定端口，第二种是外部指定ip随机端口，第三种是外部所有ip指定端口查看端口映射使用 docker port 来查看当前映射的端口配置，也可以查看到绑定的地址使用 docker container ls通过 docker logs 命令来查看应用的信息容器互联新建网络先创建一个新的 Docker 网络。1docker network create -d bridge my-net-d 参数指定 Docker 网络类型，有 bridge、 overlay运行一个容器并加入到 my-net 网络，使用--network1docker run -it --rm --name busybox1 --network my-net busybox sh以这样的方式可以加入多个容器]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>docker - 网络访问</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker -- Error response from daemon]]></title>
    <url>%2F2019%2F04%2F09%2Fdocker-Error-response-from-daemon%2F</url>
    <content type="text"><![CDATA[错误如下：1docker: Error response from daemon: OCI runtime create failed: container_linux.go:348: starting container process caused "process_linux.go:297: copying bootstrap data to pipe caused \"write init-p: broken pipe\"": unknown.由于docker的版本更新引起解决办法： 3种任选其一使用低版本的dockerdocker CE1sudo apt-get install docker-ce=18.06.1~ce~3-0~ubuntudocker EE on CentOS 7123sudo curl -SsL https://download.docker.com/linux/centos/docker-ce.repo -o /etc/yum.repos.d/docker-ce.reposudo yum --showduplicates list docker-cesudo yum install docker-ce-18.06.1.ce-3-0.el7.centos更多其他版本的安装，看这里升级linux内核例如，你现在在用Ubuntu 14.04，可以将其升级到Ubuntu 16 Xenial1sudo apt-get install linux-generic-lts-xenial升级系统版本对于Ubuntu 14.04，你可以使用一下命令升级到Xenial1sudo do-release-upgrade如果遇到14.04 --&gt; 16.04 failed; apt (&gt;= 1.0.1ubuntu2.13)&#39; is not installed报错，可以执行以下命令：12sudo apt updatesudo apt dist-upgrade]]></content>
      <categories>
        <category>踩坑</category>
      </categories>
      <tags>
        <tag>docker -- Error response from daemon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker -- 初识]]></title>
    <url>%2F2019%2F04%2F08%2Fdocker-%E5%88%9D%E8%AF%86%2F</url>
    <content type="text"><![CDATA[什么是docker传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。​ 传统虚拟化​ docker容器docker优点资源利用率高启动速度更快一致的运行环境持续交付和部署更轻松的迁移、维护和拓展……]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>docker - 初识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git -- 常用操作总结(一)]]></title>
    <url>%2F2018%2F11%2F26%2FGit-%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[git初识git 安装与登陆安装(linux)：1sudo apt-get install git登陆：由于git的分布式特性，每一个使用其的电脑都必须注册自己，如下：12git config --global user.name "Your name"git ocnfig --global user.email "Your email"git创建版本库创建一个空目录12mkdir learngitcd ./learngit将该目录初始化为git仓库1git init #git的初始化，即将当前目录与git仓库进行关联，当前目录会自动生成一个.git文件夹把文件添加到版本库123echo "Git is a version control system" &gt;&gt; readme.txtgit add readme.txt #将文件由workdirctory添加到stage(暂存区)git commit -m "wrote a readme file" #将stage的修改添加到版本库git版本控制版本回退提交历史显示命令，用于查看提交历史记录，以便确定要回退到哪个版本1git log #查看提交历史回退命令，其中HEAD指向当前版本，HEAD^指向上一个版本，HEAD^^指向上上个版本123git reset --hard commit_id #将仓库回退到指定id版本# orgit reset --hard HEAD^ #将仓库回退到上一版本当版本回退成功后，原来的版本丢失，通过 git log 无法查看其commit _id ，这时候可以使用git reflog1git reflog #查看命令历史工作区 暂存区 版本库工作区：可以理解为自己的本机工作目录，并且这个目录是还未进入git版本库管理的。在这个状态下，我们可以进行增、删、改各种操作。暂存区：是所有操作真正提交到版本库的前一步，主要是追踪各种操作，以及为多次操作后的批量提交作准备，避免频繁提交。版本库：可以简单理解为仓库，进入版本库也就意味着已经登记入库了。版本库还可以进一步分为多个分支，一般有一个master主分支，多个次分支，这样可以进行多个版本的跟踪。新增、修改与删除不管是文件的新增，还是修改，我们在工作区完成操作后，都是通过add命令完成向暂存区提交的1git add readme.txt若是删除文件，我们同样要向暂存区报备，通过rm命令记录删除操作1git rm readme.txt最后通过commit命令提交到分支使操作真正生效1git commit -m "add readme.txt/del readme.txt"操作回滚操作回滚分为三类场景：（1）如果你只是误操作，还未进行add提交到暂存区，那么只需一步操作就可以反悔1git checkout -- "readme.txt" #由于还未add，即意味暂存区还保留着该操作在工作区的上一状态，直接checkout就行（2）如果你手残地add到了暂存区，那就要分两步完成回滚12git reset HEDA "readme.txt" #将暂存区的该次误操作丢弃，并重置为分支中的最新版本状态，其他操作不受影响git checkout -- "readme.txt" #将此时暂存区的状态映射到工作区，即将误操作回复为版本库状态（3）如果你不幸到已经commit了误操作，那即意味着误操作已经进入分支中，成为了最新版本，这时候只能通过版本回退的方式来补救1git reset --hard HEAD^ #后退到误操作之前的那个版本，这样可能丢失除误操作以外的其他有用操作从以上操作我们不难发现，暂存区的存在确保了工作区的不当操作不会直接影响分支；同时，我们可以将多次add/rm操作进行一次commit提交，可以起到对操作的分组效果；最后，如果你只是在场景(1)(2)回退，那么可以最大程度的减小对其他add/rm操作的影响，不至于在回滚某个操作时，丢失其他操作。而(3)版本回退显然不是针对某个特定操作，这种回退的代价是难以估量的。git远程操作与github进行连接通过SSH协议将本地git仓库与github进行配对，首先生成SSH key1ssh-keygen -t rsa -C "youremail"执行过后，生成.ssh 目录，其中id_rsa 和id_rsa_pub 分别代表私钥和公钥。我们只需将公钥中的字符串添加到github账户的”AccountSetting”的”SSH Keys”页面中，就OK了。添加远程仓库添加github仓库命令1git remote add orgin 仓库地址 #orgin为默认远程仓库地址别名将本地库推送到远程仓库1git push -u origin master #第一次将本地的master分支推送到远程，以后可以省略'-u'克隆远程库直接从远程克隆git仓库，也可以完成本地与远程的关联1git clone &lt;ssh/https&gt;远程库地址]]></content>
      <categories>
        <category>版本控制</category>
      </categories>
      <tags>
        <tag>git - 常用操作总结(一)</tag>
      </tags>
  </entry>
</search>
