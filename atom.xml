<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RQ BLOG</title>
  
  <subtitle>真正的梦就是现实的彼岸。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://rqsir.github.io/"/>
  <updated>2019-07-08T07:28:22.663Z</updated>
  <id>http://rqsir.github.io/</id>
  
  <author>
    <name>RQsir</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CommonIO总结</title>
    <link href="http://rqsir.github.io/2019/07/06/javase-CommonIO%E6%80%BB%E7%BB%93/"/>
    <id>http://rqsir.github.io/2019/07/06/javase-CommonIO总结/</id>
    <published>2019-07-06T15:51:12.000Z</published>
    <updated>2019-07-08T07:28:22.663Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作为J2SE中”三大核心”之一的IO操作，我们虽然在学习时可以忽略“重复造轮子”的禁忌；但在实际开发当中，还是应本着“业务第一，有轮子就用的”原则来指导我们的日常工作。</p></blockquote><h1 id="java代码的规模"><a href="#java代码的规模" class="headerlink" title="java代码的规模"></a>java代码的规模</h1><p>当我们刚开始接触java时，无一例外的会从其基本语法入手。这时，我们也会跟着教程写几个简单demo，看看效果，并因此而小激动一会。</p><p>随着学习的深入，我们会逐渐了解到我们平时练手的这些小代码块，编译后无非是一些<code>class</code>文件，它们的运行需要java虚拟机的加载与相关环境的支持。后来我们会接触到一些有用的工具包，它们一般是以<code>jar</code>压缩包的形式提供给我们；<code>jar</code>包中一般会包含一到多个<code>class</code>文件，换句话说，<code>jar</code>包将一些有用的、经过开发者实践的代码整合到了一起。照上述类推，许多的<code>jar</code>又一道构成了功能更强大的<code>component</code>组件（常见的如：我们接下来要谈到的<code>CommonIO</code>）；在此基础上又一次聚合，就得到了所谓的<code>framework</code>框架（如<code>Spring</code>、<code>Commons</code>等）。</p><pre class="mermaid">graph LR    id1(class文件)-->|组成|id2(jar包);    id2(jar包)-->|组成|id3(component组件);    id3(component组件)-->|组成|id4(framework框架);</pre><h1 id="下载与配置"><a href="#下载与配置" class="headerlink" title="下载与配置"></a>下载与配置</h1><pre class="mermaid">graph TB    id1["进入Apache官网Commons页面(http://commons.apache.org/)"]==>id2["进入CommonIO项目页(http://commons.apache.org/proper/commons-io/)"];    id2["进入CommonIO项目页(http://commons.apache.org/proper/commons-io/)"]==>id3["下载最新CommonsIO_jdk"];</pre><p>下载完CommonsIO_jar包后，我们只需按照相应IDE的<code>lib</code>引入方法，完成对<code>jar</code>包的引入设置。这里以idea为例，我们只需先进入project structure 面板，然后点击左侧的Libraries选项，最后点击添加按钮并添加想要的jar包。</p><h1 id="CommonsIO常用接口"><a href="#CommonsIO常用接口" class="headerlink" title="CommonsIO常用接口"></a>CommonsIO常用接口</h1><h2 id="文件及目录大小获取"><a href="#文件及目录大小获取" class="headerlink" title="文件及目录大小获取"></a>文件及目录大小获取</h2><p><em>获取文件大小</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法: <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">sizeOf</span><span class="params">(<span class="keyword">final</span> File file)</span></span>;</span><br><span class="line">调用形式: FileUtils.sizeOf(file);</span><br></pre></td></tr></table></figure><p><em>获取目录大小</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法:<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">sizeOfDirectory</span><span class="params">(<span class="keyword">final</span> File directory)</span></span>;</span><br><span class="line">调用形式: FileUtils.sizeOfDirectory(dir);</span><br></pre></td></tr></table></figure><h2 id="遍历及筛选目录"><a href="#遍历及筛选目录" class="headerlink" title="遍历及筛选目录"></a>遍历及筛选目录</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * 遍历指定目录的第一层子目录，过滤条件为：内容非空 */</span></span><br><span class="line">Collection&lt;File&gt; files = FileUtils.listFiles(<span class="keyword">new</span> File(<span class="string">"/home/rqsir/IdeaProjects/CommonIODemo"</span>), EmptyFileFilter.NOT_EMPTY,<span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">for</span> (File file:files ) &#123;    System.out.println(file.getAbsolutePath());&#125;</span><br><span class="line">System.out.println(<span class="string">"-------------------------------"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** * 遍历指定目录的所有子目录，过滤条件为：内容非空 */</span></span><br><span class="line">Collection&lt;File&gt; files1 = FileUtils.listFiles(<span class="keyword">new</span> File(<span class="string">"/home/rqsir/IdeaProjects/CommonIODemo"</span>), EmptyFileFilter.NOT_EMPTY, DirectoryFileFilter.INSTANCE);</span><br><span class="line"><span class="keyword">for</span> (File file:files1) &#123;    System.out.println(file.getAbsolutePath());&#125;</span><br><span class="line">System.out.println(<span class="string">"-------------------------------"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** * 遍历指定目录的所有子目录，过滤条件为：后缀为：java */</span></span><br><span class="line">Collection&lt;File&gt; files2 = FileUtils.listFiles(<span class="keyword">new</span> File(<span class="string">"/home/rqsir/IdeaProjects/CommonIODemo"</span>), <span class="keyword">new</span> SuffixFileFilter(<span class="string">"java"</span>), DirectoryFileFilter.INSTANCE);</span><br><span class="line"><span class="keyword">for</span> (File file:files2) &#123;    System.out.println(file.getAbsolutePath());&#125;</span><br><span class="line">System.out.println(<span class="string">"-------------------------------"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** * 遍历指定目录的所有子目录，过滤条件为：后缀为：java或者class */</span></span><br><span class="line">Collection&lt;File&gt; files3 = FileUtils.listFiles(<span class="keyword">new</span> File(<span class="string">"/home/rqsir/IdeaProjects/CommonIODemo"</span>), FileFilterUtils.or(<span class="keyword">new</span> SuffixFileFilter(<span class="string">"java"</span>),<span class="keyword">new</span> SuffixFileFilter(<span class="string">"class"</span>)), DirectoryFileFilter.INSTANCE);</span><br><span class="line"><span class="keyword">for</span> (File file:files3) &#123;    System.out.println(file.getAbsolutePath());&#125;</span><br><span class="line">System.out.println(<span class="string">"-------------------------------"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** * 遍历指定目录的所有子目录，过滤条件为：后缀为：java且不为空 */</span></span><br><span class="line">Collection&lt;File&gt; files4 = FileUtils.listFiles(<span class="keyword">new</span> File(<span class="string">"/home/rqsir/IdeaProjects/CommonIODemo"</span>), FileFilterUtils.and(<span class="keyword">new</span> SuffixFileFilter(<span class="string">"java"</span>),EmptyFileFilter.NOT_EMPTY), DirectoryFileFilter.INSTANCE);</span><br><span class="line"><span class="keyword">for</span> (File file:files4) &#123;    System.out.println(file.getAbsolutePath());&#125;</span><br></pre></td></tr></table></figure><h2 id="读取文件内容"><a href="#读取文件内容" class="headerlink" title="读取文件内容"></a>读取文件内容</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取文件内容方式一:(一次性读取)</span></span><br><span class="line">String content =  FileUtils.readFileToString(<span class="keyword">new</span> File(<span class="string">"a.txt"</span>),<span class="string">"utf8"</span>);</span><br><span class="line">System.out.println(content);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"------------------------------"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取文件内容方式二:(按行读取)</span></span><br><span class="line">List&lt;String&gt; lines =  FileUtils.readLines(<span class="keyword">new</span> File(<span class="string">"a.txt"</span>),<span class="string">"utf8"</span>);</span><br><span class="line"><span class="keyword">for</span> (String line:lines</span><br><span class="line">     ) &#123;</span><br><span class="line">    System.out.println(line);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"------------------------------"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取文件大小</span></span><br><span class="line"><span class="keyword">byte</span>[] bys = FileUtils.readFileToByteArray(<span class="keyword">new</span> File(<span class="string">"a.txt"</span>));</span><br><span class="line">System.out.println(<span class="string">"fileSize:"</span>+bys.length);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"------------------------------"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取文件内容方式三:(通过迭代器读取)</span></span><br><span class="line">LineIterator lineIterator = FileUtils.lineIterator(<span class="keyword">new</span> File(<span class="string">"a.txt"</span>),<span class="string">"utf8"</span>);</span><br><span class="line"><span class="keyword">while</span> (lineIterator.hasNext())&#123;</span><br><span class="line">    System.out.println(lineIterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="写文件操作"><a href="#写文件操作" class="headerlink" title="写文件操作"></a>写文件操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写字符串到文件</span></span><br><span class="line">FileUtils.write(<span class="keyword">new</span> File(<span class="string">"b.txt"</span>),<span class="string">"学习很伟大\n"</span>,<span class="string">"utf8"</span>,<span class="keyword">true</span>);</span><br><span class="line">FileUtils.writeStringToFile(<span class="keyword">new</span> File(<span class="string">"b.txt"</span>),<span class="string">"学习很辛苦\n"</span>,<span class="string">"utf8"</span>,<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//写字节数组到文件</span></span><br><span class="line">FileUtils.writeByteArrayToFile(<span class="keyword">new</span> File(<span class="string">"b.txt"</span>),<span class="string">"学习很幸福\n"</span>.getBytes(<span class="string">"utf8"</span>),<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//写String类型的线性表到文件</span></span><br><span class="line">List&lt;String&gt; lines = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">lines.add(<span class="string">"昨天"</span>);</span><br><span class="line">lines.add(<span class="string">"今天"</span>);</span><br><span class="line">lines.add(<span class="string">"明天"</span>);</span><br><span class="line">FileUtils.writeLines(<span class="keyword">new</span> File(<span class="string">"b.txt"</span>),<span class="string">"utf8"</span>,lines,<span class="string">"---&gt;"</span>,<span class="keyword">true</span>);<span class="comment">//"---&gt;"为每一行的分隔符</span></span><br></pre></td></tr></table></figure><p>拷贝操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//copy file</span></span><br><span class="line">FileUtils.copyFile(<span class="keyword">new</span> File(<span class="string">"avatar.jpg"</span>),<span class="keyword">new</span> File(<span class="string">"avatar_copy.jpg"</span>));</span><br><span class="line"><span class="comment">//copy file to directory</span></span><br><span class="line">FileUtils.copyFileToDirectory(<span class="keyword">new</span> File(<span class="string">"avatar.jpg"</span>),<span class="keyword">new</span> File(<span class="string">"out"</span>));</span><br><span class="line"><span class="comment">//copy dir</span></span><br><span class="line">FileUtils.copyDirectory(<span class="keyword">new</span> File(<span class="string">"out"</span>),<span class="keyword">new</span> File(<span class="string">"out_copy"</span>));</span><br><span class="line"><span class="comment">//copy dir to dir</span></span><br><span class="line">FileUtils.copyDirectoryToDirectory(<span class="keyword">new</span> File(<span class="string">"out"</span>),<span class="keyword">new</span> File(<span class="string">"outContainer"</span>));</span><br><span class="line"><span class="comment">//copy URL to file</span></span><br><span class="line">String url = <span class="string">"https://raw.githubusercontent.com/RQsir/blog_pic_bed/master/img/81a5cfb3ly1g279yehw2kj21hc0t8457.jpg?token=AKZRZC5LDP5TBBMWU5JBQ4K4YQIPI"</span>;</span><br><span class="line">FileUtils.copyURLToFile(<span class="keyword">new</span> URL(url),<span class="keyword">new</span> File(<span class="string">"JDK_debug.gif"</span>));</span><br><span class="line"><span class="comment">//copy URL to String</span></span><br><span class="line">String webPage = IOUtils.toString(<span class="keyword">new</span> URL(<span class="string">"http://www.baidu.com"</span>),<span class="string">"utf8"</span>);</span><br><span class="line">System.out.println(webPage);</span><br><span class="line">String webPage2 = IOUtils.toString(<span class="keyword">new</span> URL(<span class="string">"http://www.163.com"</span>),<span class="string">"gbk"</span>);</span><br><span class="line">System.out.println(webPage2);</span><br></pre></td></tr></table></figure><pre class="mermaid">sequenceDiagram    participant John    participant Alice    Alice->>John: Hello John, how are you?    John-->>Alice: Great!</pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;作为J2SE中”三大核心”之一的IO操作，我们虽然在学习时可以忽略“重复造轮子”的禁忌；但在实际开发当中，还是应本着“业务第一，有轮子就用的”原则来指导我们的日常工作。&lt;/p&gt;&lt;/blockquote&gt;&lt;h1 id=&quot;java代码的规模&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="java-se" scheme="http://rqsir.github.io/categories/java-se/"/>
    
    
      <category term="CommonIO" scheme="http://rqsir.github.io/tags/CommonIO/"/>
    
  </entry>
  
  <entry>
    <title>VirtualBox 网络模式总结</title>
    <link href="http://rqsir.github.io/2019/05/23/VirtualBox-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
    <id>http://rqsir.github.io/2019/05/23/VirtualBox-网络模式总结/</id>
    <published>2019-05-22T16:44:19.000Z</published>
    <updated>2019-05-22T17:08:41.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今天在装MySQL的过程中，突然想尝试一下通过VirtualBox虚拟机模拟远端服务器，为本地win10提供数据服务器访问业务。那问题来了，如何正确配置VirtualBox的网络设置，来实现win10主机与虚拟机互通互联的需求呢？</p></blockquote><h2 id="五种网络模式"><a href="#五种网络模式" class="headerlink" title="五种网络模式"></a>五种网络模式</h2><p>首先，让我们来看一下VirtualBox中的5中网络配置模式：</p><p><img src="https://raw.githubusercontent.com/RQsir/blog_pic_bed/master/img/DeepinScreenshot_select-area_20190523005309.png" alt></p><p>如上图所示，在VirtualBox中我们可能用到的就5种网络模式，下面对它们分别简介如下：</p><table><thead><tr><th style="text-align:center">网络模式</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">网络地址转换（NAT）</td><td style="text-align:center">NAT协议通过具有公网ip的host主机作为代理，<br>实现了无公网ip的guest虚拟机的互联网访问需求</td></tr><tr><td style="text-align:center">NAT网络</td><td style="text-align:center">本质上也是NAT，不同的是这种模式下不支持<br>host和guest主机之间的端口转发</td></tr><tr><td style="text-align:center">桥接网卡</td><td style="text-align:center">桥接有点类似物理设备中的交换机，<br>通过它，guest虚拟机可以和host主机在链路层互联，构成一个局域网；<br>这样的话，guest虚拟机由于加入了host主机所在的物理局域网会由DHCP自动分配到一个ip</td></tr><tr><td style="text-align:center">内部网络</td><td style="text-align:center">在这种模式下，VirtualBox会生成一个虚拟局域网供虚拟机集群使用；<br>虚拟机间可以相互通信，但host主机无法与虚拟机进行通信</td></tr><tr><td style="text-align:center">host-only模式</td><td style="text-align:center">guest虚拟机通过host上的虚拟网卡与host主机处于同一局域网中，<br>guest和host可以相互通信，但guest虚拟机无法访问外网</td></tr></tbody></table><h2 id="分类详解"><a href="#分类详解" class="headerlink" title="分类详解"></a>分类详解</h2><p>对于上述五种模式（除去内部网络外），我在win10和虚拟机中分别做了ping通测试，现记录如下：</p><h3 id="桥接网卡"><a href="#桥接网卡" class="headerlink" title="桥接网卡"></a>桥接网卡</h3><p>如上面表格总结的那样，在桥接模式下，guest虚拟机获得了和host一样的，位于同一局域物理网络中的独立的ip地址。</p><p>我们此时，可以将其视作一台真实的物理机，它与host地位对等。</p><p><img src="https://raw.githubusercontent.com/RQsir/blog_pic_bed/master/img/DeepinScreenshot_select-area_20190523010133.png" alt></p><p>在实际的测试过程当中，我发现自己笔记本的无线网卡似乎并不支持桥接模式下的混杂模式，具体表现是：guest虚拟机可以和host机相互ping通，但guest虚拟机却死活也ping不通外网。</p><p>通过多方搜索，我总算是在一篇博文中发现了这个问题，特地mark一下。简要步骤是：先在win10的设备管理器中添加一个<code>Microsoft KM-TEST 环回适配器</code>，然后将物理无线网卡的网络共享给该虚拟网络配适器，最后在VirtualBox网络桥接模式配置界面中找到<code>名称选择</code>选项，选择<code>Microsoft KM-TEST 环回适配器</code>就可以了。详情请参考<a href="https://jingyan.baidu.com/article/948f59242e601dd80ff5f929.html" target="_blank" rel="noopener">VirtualBox与笔记本无线网卡桥接</a></p><h3 id="NAT网络（不带端口转发）"><a href="#NAT网络（不带端口转发）" class="headerlink" title="NAT网络（不带端口转发）"></a>NAT网络（不带端口转发）</h3><p>NAT协议，最初是为了解决公网ip地址有限，但又必须让每台不具有公网ip的计算机实现上网目的这一问题而提出的。实现思路可以大致理解为：位于同一局域网中的无公网ip主机，通过一个具有公网ip的计算机去间接访问所需资源；这个具有公网ip的计算机在这里起到了一个代理的作用（这一点很类似我们今天的海外商品代购中心），它首先将这些无公网ip主机的请求进行转换（主要是将请求中的原ip地址换成自己的公网ip），然后再次转发给互联网中的目的主机；但收到回复后，它再按照NAT转换表进行转发回复，将响应最终发给每一个无公网ip主机。</p><p>根据这一思路，VirtualBox中使用NAT网络模式，guest虚拟机所在局域网中必然存在一个具有公网ip的代理主机。为验证这一理论，我在虚拟机中通过路由跟踪命令<code>traceroute</code>，成功发现了这个代理主机的身影，如下所示：</p><p><img src="https://raw.githubusercontent.com/RQsir/blog_pic_bed/master/img/DeepinScreenshot_select-area_20190523005941.png" alt></p><p>相关主机间的ping图如下：</p><p><img src="https://raw.githubusercontent.com/RQsir/blog_pic_bed/master/img/DeepinScreenshot_select-area_20190523010232.png" alt></p><h3 id="网络地址转换（NAT-带端口转发）"><a href="#网络地址转换（NAT-带端口转发）" class="headerlink" title="网络地址转换（NAT 带端口转发）"></a>网络地址转换（NAT 带端口转发）</h3><p>上面刚介绍了不带端口转发的NAT模式，通过相关的ping图我们不难发现，这种模式存在着很大缺陷：那便是Host主机无法访问Guest虚拟机。这样一来，我们希望的win10主机请求虚拟机中数据库服务器的初衷就泡汤了。</p><p>针对这种问题，VirtualBox特地为我们推出了带端口转发的NAT网络模式，相关设置描述如下：</p><p>首先我们进入VirtualBox的网络设置界面，如下所示</p><p>!<img src="https://raw.githubusercontent.com/RQsir/blog_pic_bed/master/img/DeepinScreenshot_select-area_20190523010532.png" alt></p><p>进入端口转发设置子界面</p><p><img src="https://raw.githubusercontent.com/RQsir/blog_pic_bed/master/img/DeepinScreenshot_select-area_20190523010616.png" alt></p><p>按照图示指南，完成相应设置后，点击确认即可。</p><p>这里，我们再来看看host主机与guest主机之间的相关ping通情况：</p><h3 id="host-only模式"><a href="#host-only模式" class="headerlink" title="host-only模式"></a><img src="https://raw.githubusercontent.com/RQsir/blog_pic_bed/master/img/DeepinScreenshot_select-area_20190523010700.png" alt>host-only模式</h3><p>这一网络模式下，默认仅允许guest虚拟机之间互相访问，不能连外网，没有配置DNS无法解析域名，无法ping通host主机。但另一方面，它也是VirtualBox网络配置中可玩性最高的一种模式，按理说只要是其他模式能够实现的功能，通过正确的配置，在这种模式下都能实现。</p><p>我们可以认为，VirtualBox默认为这一模式虚拟化出了一张网卡，用于连接所有的虚拟主机；我们可以通过对这块虚拟网卡手动设定ip，或者是桥接其他物理网卡、网络共享等操作，来达到我们想要的各种网络需求。</p><h2 id="方案确定"><a href="#方案确定" class="headerlink" title="方案确定"></a>方案确定</h2><p>通过上述分析，我大致确定了两套可行的方案：</p><ol><li>通过VirtualBox的网桥模式，使guest虚拟机获得与host主机同一局域网下的真实ip，进而达到host主机自由请求guest虚拟机上数据库服务的目的。</li><li>利用NAT端口转发模式，实现guest虚拟机访问外网的目标，同时host主机通过端口映射技术，可以最终请求到guest虚拟机上数据库的相关服务，完成数据库的远程调用。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;今天在装MySQL的过程中，突然想尝试一下通过VirtualBox虚拟机模拟远端服务器，为本地win10提供数据服务器访问业务。那问题来了，如何正确配置VirtualBox的网络设置，来实现win10主机与虚拟机互通互联的需求呢？&lt;/p&gt;&lt;/bloc
      
    
    </summary>
    
      <category term="虚拟机" scheme="http://rqsir.github.io/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="VirtualBox-网络模式" scheme="http://rqsir.github.io/tags/VirtualBox-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>java -- 变量相加和常量相加的区别</title>
    <link href="http://rqsir.github.io/2019/05/21/java-%E5%8F%98%E9%87%8F%E7%9B%B8%E5%8A%A0%E5%92%8C%E5%B8%B8%E9%87%8F%E7%9B%B8%E5%8A%A0%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://rqsir.github.io/2019/05/21/java-变量相加和常量相加的区别/</id>
    <published>2019-05-21T08:05:06.000Z</published>
    <updated>2019-05-26T07:58:25.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>偶然看到了一道有关java基本数据类型中变量相加和常量相加的面试题，觉得很有意思，先总结如下</p></blockquote><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b1=<span class="number">1</span>, b2=<span class="number">2</span>, b3, b4;</span><br><span class="line">b3 = b1 + b2;</span><br><span class="line">b4 = <span class="number">1</span> + <span class="number">2</span>;</span><br><span class="line"><span class="comment">//问哪一条语句会编程失败？</span></span><br></pre></td></tr></table></figure><p>题目咋一看，似乎很简单。两个数相加，不就是考虑数据类型是否一致，以及运算结果是否会溢出的问题吗？</p><p>照着这一思路，我首先判断第2行的代码应该是没有问题的，理由如下：（1）变量b1和b2都是byte类型变量；（2）b1+b2结果为3，没有超出byte的存储空间-128~127。</p><p>至于第3行代码，是两个常量相加，再将结果赋值给变量b4，应该也不存在编译问题。</p><h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>编译输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error(3):java: incompatible types: possible lossy conversion from int to byte</span><br></pre></td></tr></table></figure><p>第3行编译报错，第4行通过编译</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>初步断定是数据类型转换失败，因为<code>int</code>向<code>byte</code>转换时，会存在精度丢失的问题。</p><p>那么，这里的<code>int</code>数据又是哪里来的呢？难道<code>byte</code>类型的b1和b2相加，结果被自动转成了int？</p><p>带着这些疑问，我查阅了相关资料，发现原来在java中基本数据类型在进行运算时，普遍存在着所谓<strong>自动数据类型转化</strong>问题。之间的转化图可以总结如下：</p><p><img src="https://raw.githubusercontent.com/RQsir/blog_pic_bed/master/img/20190423163455987_QPFFYK.jpg" alt></p><p>其中红线表示可以在不丢失精度的情况下完成转化，而蓝线则意味着转化后可能会损失部分精度；不管怎样，图中所有转化，都是java编译器所允许的自动类型转换。</p><p>相关规则是：</p><ol><li><p>当byte、short、int、long、char等数据类型在一起运算，即只有整型数据参与运算时：无long型，所有非int类型转成int类型；有long类型，都转成long类型。</p></li><li><p>当float、double等数据类型一起运算，即只有浮点型数据参与运算时：一律转为double类型进行运算。</p></li><li><p>当所有数据类型混在一起运算，即整数和浮点数据类型同时存在时：一律转为double类型进行运算。</p></li></ol><p><u>另外还需要注意的是：整型数据的默认类型为int，浮点型则为double。一般数据运算都先转为默认数据类型，然后才开始运算；除非有更高级别的数据类型存在，比如规则1中存在long型，则都转为long（虽然默认数据类型是int）</u></p><p>再回到那道面试题，两个<code>byte</code>类型的变量进行加法运算，编译器在编译这行代码时会自动将其类型转换为整型默认数据类型<code>int</code>，这种现象也叫做java的<strong>自动类型提升</strong>。</p><h1 id="从反编译看数据类型转换"><a href="#从反编译看数据类型转换" class="headerlink" title="从反编译看数据类型转换"></a>从反编译看数据类型转换</h1><p>另外，借助反编译工具<code>procyon.jar</code>，我们可以从代码执行的底层进一步窥探到java数据类型转换的过程。由于<code>b3 = b1 + b2;</code>编译不通过，现将原始代码修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b1=<span class="number">1</span>, b2=<span class="number">2</span>, b3, b4;</span><br><span class="line"><span class="comment">//b3 = b1 + b2;</span></span><br><span class="line"><span class="keyword">int</span> i1 = b1 + b2;</span><br><span class="line">b4 = <span class="number">1</span> + <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>反编译如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">b1 : <span class="keyword">byte</span></span><br><span class="line">b2 : <span class="keyword">byte</span></span><br><span class="line">i1 : <span class="keyword">int</span></span><br><span class="line">b4 : <span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line">b1 = ldc:<span class="keyword">byte</span>(<span class="number">1</span>)</span><br><span class="line">b2 = ldc:<span class="keyword">byte</span>(<span class="number">2</span>)</span><br><span class="line">i1 = add:<span class="keyword">int</span>(b1:<span class="keyword">byte</span>, b2:<span class="keyword">byte</span>)</span><br><span class="line">b4 = ldc:<span class="keyword">byte</span>(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>从第8行，我们可以知道b1+b2，结果是以int类型保存的，故源码中我们企图将其运算结果赋值给b3会报数据类型不匹配的错误。</p><p>而1+2这个常量运算式，编译器是先将其结果计算出后，再根据其要被赋值的变量类型（这里被赋值的变量类型是byte），动态分配存储空间的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>变量相加：一般是先开辟内存空间（根据参与运算的变量类型决定，规则见上面的分析），然后进行相关操作。</p><p>常量相加：一般是编译器先帮我们算出结果，然后根据所要赋值的变量类型开辟相应内存空间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;偶然看到了一道有关java基本数据类型中变量相加和常量相加的面试题，觉得很有意思，先总结如下&lt;/p&gt;&lt;/blockquote&gt;&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目
      
    
    </summary>
    
      <category term="java-se" scheme="http://rqsir.github.io/categories/java-se/"/>
    
    
      <category term="java-变量相加和常量相加的区别" scheme="http://rqsir.github.io/tags/java-%E5%8F%98%E9%87%8F%E7%9B%B8%E5%8A%A0%E5%92%8C%E5%B8%B8%E9%87%8F%E7%9B%B8%E5%8A%A0%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>java -- IO流</title>
    <link href="http://rqsir.github.io/2019/05/14/java-IO%E6%B5%81/"/>
    <id>http://rqsir.github.io/2019/05/14/java-IO流/</id>
    <published>2019-05-13T16:00:00.000Z</published>
    <updated>2019-06-09T01:22:34.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>java中对于输入输出相关操作进行了抽象，统称为java的IO流操作。这里，我们在以往java文件读写操作（<code>FileWriter</code>和<code>FileReader</code>）基础上，进一步深入学习java的IO流概念。</p></blockquote><h2 id="IO流分类"><a href="#IO流分类" class="headerlink" title="IO流分类"></a>IO流分类</h2><p>根据不同的分类标准，我们可以对IO流进行不同的的划分。现暂以<strong>IO流向</strong>、<strong>IO操作数据类型</strong>和<strong>IO流功能</strong>这三个基准，来对IO流进行大致分类，如下：</p><p>按流向分</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">作用</th><th style="text-align:center">举例</th></tr></thead><tbody><tr><td style="text-align:center">输入流</td><td style="text-align:center">读取数据</td><td style="text-align:center">FileReader</td></tr><tr><td style="text-align:center">输出流</td><td style="text-align:center">写出数据</td><td style="text-align:center">FileWriter</td></tr></tbody></table><p>按数据类型分</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">作用</th><th style="text-align:center">举例</th></tr></thead><tbody><tr><td style="text-align:center">字节流</td><td style="text-align:center">以byte为单位读写</td><td style="text-align:center">InputStream OutputStream</td></tr><tr><td style="text-align:center">字符流</td><td style="text-align:center">以char为单位读写</td><td style="text-align:center">FileReader FileWriter</td></tr></tbody></table><p>按功能分（是否直接操作数据源）</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">说明</th><th style="text-align:center">举例</th></tr></thead><tbody><tr><td style="text-align:center">节点流</td><td style="text-align:center">可以直接从数据源或目的地读写数据</td><td style="text-align:center">FileReader<br>FileInputStream</td></tr><tr><td style="text-align:center">包装流</td><td style="text-align:center">不直接连接数据源或目的地，是其他流的封装，<br>目的是简化操作或提高效率</td><td style="text-align:center">InputStreamReader<br>PrintWriter</td></tr></tbody></table><h2 id="IO流读写操作"><a href="#IO流读写操作" class="headerlink" title="IO流读写操作"></a>IO流读写操作</h2><p>按照上面的IO流分类，我们也可以将IO流操作分为<strong>字节流操作</strong>和<strong>字符流操作</strong>，下面将分别进行介绍：</p><h3 id="字节流读写-–-二进制文件搬运工"><a href="#字节流读写-–-二进制文件搬运工" class="headerlink" title="字节流读写 – 二进制文件搬运工"></a>字节流读写 – 二进制文件搬运工</h3><p>计算机文件，本质上就是对一连串“0101XXX”等二进制数据的存储。正因为如此，一切文件（不管是视频、音频、图片，还是普通文本文件）都可以通过对底层二进制数据的读写，以实现特定的复制、修改操作。</p><p>这里以图片的复制操作为例，相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建FileInputStream对象和FileOutputStream对象</span></span><br><span class="line">FileInputstream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"hill.jpg"</span>);</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutStream(<span class="string">"hill_copy.jpg"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.通过字节数组进行复制</span></span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span>((len = fis.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">    fos.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.关闭InputStream和OutputStream，释放资源</span></span><br><span class="line">fis.close();</span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure><h3 id="字符流读写-–-文本文件好帮手"><a href="#字符流读写-–-文本文件好帮手" class="headerlink" title="字符流读写 – 文本文件好帮手"></a>字符流读写 – 文本文件好帮手</h3><p>特别的，除了像上面那样通过字节流完成读写外，文本文件还可以通过字符流的方式完成读写操作。</p><p>这是因为文本文件的二进制存储，都是以特定的的编码方式实现的（例如unicode编码）；这意味着当这些二进制数据被读入内存，并存入char型数组时，计算机可以正确地完成相应的编解码工作，不会发生数据丢失的状况。</p><p>而普通的二进制文件（比如一张图片），由于其二进制存储并未遵循字符编码规则；一旦其被读入内存，并存入字符数组时，计算机会依照相应的编码规则进行解码操作；这时候就会发生有些二进制bit被误当作编码的标志位而丢弃，造成了数据的损坏。</p><p>下面我们对字符的编解码进行相关总结：</p><h4 id="编码表"><a href="#编码表" class="headerlink" title="编码表"></a>编码表</h4><p>可以简单的理解为：一张字符与数值的映射表。根据这张表，计算机可以将内存中存储的数值所对应的字符进行渲染显示。</p><p>最早的编码表是<code>ASCII</code>，其只覆盖了阿拉伯数字、英文字母和一些常用符号，主要供英语使用；随后各国根据本国语言，相继推出了本国的编码表：例如中国的<code>GBK</code>。</p><p>由于各国编码表不一致，常常出现文件移动到不同编码的计算机后出现乱码现象，于是一种兼容所有编码规则的编码表<code>Unicode</code>出现了。最先推出<code>Unicode</code>编码时，是将2个字节作为每个字符的存储单元，但很快就不够用了；于是乎推出了用4个字节存储每个字符的规则，这种方案虽然解决了存储单元空间不足的问题，但也同时造成了存储空间的大量浪费（比如用4个字节去存储只占一个字节的字符）。</p><p>在这样背景下，一种可变单元存储空间的编码规则<code>UTF-8</code>出现了，它本质上还是<code>Unicode</code>，只不过改进了前者的存储规则。</p><p>另外我们还要提一下<code>ANSI</code>编码，它又叫本地编码表；和上面提到的编码不同，它并不是一种具体的编码规则，而是本地编码的代指。如果你的本地编码是<code>GBK</code>，那么<code>ANSI</code>就是<code>GBK</code>；如果你的本地编码是<code>UTF-8</code>，那么<code>ANSI</code>就是<code>UTF-8</code>。</p><h4 id="字符串编码"><a href="#字符串编码" class="headerlink" title="字符串编码"></a>字符串编码</h4><p>要保证字符串写入文件或打印到console时不乱码，基本思路是：<strong>编解码前后一致，包括字符集与字节长度</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以GBK编码写入数据到文件</span></span><br><span class="line">String str = <span class="string">"你好吗？"</span>;</span><br><span class="line"><span class="keyword">byte</span>[] bys = str.getBytes(<span class="string">"GBK"</span>);</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"a.txt"</span>); <span class="comment">//打开文件时必须以GBK编码打开，才能保证不出现乱码</span></span><br><span class="line">fos.write(bys);</span><br><span class="line">fos.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取文件中GBK编码数据，并打印到控制台</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"a.txt"</span>);</span><br><span class="line"><span class="keyword">byte</span>[] bys = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len = fis.read(bys);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(bys,<span class="number">0</span>,len,<span class="string">"GBK"</span>));<span class="comment">//必须以GBK编码进行解码操作，不然会出现乱码</span></span><br></pre></td></tr></table></figure><h4 id="字符流编码"><a href="#字符流编码" class="headerlink" title="字符流编码"></a>字符流编码</h4><p>字符流 = 字节流 + 编码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">"b.txt"</span>),<span class="string">"GBK"</span>);</span><br><span class="line"></span><br><span class="line">String s = <span class="string">"你好呀"</span>;</span><br><span class="line">osw.write(s);<span class="comment">//这里使用GBK对字符串进行了编码，转为字节流后，然后写入了文件中</span></span><br><span class="line"></span><br><span class="line">osw.close();</span><br></pre></td></tr></table></figure><p>相关文本文件操作详情可以参考之前的总结<a href="https://rqsir.github.io/2019/04/24/java-%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/">java – 文本文件读写</a></p><p>相关unicode等字符编码可以参考<a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="noopener">字符编码笔记：ASCII，Unicode 和 UTF-8</a></p><h2 id="常用IO流类介绍"><a href="#常用IO流类介绍" class="headerlink" title="常用IO流类介绍"></a>常用IO流类介绍</h2><h3 id="标准输入输出流"><a href="#标准输入输出流" class="headerlink" title="标准输入输出流"></a>标准输入输出流</h3><p>有关标准输入输出流，我们在之前的日常编码中经常用到，只不过没有引起我们的关注罢了。</p><p>诸如向控制台打印<code>System.out.println(&quot;xxxxx&quot;)</code>或者是键盘录入<code>new Scanner(System.in)</code>，我们都可以发现<code>Systemm</code>类的身影。事实上，<code>System</code>中的类字段<code>out</code>以及<code>in</code>就是我们要谈到的标准输出输入流对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The "standard" input stream. This stream is already</span></span><br><span class="line"><span class="comment">    * open and ready to supply input data. Typically this stream</span></span><br><span class="line"><span class="comment">    * corresponds to keyboard input or another input source specified by</span></span><br><span class="line"><span class="comment">    * the host environment or user.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> InputStream in = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The "standard" output stream. This stream is already</span></span><br><span class="line"><span class="comment">    * open and ready to accept output data. Typically this stream</span></span><br><span class="line"><span class="comment">    * corresponds to display output or another output destination</span></span><br><span class="line"><span class="comment">    * specified by the host environment or user.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * For simple stand-alone Java applications, a typical way to write</span></span><br><span class="line"><span class="comment">    * a line of output data is:</span></span><br><span class="line"><span class="comment">    * &lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment">    *     System.out.println(data)</span></span><br><span class="line"><span class="comment">    * &lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * See the &lt;code&gt;println&lt;/code&gt; methods in class &lt;code&gt;PrintStream&lt;/code&gt;.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>     java.io.PrintStream#println()</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>     java.io.PrintStream#println(boolean)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>     java.io.PrintStream#println(char)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>     java.io.PrintStream#println(char[])</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>     java.io.PrintStream#println(double)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>     java.io.PrintStream#println(float)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>     java.io.PrintStream#println(int)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>     java.io.PrintStream#println(long)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>     java.io.PrintStream#println(java.lang.Object)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>     java.io.PrintStream#println(java.lang.String)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> PrintStream out = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>相关JDK源码如上，不管是<code>in</code>还是<code>out</code>都是字节流对象；其中<code>in</code>用于读取键盘录入数据，而<code>out</code>用于向屏幕输出数据。</p><h3 id="OutputStreamWriter-amp-amp-InputStreamReader"><a href="#OutputStreamWriter-amp-amp-InputStreamReader" class="headerlink" title="OutputStreamWriter &amp;&amp; InputStreamReader"></a>OutputStreamWriter &amp;&amp; InputStreamReader</h3><p>由于标准输入输出流处理的都是字节流数据，而我们人类可以识别的只能是字符流数据；一旦我们打算将所谓的字符流数据打印到屏幕，或者是把键盘输入的字节流数据保存为文本文件时，都会不可避免地遇到数据流间相互转化的问题。</p><p>例如，我们打算将文本文件的字符流数据打印到console，可以采用如下的办法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//read file</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"a.txt"</span>));</span><br><span class="line"><span class="comment">//OutputStream</span></span><br><span class="line">OutputStream os = System.out;</span><br><span class="line"></span><br><span class="line">String line;</span><br><span class="line"><span class="keyword">while</span>((line = br.readLine()) != <span class="keyword">null</span>)&#123; <span class="comment">//read file content,and print to console</span></span><br><span class="line">    os.write(line.getBytes()); <span class="comment">//由于标准输出流对象只能接收字节流，必须得手动将字符流转为字节流</span></span><br><span class="line">    os.write(<span class="string">"\n"</span>.getBytes());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">br.close();</span><br><span class="line">os.close();</span><br></pre></td></tr></table></figure><p>以上方法的不便之处显而易见，这种手动的转换极容易被忽视，进而导致错误。</p><p>从这一痛点出发，java为我们引入了<code>OutputStreamWriter</code>类，帮助我们自动完成字符流向字节流的转换。使用<code>OutputStreamWriter</code>重写以上方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//read file</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"a.txt"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//print file</span></span><br><span class="line">BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(System.out));</span><br><span class="line"></span><br><span class="line">String line = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span>((line = br.readLine()) != <span class="keyword">null</span>)&#123; <span class="comment">//read file content,and print to console</span></span><br><span class="line">    bw.write(line);  <span class="comment">//同OutputStream相比，使用OutputStreamWriter我们只需传入想要打印的字符流对象，而完全不要操心字符流与字节流的转换问题</span></span><br><span class="line">    bw.newLine();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">br.close();</span><br><span class="line">bw.close();</span><br></pre></td></tr></table></figure><p>和将文本文件的字符流数据打印到console中类似，我们从键盘录入字节流数据并将其存储在文本文件当中，可以使用<code>InputStreamReader</code>完成字节流向字符流的自动转换。相关代码如下：</p><p>使用手动转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"a.txt"</span>);</span><br><span class="line">InputStream is = System.in;</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] bys = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">while</span> ((len=is.read(bys)) != -<span class="number">1</span>)&#123;</span><br><span class="line">    fw.write(<span class="keyword">new</span> String(bys,<span class="number">0</span>,len)); <span class="comment">//这里需要手动将键盘录入的字节流转化为字符流</span></span><br><span class="line">    fw.flush();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fw.close();</span><br><span class="line">is.close();</span><br></pre></td></tr></table></figure><p>使用<code>InputStreamReader</code>自动转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"a.txt"</span>));</span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line"></span><br><span class="line">String line;</span><br><span class="line"><span class="keyword">while</span> ((line=br.readLine()) != <span class="keyword">null</span>)&#123; <span class="comment">//这里直接通过readLine()读出了字符流，而字节流向字符流的转化由InputStreamReader内部完成</span></span><br><span class="line">    bw.write(line);</span><br><span class="line">    bw.newLine();</span><br><span class="line">    bw.flush();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bw.close();</span><br><span class="line">br.close();</span><br></pre></td></tr></table></figure><h3 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h3><p>打印流大体可以分为两类：字符打印流<code>PrintWriter</code>和字节打印流<code>PrintStream</code>。和其他IO流不同的是，打印流仅仅存在输出流类，没有对应的输入流类。</p><p>由于<code>PrintStream</code>就是我们之前一直谈到到的<code>System.out</code>，这里不再赘述。</p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>至于<code>PrintWriter</code>，它是一个字符流输出类。这里我们一起看一下它的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">PrintWriter</span><span class="params">(File file)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(file))),</span><br><span class="line">             <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">PrintWriter</span><span class="params">(File file, String csn)</span></span></span><br><span class="line"><span class="function">     <span class="keyword">throws</span> FileNotFoundException, UnsupportedEncodingException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(toCharset(csn), file);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PrintWriter</span><span class="params">(OutputStream out, <span class="keyword">boolean</span> autoFlush)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(out)), autoFlush);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// save print stream for error propagation</span></span><br><span class="line">        <span class="keyword">if</span> (out <span class="keyword">instanceof</span> java.io.PrintStream) &#123;</span><br><span class="line">            psOut = (PrintStream) out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">PrintWriter</span><span class="params">(OutputStream out, <span class="keyword">boolean</span> autoFlush)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(out)), autoFlush);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// save print stream for error propagation</span></span><br><span class="line">        <span class="keyword">if</span> (out <span class="keyword">instanceof</span> java.io.PrintStream) &#123;</span><br><span class="line">            psOut = (PrintStream) out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">PrintWriter</span><span class="params">(String fileName, String csn)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> FileNotFoundException, UnsupportedEncodingException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(toCharset(csn), <span class="keyword">new</span> File(fileName));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PrintWriter</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(fileName))),</span><br><span class="line">             <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PrintWriter</span><span class="params">(Writer out,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">boolean</span> autoFlush)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(out);</span><br><span class="line">        <span class="keyword">this</span>.out = out;</span><br><span class="line">        <span class="keyword">this</span>.autoFlush = autoFlush;</span><br><span class="line">        lineSeparator = java.security.AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> sun.security.action.GetPropertyAction(<span class="string">"line.separator"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">PrintWriter</span><span class="params">(Writer out,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">boolean</span> autoFlush)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(out);</span><br><span class="line">        <span class="keyword">this</span>.out = out;</span><br><span class="line">        <span class="keyword">this</span>.autoFlush = autoFlush;</span><br><span class="line">        lineSeparator = java.security.AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> sun.security.action.GetPropertyAction(<span class="string">"line.separator"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="title">PrintWriter</span><span class="params">(Charset charset, File file)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> FileNotFoundException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(file), charset)),</span><br><span class="line">             <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>PrintWriter</code>基本上都是有参构造函数，传入的参数有<code>File</code>对象、<code>Writer</code>字符输出流对象、以及<code>OutputStream</code>字节输出流对象。其中传入的<code>File</code>对象通过调用<code>new BufferedWriter(new OutputStreamWriter(new FileOutputStream(fileName))</code>，最终转为了<code>Writer</code>对象；而<code>OutputStream</code>字节输出流对象，通过<code>new BufferedWriter(new OutputStreamWriter(out))</code>也最终转为了<code>Writer</code>对象。</p><p>这里我们可以稍微总结一下：<code>PrintWriter</code>由于自身并不具备字符输出功能，因此是一个<strong>包装流</strong>，它内部通过调用<strong>基本流</strong><code>Writer</code>对象完成字符流IO操作。</p><h4 id="特有成员函数"><a href="#特有成员函数" class="headerlink" title="特有成员函数"></a>特有成员函数</h4><p>这里我们主要介绍一下<code>PrintWriter</code>有关<strong>自动换行</strong>和<strong>自动刷新</strong>的方法。相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PrintWriter pw = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> FileWriter(<span class="string">"a.txt"</span>),<span class="keyword">true</span>);</span><br><span class="line">pw.println(<span class="string">"how do u do?"</span>);</span><br></pre></td></tr></table></figure><p>如上所示，我们可以通过构造函数中的第二个boolean参数手动开启<strong>自动刷新</strong>功能。另外，同<code>System.out.println()</code>类似，<code>PrintWriter</code>同样可以使用<code>println()</code>实现输出换行的目的。</p><p><em>注意：即使手动开启了自动刷新，也并不是说<code>PrintWriter</code>中的所有方法调用时都有效果。JDK特别指出，只有当调用<code>print()</code>、<code>println()</code>以及<code>format()</code>方法时，才存在自动刷新效果</em></p><h4 id="利用PrintWriter进行文件复制"><a href="#利用PrintWriter进行文件复制" class="headerlink" title="利用PrintWriter进行文件复制"></a>利用PrintWriter进行文件复制</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PrintWriter pw = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> FileWriter(<span class="string">"dest.txt"</span>),<span class="keyword">true</span>);</span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"src.txt"</span>));</span><br><span class="line">String line;</span><br><span class="line"><span class="keyword">while</span> ((line=br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">pw.println(line);</span><br><span class="line">&#125;</span><br><span class="line">pw.close();</span><br><span class="line">br.close();</span><br></pre></td></tr></table></figure><h3 id="对象操作流"><a href="#对象操作流" class="headerlink" title="对象操作流"></a>对象操作流</h3><p>顾名思义，这是一个用于读写对象的IO流。按照惯例，我们同样可以将其分为两类：<strong>对象输入流<code>ObjectInputStream</code></strong>以及<strong>对象输出流<code>ObjectOutputStream</code></strong></p><p>下面对这两个类进行详细介绍：</p><table><thead><tr><th style="text-align:center">类名</th><th style="text-align:center">构造方法</th><th style="text-align:center">常用成员方法</th></tr></thead><tbody><tr><td style="text-align:center">ObjectOutputStream</td><td style="text-align:center">ObjectOutputStream(OutputStream out)</td><td style="text-align:center">void writeObject(Object obj)</td></tr><tr><td style="text-align:center">ObjectInputStream</td><td style="text-align:center">ObjectInputStream(InputStream in)</td><td style="text-align:center">Object readObject()</td></tr></tbody></table><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>需要指出的是，我们在使用对象操作流进行对象读写时，需要注意对象所在类是否实现了<code>Serializable</code>接口，不然会报<code>java.io.NotSerializableException</code>。</p><p>除此之外，我们在对象类中还需手动指定序列化ID<code>serialVersionUID</code>，以防止读取已经保存的对象流文件时，由于对象所属类的修改，产生的文件中保存的序列化ID和类中自动计算的序列化ID不一致的异常。这种情况下，通常会报<code>java.io.InvalidClassException xxxxxx local class incompatible</code>等异常。</p><p>比较稳妥的写法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectOutputStream</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream((<span class="keyword">new</span> FileOutputStream(<span class="string">"a.txt"</span>)));</span><br><span class="line"></span><br><span class="line">        Student stu = <span class="keyword">new</span> Student(<span class="string">"ZhangSan"</span>,<span class="number">19</span>);</span><br><span class="line">        Student stu2 = <span class="keyword">new</span> Student(<span class="string">"LiSi"</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        oos.writeObject(stu);</span><br><span class="line">        oos.writeObject(stu2);</span><br><span class="line"></span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123; <span class="comment">//要操作的对象流所在类需要实现Serializable接口</span></span><br><span class="line">    <span class="comment">//这里手动指定了类的序列化IDenumerate</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">480241723845934527L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">", gender='"</span> + gender + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后还需注意的是：我们在上面代码中用对象操作流输出了两个对象到文件中，但当我们需要从文件中读取这些对象时，很自然的会遇到需要确定读取对象个数的问题。比如下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"a.txt"</span>));</span><br><span class="line"></span><br><span class="line">Object o = ois.readObject();</span><br><span class="line">System.out.println(o);</span><br><span class="line">Object o2 = ois.readObject();</span><br><span class="line">System.out.println(o2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Exception in thread "main" java.io.EOFException</span></span><br><span class="line">Object o3 = ois.readObject();</span><br><span class="line">System.out.println(o3);</span><br><span class="line"></span><br><span class="line">ois.close();</span><br></pre></td></tr></table></figure><p>在执行到<code>Object o3 = ois.readObject()</code>，会抛出异常<code>java.io.EOFException</code>，原因是此时文件已经读到尾了。和之前读取文件中的字符或字节流不同的是，之前一旦读到文件末尾我们可以通过返回<code>-1</code>的方式获知情况并终止读取操作；而在读取对象输出流文件中却没有这种机制，我们只能通过捕获异常手动处理方式来解决。</p><p>事实上，像这种读取多对象输出流文件的问题，我们可以考虑用一个集合存储多个对象，再将集合以对象流的形式写入文件；这样一来，在读取文件时就不用关系读取对象个数的问题了。本着这个思想，将上述代码重构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream((<span class="keyword">new</span> FileOutputStream(<span class="string">"b.txt"</span>)));</span><br><span class="line">ArrayList&lt;Student&gt; stus = <span class="keyword">new</span> ArrayList&lt;Student&gt;();</span><br><span class="line">stus.add(<span class="keyword">new</span> Student(<span class="string">"WangWu"</span>,<span class="number">30</span>));</span><br><span class="line">stus.add(<span class="keyword">new</span> Student(<span class="string">"ZhaoLiu"</span>,<span class="number">23</span>));</span><br><span class="line">oos.writeObject(stus);</span><br><span class="line">oos.close();</span><br><span class="line"></span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"b.txt"</span>));</span><br><span class="line">Object obj = ois.readObject();</span><br><span class="line">System.out.println(obj);</span><br><span class="line">ois.close();</span><br></pre></td></tr></table></figure><h3 id="Properties-–-配置文件读写能手"><a href="#Properties-–-配置文件读写能手" class="headerlink" title="Properties – 配置文件读写能手"></a>Properties – 配置文件读写能手</h3><p>一种特殊的双列集合，实现了<code>Map</code>接口，继承了<code>Hashtable</code>。不同于<code>HashMap</code>，<code>Properties</code>中的键值对都为<code>String</code>类型。</p><p>另外，由于<code>Properties</code>实现了属性集的持久化，故又称之为属性列表。</p><h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates an empty property list with no default values.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Properties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(<span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates an empty property list with the specified defaults.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>   defaults   the defaults.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Properties</span><span class="params">(Properties defaults)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.defaults = defaults;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>如上，<code>Properties</code>提供了两个构造方法；空参的构造方法用于实例化一个空的属性列表，有参的构造方法可以生成一个指定默认值的属性列表。</p><h4 id="常用成员方法"><a href="#常用成员方法" class="headerlink" title="常用成员方法"></a>常用成员方法</h4><p>由于<code>Properties</code>实现了<code>Map</code>接口，理论上<code>Map</code>的方法其都可以调用。例如增加属性，我们可以使用<code>put(key,value)</code>；删除属性，则可以使用<code>remove(key)</code>。</p><p>但<code>Properties</code>类的官方注释并不推荐我们这么做，理由是使用<code>Map</code>接口的<code>put(key,value)</code>方法可以增加非字符串的属性行，这将导致<code>Properties</code>中<code>store</code>he<code>sava</code>方法的调用失败。</p><p>这里我们将<code>Properties</code>中的常用方法总结如下：</p><table><thead><tr><th style="text-align:center">方法名</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">Object setProperty(String key, String value)</td><td style="text-align:center">新增Properties属性行</td></tr><tr><td style="text-align:center">getProperty(String key)</td><td style="text-align:center">查询指定key的属性值</td></tr><tr><td style="text-align:center">String getProperty(String key, String defaultValue)</td><td style="text-align:center">查询指定key的属性值，没有则返回默认值</td></tr></tbody></table><p>另外，日常工作中我们会经常使用<code>Properties</code>来进行属性文件的读写，因此特将<code>Properties</code>的IO操作总结如下：</p><p>使用<code>Properties</code>中的<code>void list(PrintWriter out)</code>或<code>void store(Writer writer, String comments)</code>将属性写入文本文件：</p><p>​ 使用<code>list()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">prop.setProperty(<span class="string">"001"</span>,<span class="string">"LiSi"</span>);</span><br><span class="line">prop.setProperty(<span class="string">"002"</span>,<span class="string">"ZhangSan"</span>);</span><br><span class="line">prop.setProperty(<span class="string">"003"</span>,<span class="string">"ZhaoSi"</span>);</span><br><span class="line">System.out.println(prop);</span><br><span class="line"></span><br><span class="line">PrintWriter pw = <span class="keyword">new</span> PrintWriter(<span class="string">"a.txt"</span>);</span><br><span class="line">prop.list(pw);</span><br><span class="line">pw.close();</span><br></pre></td></tr></table></figure><p>​ 使用<code>store()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">prop.setProperty(<span class="string">"001"</span>,<span class="string">"ZhangSan"</span>);</span><br><span class="line">prop.setProperty(<span class="string">"002"</span>,<span class="string">"LiSi"</span>);</span><br><span class="line">prop.setProperty(<span class="string">"003"</span>,<span class="string">"WangWu"</span>);</span><br><span class="line">prop.setProperty(<span class="string">"004"</span>,<span class="string">"ZhaoLiu"</span>);</span><br><span class="line">System.out.println(prop);</span><br><span class="line"></span><br><span class="line">OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">"b.txt"</span>));</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"c.txt"</span>);</span><br><span class="line">PrintStream ps = System.out;</span><br><span class="line"></span><br><span class="line">prop.store(osw,<span class="keyword">null</span>);</span><br><span class="line">prop.store(fos,<span class="keyword">null</span>);</span><br><span class="line">prop.store(ps,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">osw.close();</span><br><span class="line">fos.close();</span><br><span class="line">ps.close();</span><br></pre></td></tr></table></figure><p>使用<code>Properties</code>中的<code>void load(Reader reader)</code>从文件中读取属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"a.txt"</span>);</span><br><span class="line">prop.load(fr);</span><br><span class="line">fr.close();</span><br><span class="line">System.out.println(prop);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;java中对于输入输出相关操作进行了抽象，统称为java的IO流操作。这里，我们在以往java文件读写操作（&lt;code&gt;FileWriter&lt;/code&gt;和&lt;code&gt;FileReader&lt;/code&gt;）基础上，进一步深入学习java的IO流概念。&lt;
      
    
    </summary>
    
      <category term="java-se" scheme="http://rqsir.github.io/categories/java-se/"/>
    
    
      <category term="java - IO" scheme="http://rqsir.github.io/tags/java-IO/"/>
    
  </entry>
  
  <entry>
    <title>java中的常用数据结构</title>
    <link href="http://rqsir.github.io/2019/05/14/java%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://rqsir.github.io/2019/05/14/java中的常用数据结构/</id>
    <published>2019-05-13T16:00:00.000Z</published>
    <updated>2019-05-21T04:10:45.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>java中为我们提供了很多实用的数据结构，常用的大体上分为两大类：根类为<code>AbstractCollection</code>的单集合容器，以及根类为<code>AbstractMap&lt;K，V&gt;</code>的双集合容器。</p><p>我们一般本着从最顶层（顶层包含该数据结构的所有公共方法和字段）开始学习，从最底层（顶层包含数据结构的具体实现和特有方法）开始使用的原则，来总结以上两大数据容器。</p></blockquote><h2 id="AbstractCollection-–-单集合容器"><a href="#AbstractCollection-–-单集合容器" class="headerlink" title="AbstractCollection – 单集合容器"></a>AbstractCollection – 单集合容器</h2><p><img src="https://raw.githubusercontent.com/RQsir/blog_pic_bed/master/img/DeepinScreenshot_select-area_20190505162421.png" alt></p><p>如上图所示：<code>AbstractCollection</code>这个抽象类实际上实现了对应接口<code>Collection</code>，在<code>Collection</code>中定义了所有单集合容器都应具有的特性。</p><p>首先我们一起看一下<code>Collection</code>接口的JDK注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* The root <span class="class"><span class="keyword">interface</span> <span class="title">in</span> <span class="title">the</span> &lt;<span class="title">i</span>&gt;<span class="title">collection</span> <span class="title">hierarchy</span>&lt;/<span class="title">i</span>&gt;.  <span class="title">A</span> <span class="title">collection</span></span></span><br><span class="line"><span class="class">* <span class="title">represents</span> <span class="title">a</span> <span class="title">group</span> <span class="title">of</span> <span class="title">objects</span>, <span class="title">known</span> <span class="title">as</span> <span class="title">its</span> &lt;<span class="title">i</span>&gt;<span class="title">elements</span>&lt;/<span class="title">i</span>&gt;.  <span class="title">Some</span></span></span><br><span class="line"><span class="class">* <span class="title">collections</span> <span class="title">allow</span> <span class="title">duplicate</span> <span class="title">elements</span> <span class="title">and</span> <span class="title">others</span> <span class="title">do</span> <span class="title">not</span>.  <span class="title">Some</span> <span class="title">are</span> <span class="title">ordered</span></span></span><br><span class="line"><span class="class">* <span class="title">and</span> <span class="title">others</span> <span class="title">unordered</span>.  <span class="title">The</span> <span class="title">JDK</span> <span class="title">does</span> <span class="title">not</span> <span class="title">provide</span> <span class="title">any</span> &lt;<span class="title">i</span>&gt;<span class="title">direct</span>&lt;/<span class="title">i</span>&gt;</span></span><br><span class="line">* implementations of this interface: it provides implementations of more</span><br><span class="line">* specific subinterfaces like &lt;tt&gt;Set&lt;/tt&gt; and &lt;tt&gt;List&lt;/tt&gt;.  This interface</span><br><span class="line">* is typically used to pass collections around and manipulate them where</span><br><span class="line">* maximum generality is desired.</span><br></pre></td></tr></table></figure><p>从中，我们可以总结出<code>Collection</code>的几大特点：</p><ul><li>子类中既存在允许重复值（如<code>LinkedList</code>、<code>ArrayList</code>），也存在不允许重复值（如<code>HashSet</code>）</li><li>子类中既存在有序的（如<code>LinkedList</code>、<code>ArrayList</code>），也存在无序的（如<code>HashSet</code>）</li><li>子类中既存在不包含index的（如<code>HashSet</code>），也存在包含index的（如<code>LinkedList</code>、<code>ArrayList</code>）</li></ul><p>对应<code>Collection</code>的一些共有的抽象方法，如下图所示：</p><p><img src="https://raw.githubusercontent.com/RQsir/blog_pic_bed/master/img/DeepinScreenshot_select-area_20190505164436111.png" alt></p><p>其中<code>Collection</code>的增、删,分别对应着<code>add(E element)</code>、<code>remove(Object)</code>、<code>clear()</code>（清空集合）</p><p>另外，<strong>集合的遍历</strong>涉及到的两个函数<code>toArray()</code>以及<code>iterator()</code>，我们需重点掌握。</p><p><strong>使用<code>toArray()</code>遍历集合</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用了向上多态转型</span></span><br><span class="line">Collection c = <span class="keyword">new</span> ArrayList(); </span><br><span class="line">c.add(<span class="string">"I"</span>);</span><br><span class="line">c.add(<span class="string">"love"</span>);</span><br><span class="line">c.add(<span class="string">"java"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用数组遍历集合，使用toArray()函数</span></span><br><span class="line">Object[] arr = c.toArray();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用迭代器<code>Iterator</code>遍历集合</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用了向上多态转型</span></span><br><span class="line">Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line">c.add(<span class="string">"I"</span>);</span><br><span class="line">c.add(<span class="string">"love"</span>);</span><br><span class="line">c.add(<span class="string">"java"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用迭代器遍历集合，使用iterator()函数</span></span><br><span class="line">Iterator it = c.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    System.out.println(it.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注意：使用迭代器时不要对原集合进行操作，否则会出现<a href>并发修改异常</a></em></p><h3 id="Collection子类精讲"><a href="#Collection子类精讲" class="headerlink" title="Collection子类精讲"></a>Collection子类精讲</h3><p>说完了Collection父类的的共有特性和通用操作，现在聊聊其具体子类的一些独有特点。通过继承关系图，我们可以知道Collection可以分为四类：Queue、Deque、List和Set。下面我们主要谈谈List和Set：</p><h3 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h3><p>先来一段JDK说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">* <span class="function">An ordered <span class="title">collection</span> <span class="params">(also known as a &lt;i&gt;sequence&lt;/i&gt;)</span>.  The user of <span class="keyword">this</span></span></span><br><span class="line"><span class="function">* interface has precise control over where in the list each element is</span></span><br><span class="line"><span class="function">* inserted.  The user can access elements by their integer <span class="title">index</span> <span class="params">(position in</span></span></span><br><span class="line"><span class="function"><span class="params">* the list)</span>, and search <span class="keyword">for</span> elements in the list.&lt;p&gt;</span></span><br><span class="line"><span class="function">*</span></span><br><span class="line"><span class="function">* Unlike sets, lists typically allow duplicate elements.  More formally,</span></span><br><span class="line"><span class="function">* lists typically allow pairs of elements &lt;tt&gt;e1&lt;/tt&gt; and &lt;tt&gt;e2&lt;/tt&gt;</span></span><br><span class="line"><span class="function">* such that &lt;tt&gt;e1.<span class="title">equals</span><span class="params">(e2)</span>&lt;/tt&gt;, and they typically allow multiple</span></span><br><span class="line"><span class="function">* <span class="keyword">null</span> elements <span class="keyword">if</span> they allow <span class="keyword">null</span> elements at all.  It is not inconceivable</span></span><br><span class="line"><span class="function">* that someone might wish to implement a list that prohibits duplicates, by</span></span><br><span class="line"><span class="function">* throwing runtime exceptions when the user attempts to insert them, but we</span></span><br><span class="line"><span class="function">* expect <span class="keyword">this</span> usage to be rare.&lt;p&gt;</span></span><br></pre></td></tr></table></figure><p>其特点可以用如下关键词形容：<strong>有序</strong>、<strong>存在索引</strong>、<strong>允许重复</strong></p><p>常用方法有<code>add(int index, E element)</code>、<code>remove(int index)</code>、<code>set(int index, E element)</code>、<code>get(int index)</code>，这些是不同于<code>Collection</code>，<code>List</code>所特有的方法。</p><h4 id="LinkList和ArrayList之大比拼"><a href="#LinkList和ArrayList之大比拼" class="headerlink" title="LinkList和ArrayList之大比拼"></a>LinkList和ArrayList之大比拼</h4><p>在父接口List下，我们接触最多的就是<code>LinkList</code>和<code>ArrayList</code>了。下表是对它们的总结：</p><table><thead><tr><th style="text-align:center">类名</th><th style="text-align:center">特点</th><th style="text-align:center">特有方法</th></tr></thead><tbody><tr><td style="text-align:center">ArrayList</td><td style="text-align:center">底层用可变数组对List进行了实现<br>按index查找很快–O(1)<br>但按值进行查找速度很慢–O(n)<br>修改元素–O(1)<br>删除涉及到数组的移位，也很慢–O(n)<br>尾部添加元素，需要扩大数组–O(n)<br>指定位置添加，需要移动其他元素–O(n)</td><td style="text-align:center">没有，方法基本和List一样</td></tr><tr><td style="text-align:center">LinkedList</td><td style="text-align:center">底层用双向链表实现<br>按index查找不能像数组那样，还是得一个节点一个节点遍历–O(n)<br>按值查找同上–O(n)<br>修改元素和删除很快–O(1)<br>尾部添加元素–O(1)<br>指定位置添加元素–O(1)</td><td style="text-align:center">addFirst(E e)<br>addLast(E e)<br>getFirst( )<br>getLast( )<br>removeFirst( )<br>removeLast( )</td></tr></tbody></table><p>使用指南：</p><ul><li>如果业务查询多，添加和删除少，优先考虑<code>ArrayList</code></li><li>如果业务添加和删除多，查询少，优先考虑<code>LinkedList</code></li><li>一般情况，使用ArrayList就可以了</li></ul><h3 id="set接口"><a href="#set接口" class="headerlink" title="set接口"></a>set接口</h3><p>首先看一下其JDK注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* A collection that contains no duplicate elements.  More formally, sets</span><br><span class="line">* contain no pair of elements &lt;code&gt;e1&lt;/code&gt; and &lt;code&gt;e2&lt;/code&gt; such that</span><br><span class="line">* &lt;code&gt;e1.equals(e2)&lt;/code&gt;, and at most one null element.  As implied by</span><br><span class="line">* its name, <span class="keyword">this</span> <span class="class"><span class="keyword">interface</span> <span class="title">models</span> <span class="title">the</span> <span class="title">mathematical</span> &lt;<span class="title">i</span>&gt;<span class="title">set</span>&lt;/<span class="title">i</span>&gt; <span class="title">abstraction</span>.</span></span><br></pre></td></tr></table></figure><p>set的概念和数学上集合的概念基本一致，即：<strong>无序</strong>、<strong>无重复</strong>、<strong>无索引</strong></p><p>其常用方法和<code>Collection</code>一样：<code>add(E element)</code>、<code>remove(Object)</code>和<code>clear()</code></p><h4 id="HashSet-–-存储自定义对象"><a href="#HashSet-–-存储自定义对象" class="headerlink" title="HashSet – 存储自定义对象"></a>HashSet – 存储自定义对象</h4><p>先看一下JDK中对其的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* This <span class="class"><span class="keyword">class</span> <span class="keyword">implements</span> <span class="title">the</span> &lt;<span class="title">tt</span>&gt;<span class="title">Set</span>&lt;/<span class="title">tt</span>&gt; <span class="title">interface</span>, <span class="title">backed</span> <span class="title">by</span> <span class="title">a</span> <span class="title">hash</span> <span class="title">table</span></span></span><br><span class="line"><span class="class">* (<span class="title">actually</span> <span class="title">a</span> &lt;<span class="title">tt</span>&gt;<span class="title">HashMap</span>&lt;/<span class="title">tt</span>&gt; <span class="title">instance</span>).  <span class="title">It</span> <span class="title">makes</span> <span class="title">no</span> <span class="title">guarantees</span> <span class="title">as</span> <span class="title">to</span> <span class="title">the</span></span></span><br><span class="line"><span class="class">* <span class="title">iteration</span> <span class="title">order</span> <span class="title">of</span> <span class="title">the</span> <span class="title">set</span></span>; in particular, it does not guarantee that the</span><br><span class="line">* order will remain constant over time.  This <span class="class"><span class="keyword">class</span> <span class="title">permits</span> <span class="title">the</span> &lt;<span class="title">tt</span>&gt;<span class="title">null</span>&lt;/<span class="title">tt</span>&gt;</span></span><br><span class="line"><span class="class">* <span class="title">element</span>.</span></span><br></pre></td></tr></table></figure><p>从以上注释可知，<code>HaseSet</code>的底层是由<code>HashMap</code>实现的。这里我们可以看一下其源码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    * Adds the specified element to <span class="keyword">this</span> set <span class="keyword">if</span> it is not already present.</span><br><span class="line">    * More formally, adds the specified element &lt;tt&gt;e&lt;/tt&gt; to this set if</span><br><span class="line">    * this set contains no element &lt;tt&gt;e2&lt;/tt&gt; such that</span><br><span class="line">    * &lt;tt&gt;(e==null&amp;nbsp;?&amp;nbsp;e2==null&amp;nbsp;:&amp;nbsp;e.equals(e2))&lt;/tt&gt;.</span><br><span class="line">    * If <span class="keyword">this</span> set already contains the element, the call leaves the set</span><br><span class="line">    * unchanged and returns &lt;tt&gt;false&lt;/tt&gt;.</span><br><span class="line">    *</span><br><span class="line">    * <span class="meta">@param</span> e element to be added to <span class="keyword">this</span> set</span><br><span class="line">    * @return &lt;tt&gt;true&lt;/tt&gt; if this set did not already contain the specified</span><br><span class="line">    * element</span><br><span class="line">    *</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>; <span class="comment">//这里调用了成员变量map的put方法</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"><span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><h2 id="AbstractMap-–-双集合容器"><a href="#AbstractMap-–-双集合容器" class="headerlink" title="AbstractMap – 双集合容器"></a>AbstractMap – 双集合容器</h2><p><img src="https://raw.githubusercontent.com/RQsir/blog_pic_bed/master/img/DeepinScreenshot_select-area_20190505162437.png" alt></p><p>如图，<code>AbstractMap</code>是相对于<code>AbstractCollection</code>而言，又一抽象数据结构的顶层父类。不同于<code>AbstractCollection</code>单集合特点，在<code>AbstractMap</code>结构中存在着两个集合，且维护着这两个集合之间的对应关系。</p><p>先看一段JDK注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">* An object that maps keys to values.  A map cannot contain duplicate keys;</span><br><span class="line">* each key can map to at most one value.</span><br><span class="line">*</span><br><span class="line">* &lt;p&gt;This <span class="class"><span class="keyword">interface</span> <span class="title">takes</span> <span class="title">the</span> <span class="title">place</span> <span class="title">of</span> <span class="title">the</span> &lt;<span class="title">tt</span>&gt;<span class="title">Dictionary</span>&lt;/<span class="title">tt</span>&gt; <span class="title">class</span>, <span class="title">which</span></span></span><br><span class="line"><span class="class">* <span class="title">was</span> <span class="title">a</span> <span class="title">totally</span> <span class="title">abstract</span> <span class="title">class</span> <span class="title">rather</span> <span class="title">than</span> <span class="title">an</span> <span class="title">interface</span>.</span></span><br><span class="line"><span class="class">*</span></span><br><span class="line"><span class="class">* &lt;<span class="title">p</span>&gt;<span class="title">The</span> &lt;<span class="title">tt</span>&gt;<span class="title">Map</span>&lt;/<span class="title">tt</span>&gt; <span class="title">interface</span> <span class="title">provides</span> <span class="title">three</span> &lt;<span class="title">i</span>&gt;<span class="title">collection</span> <span class="title">views</span>&lt;/<span class="title">i</span>&gt;, <span class="title">which</span></span></span><br><span class="line"><span class="class">* <span class="title">allow</span> <span class="title">a</span> <span class="title">map</span>'<span class="title">s</span> <span class="title">contents</span> <span class="title">to</span> <span class="title">be</span> <span class="title">viewed</span> <span class="title">as</span> <span class="title">a</span> <span class="title">set</span> <span class="title">of</span> <span class="title">keys</span>, <span class="title">collection</span> <span class="title">of</span> <span class="title">values</span>,</span></span><br><span class="line"><span class="class">* <span class="title">or</span> <span class="title">set</span> <span class="title">of</span> <span class="title">key</span>-<span class="title">value</span> <span class="title">mappings</span>.  <span class="title">The</span> &lt;<span class="title">i</span>&gt;<span class="title">order</span>&lt;/<span class="title">i</span>&gt; <span class="title">of</span> <span class="title">a</span> <span class="title">map</span> <span class="title">is</span> <span class="title">defined</span> <span class="title">as</span></span></span><br><span class="line"><span class="class">* <span class="title">the</span> <span class="title">order</span> <span class="title">in</span> <span class="title">which</span> <span class="title">the</span> <span class="title">iterators</span> <span class="title">on</span> <span class="title">the</span> <span class="title">map</span>'<span class="title">s</span> <span class="title">collection</span> <span class="title">views</span> <span class="title">return</span> <span class="title">their</span></span></span><br><span class="line"><span class="class">* <span class="title">elements</span>.  <span class="title">Some</span> <span class="title">map</span> <span class="title">implementations</span>, <span class="title">like</span> <span class="title">the</span> &lt;<span class="title">tt</span>&gt;<span class="title">TreeMap</span>&lt;/<span class="title">tt</span>&gt; <span class="title">class</span>, <span class="title">make</span></span></span><br><span class="line">* specific guarantees as to their order; others, like the &lt;tt&gt;HashMap&lt;/tt&gt;</span><br><span class="line">* <span class="class"><span class="keyword">class</span>, <span class="title">do</span> <span class="title">not</span>.</span></span><br></pre></td></tr></table></figure><p>从中，我们可以总结<code>Map</code>的几大特点：<strong>keys –&gt;value映射</strong>、<strong>key是set</strong>、<strong>value是Collection</strong></p><p>Map中常用方法有：</p><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">void clear()</td><td style="text-align:center">清空map</td></tr><tr><td style="text-align:center">Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()</td><td style="text-align:center">返回map中键值对集合</td></tr><tr><td style="text-align:center">boolean equals(Object o)</td><td style="text-align:center">比较两个map是否相等</td></tr><tr><td style="text-align:center">int hashCode()</td><td style="text-align:center">计算map的hash值</td></tr><tr><td style="text-align:center">V get(Object key)</td><td style="text-align:center">根据key获取map中value</td></tr><tr><td style="text-align:center">V put(K key, V value)</td><td style="text-align:center">map中添加key-value对</td></tr><tr><td style="text-align:center">V remove(Object key)</td><td style="text-align:center">根据key移除键值对</td></tr><tr><td style="text-align:center">Set<k>keySet()</k></td><td style="text-align:center">获取map所有的key</td></tr><tr><td style="text-align:center">Collection<v>values()</v></td><td style="text-align:center">获取map所有的value</td></tr><tr><td style="text-align:center">Set&lt;Entry&lt;K,V&gt;&gt; entrySet()</td><td style="text-align:center">获取键值对集合</td></tr></tbody></table><p>Map内部接口Entry&lt;K,V&gt;中常用方法：</p><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">K getKey()</td><td style="text-align:center">获取键值对中的key</td></tr><tr><td style="text-align:center">V getValue()</td><td style="text-align:center">获取键值对中value</td></tr><tr><td style="text-align:center">V setValue(V value)</td><td style="text-align:center">设置键值对中的value</td></tr><tr><td style="text-align:center">boolean equals(Object o)</td><td style="text-align:center">比较两个键值对是否相等</td></tr><tr><td style="text-align:center">int hashCode()</td><td style="text-align:center">返回键值对的hash值</td></tr></tbody></table><p>同上，map的遍历我们也有两种方法：</p><p><strong>使用<code>keySet()</code>和<code>get(Object key)</code>进行map遍历</strong></p><p>整个过程可以简单理解成：先获取“key集合”，再通过key找value，获取全部键值对，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;K&gt; keys = map.keySet();</span><br><span class="line"><span class="keyword">for</span>(K key:keys)&#123;</span><br><span class="line">    V value = map.get(key);</span><br><span class="line">    System.out.println(key + <span class="string">"----"</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用<code>entrySet()</code>进行遍历</strong></p><p>整个过程可以理解为：先获取”键值对集合“，再通过键值对，获取key和value</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Map.Entry&lt;K,V&gt;&gt; entries = map.enrtySet();</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;K,V&gt; entry:entries)&#123;</span><br><span class="line">    K key = entry.getKey();</span><br><span class="line">    V value = entry.getValue();</span><br><span class="line">    System.out.println(key + <span class="string">"----"</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Map子类精讲"><a href="#Map子类精讲" class="headerlink" title="Map子类精讲"></a>Map子类精讲</h3><p>这里我们主要总结<code>HashMap</code>的常用操作，详情请参考<a href>java – HashMap详解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;java中为我们提供了很多实用的数据结构，常用的大体上分为两大类：根类为&lt;code&gt;AbstractCollection&lt;/code&gt;的单集合容器，以及根类为&lt;code&gt;AbstractMap&amp;lt;K，V&amp;gt;&lt;/code&gt;的双集合容器。&lt;/p&gt;
      
    
    </summary>
    
      <category term="java-se" scheme="http://rqsir.github.io/categories/java-se/"/>
    
    
      <category term="java - 数据结构" scheme="http://rqsir.github.io/tags/java-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>java -- HashMap详解</title>
    <link href="http://rqsir.github.io/2019/05/14/java-HashMap%E8%AF%A6%E8%A7%A3/"/>
    <id>http://rqsir.github.io/2019/05/14/java-HashMap详解/</id>
    <published>2019-05-13T16:00:00.000Z</published>
    <updated>2019-05-21T03:04:25.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是hash"><a href="#什么是hash" class="headerlink" title="什么是hash"></a>什么是hash</h2><p>比较官方的解释是将任意长度数据映射到到固定长度的域中。</p><p>例如我们要将1~100编号的苹果放在10个篮子中，怎么做才能尽可能均匀地分散这100个苹果，使得每个篮子苹果个数大致相当。最简单的办法就是通过模运算来解决，把每一个苹果的编号<code>num</code>对篮子数<code>n</code>进行取模得到该苹果要放入篮子的编号<code>index</code>，即<code>index=num%n</code>。这样，可以保证每个篮子都将放入10个苹果。</p><h2 id="hash在Map中的应用"><a href="#hash在Map中的应用" class="headerlink" title="hash在Map中的应用"></a>hash在Map中的应用</h2><p><code>HashMap</code>的底层是<code>HashTable</code>，通过<code>Node[]</code>进行数据存储；每一个<code>Node</code>是一个<code>key-value</code>键值对，在进行<code>Node</code>存放，即确定节点在<code>Node[]</code>中的存储<code>index</code>时，采用了<code>Hash</code>散列的思想。由于<code>Hash</code>散列的随机性，有时候会出现不同<code>Node</code>同一<code>index</code>的情况，这时候<code>HashMap</code>采用了同一<code>index</code>处采用链表的形式来存储相同<code>index</code>的不同<code>Node</code>。</p><h2 id="HashMap所在包"><a href="#HashMap所在包" class="headerlink" title="HashMap所在包"></a>HashMap所在包</h2><p><code>HashMap</code>位于<code>java.util</code>包下，使用它必须导包。</p><h2 id="HashMap构造函数"><a href="#HashMap构造函数" class="headerlink" title="HashMap构造函数"></a>HashMap构造函数</h2><p><code>HashMap</code>有4个构造函数，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity</span></span><br><span class="line"><span class="comment">     * (16) and the default load factor (0.75).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment">     * capacity and load factor.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment">     *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment">     * capacity and the default load factor (0.75).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  initialCapacity the initial capacity.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a new &lt;tt&gt;HashMap&lt;/tt&gt; with the same mappings as the</span></span><br><span class="line"><span class="comment">     * specified &lt;tt&gt;Map&lt;/tt&gt;.  The &lt;tt&gt;HashMap&lt;/tt&gt; is created with</span></span><br><span class="line"><span class="comment">     * default load factor (0.75) and an initial capacity sufficient to</span></span><br><span class="line"><span class="comment">     * hold the mappings in the specified &lt;tt&gt;Map&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   m the map whose mappings are to be placed in this map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  NullPointerException if the specified map is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">        putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>一般情况下，我们默认使用空参构造函数，只有在特殊情况需要调节<code>HashMap</code>性能时会使用包含<code>initialCapacity</code>或<code>loadFactor</code>含参构造函数。</p><h2 id="HashMap的底层实现"><a href="#HashMap的底层实现" class="headerlink" title="HashMap的底层实现"></a>HashMap的底层实现</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是hash&quot;&gt;&lt;a href=&quot;#什么是hash&quot; class=&quot;headerlink&quot; title=&quot;什么是hash&quot;&gt;&lt;/a&gt;什么是hash&lt;/h2&gt;&lt;p&gt;比较官方的解释是将任意长度数据映射到到固定长度的域中。&lt;/p&gt;&lt;p&gt;例如我们要将1~100编号的苹果
      
    
    </summary>
    
      <category term="java-se" scheme="http://rqsir.github.io/categories/java-se/"/>
    
    
      <category term="java - HashMap" scheme="http://rqsir.github.io/tags/java-HashMap/"/>
    
  </entry>
  
  <entry>
    <title>java -- 泛型</title>
    <link href="http://rqsir.github.io/2019/05/14/java-%E6%B3%9B%E5%9E%8B/"/>
    <id>http://rqsir.github.io/2019/05/14/java-泛型/</id>
    <published>2019-05-13T16:00:00.000Z</published>
    <updated>2019-05-21T04:19:25.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要引入泛型"><a href="#为什么要引入泛型" class="headerlink" title="为什么要引入泛型"></a>为什么要引入泛型</h2><p>先看一个例子，有如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Student stu = <span class="keyword">new</span> Student(<span class="string">"zhangsan"</span>, <span class="number">32</span>);</span><br><span class="line">        Student stu2 = <span class="keyword">new</span> Student(<span class="string">"lisi"</span>, <span class="number">24</span>);</span><br><span class="line">        </span><br><span class="line">        Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        c.add(stu);</span><br><span class="line">        c.add(stu2);</span><br><span class="line">        </span><br><span class="line">        Iterator it = c.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            String str = (String)it.next();</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Studnet</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread "main" java.lang.ClassCastException: Student cannot be cast to java.lang.String</span><br><span class="line">at GenericTest.main(GenericTest.java:16)</span><br></pre></td></tr></table></figure><p>这是一个java中的类型转换异常，发生的原因是我们无法将一个<code>Student</code>类强转为<code>String</code>类，因为它们之间没有继承关系。</p><p>针对这种问题，java为我们提供了一种叫做<strong>泛型</strong>的机制，在编译期间就明确集合中存储元素类型，规避掉了这种不安全的转换情景。</p><p>修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Student stu = <span class="keyword">new</span> Student(<span class="string">"zhangsan"</span>, <span class="number">32</span>);</span><br><span class="line">        Student stu2 = <span class="keyword">new</span> Student(<span class="string">"lisi"</span>, <span class="number">24</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在声明及初始化集合变量时，就通过“&lt;Student&gt;”指明元素类型</span></span><br><span class="line">        Collection&lt;Student&gt; c = <span class="keyword">new</span> ArrayList&lt;Student&gt;();</span><br><span class="line">        c.add(stu);</span><br><span class="line">        c.add(stu2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//由于迭代器的底层操作的是集合的副本，也可以通过泛型机制指明元素类型</span></span><br><span class="line">        Iterator&lt;Student&gt; it = c.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            Student s = it.next();</span><br><span class="line">            System.out.println(s.name+<span class="string">"---"</span>+s.age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型给我们带来了什么"><a href="#泛型给我们带来了什么" class="headerlink" title="泛型给我们带来了什么"></a>泛型给我们带来了什么</h2><p>泛型的好处归纳起来，有如下几点：</p><ul><li>规避了不安全类型转换问题</li><li>减少IDE警告</li><li>可以简化代码书写（不用手动进行类型转换）</li></ul><h2 id="什么时候可以使用泛型"><a href="#什么时候可以使用泛型" class="headerlink" title="什么时候可以使用泛型"></a>什么时候可以使用泛型</h2><p>是否可以使用泛型，具体以API为准；原理上只要带有<code>&lt;E&gt;</code>标志的类或接口，都可以使用泛型。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么要引入泛型&quot;&gt;&lt;a href=&quot;#为什么要引入泛型&quot; class=&quot;headerlink&quot; title=&quot;为什么要引入泛型&quot;&gt;&lt;/a&gt;为什么要引入泛型&lt;/h2&gt;&lt;p&gt;先看一个例子，有如下代码：&lt;/p&gt;&lt;figure class=&quot;highlight java
      
    
    </summary>
    
      <category term="java-se" scheme="http://rqsir.github.io/categories/java-se/"/>
    
    
      <category term="java - 泛型" scheme="http://rqsir.github.io/tags/java-%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>java -- 文件管家File类</title>
    <link href="http://rqsir.github.io/2019/05/14/java-%E6%96%87%E4%BB%B6%E7%AE%A1%E5%AE%B6File%E7%B1%BB/"/>
    <id>http://rqsir.github.io/2019/05/14/java-文件管家File类/</id>
    <published>2019-05-13T16:00:00.000Z</published>
    <updated>2019-05-21T04:17:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类初识"><a href="#类初识" class="headerlink" title="类初识"></a>类初识</h2><p><code>File</code>是java中文件管理工具类，主要负责文件和目录的相关操作。</p><p>JDK1.8中对其描述如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">* An <span class="keyword">abstract</span> representation of file and directory pathnames.</span><br><span class="line">*</span><br><span class="line">* &lt;p&gt; User interfaces and operating systems use system-dependent &lt;em&gt;pathname</span><br><span class="line">* strings&lt;/em&gt; to name files and directories.  This class presents an</span><br><span class="line">* <span class="keyword">abstract</span>, system-independent view of hierarchical pathnames.  An</span><br><span class="line">* &lt;em&gt;abstract pathname&lt;/em&gt; has two components:</span><br><span class="line">*</span><br><span class="line">* &lt;ol&gt;</span><br><span class="line">* &lt;li&gt; An optional system-dependent &lt;em&gt;prefix&lt;/em&gt; string,</span><br><span class="line">*      such as a disk-drive specifier, &lt;code&gt;"/"&lt;/code&gt;&amp;nbsp;for the UNIX root</span><br><span class="line">*      directory, or &lt;code&gt;"\\\\"&lt;/code&gt;&amp;nbsp;for a Microsoft Windows UNC pathname, and</span><br><span class="line">* &lt;li&gt; A sequence of zero or more string &lt;em&gt;names&lt;/em&gt;.</span><br><span class="line">* &lt;/ol&gt;</span><br></pre></td></tr></table></figure><p>需要指出的是 ，<code>File</code>对象并不一定是一个实际存在的物理对象，它仅表示对指定<code>path</code>的文件或目录的抽象描述；最终生成文件和目录，还得依赖于相关的成员函数如<code>createNewFile()</code>或<code>mkdir()</code>等。</p><h2 id="所在包"><a href="#所在包" class="headerlink" title="所在包"></a>所在包</h2><p><code>File</code>类位于<code>java.io</code>包下，使用时需要导包。</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p><code>File</code>共有6个构造方法，其中2个为私有构造方法，主要供其类部使用，这里不谈；剩余的4个公有构造函数，详情见下表所示：</p><table><thead><tr><th style="text-align:center">构造方法名</th><th style="text-align:center">介绍</th></tr></thead><tbody><tr><td style="text-align:center">File(File parent, String child)</td><td style="text-align:center">通过父目录File对象和待创建目录或文件名，生成一个File对象</td></tr><tr><td style="text-align:center">File(String parent, String child)</td><td style="text-align:center">通过父目录名和待创建目录或文件名，生成一个File对象</td></tr><tr><td style="text-align:center">File(String pathname)</td><td style="text-align:center">通过指定完整路径名，生成一个File对象</td></tr><tr><td style="text-align:center">File(URI uri)</td><td style="text-align:center">通过指定完整路径的URI，生成一个File对象</td></tr></tbody></table><h2 id="常用成员方法"><a href="#常用成员方法" class="headerlink" title="常用成员方法"></a>常用成员方法</h2><p>由于<code>File</code>类中方法比较多，我们这里简单地分类如下：</p><ul><li>负责创建文件和目录的方法</li></ul><table><thead><tr><th style="text-align:center">创建的方法</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">boolean createNewFile()</td><td style="text-align:center">创建新文件</td></tr><tr><td style="text-align:center">boolean mkdir()</td><td style="text-align:center">创建新单级目录</td></tr><tr><td style="text-align:center">boolean mkdirs()</td><td style="text-align:center">创建新多级目录</td></tr></tbody></table><ul><li>负责删除文件和目录的方法</li></ul><table><thead><tr><th style="text-align:center">删除的方法</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">boolean delete()</td><td style="text-align:center">删除指定文件和目录（目录必须为空）</td></tr></tbody></table><ul><li>负责获取文件和目录属性的方法</li></ul><table><thead><tr><th style="text-align:center">获取的方法</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">File getAbsoluteFile()</td><td style="text-align:center">获取绝对路径的File对象</td></tr><tr><td style="text-align:center">String getAbsolutePath()</td><td style="text-align:center">获取File对象的绝对路径</td></tr><tr><td style="text-align:center">String getParent()</td><td style="text-align:center">获取File对象的父路径</td></tr><tr><td style="text-align:center">File getParentFile()</td><td style="text-align:center">获取File对象的父File对象</td></tr><tr><td style="text-align:center">String getName()</td><td style="text-align:center">获取文件或目录名称</td></tr><tr><td style="text-align:center">String getPath()</td><td style="text-align:center">获取文件或目录创建时指定的路径（绝对或相对路径）</td></tr><tr><td style="text-align:center">long lastModified()</td><td style="text-align:center">以毫秒值返回文件或目录最后修改时间</td></tr><tr><td style="text-align:center">long length()</td><td style="text-align:center">返回文件的字节数</td></tr></tbody></table><ul><li>负责判断文件和目录行为的方法</li></ul><table><thead><tr><th style="text-align:center">判断的方法</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">boolean exists()</td><td style="text-align:center">判断文件或目录是否存在</td></tr><tr><td style="text-align:center">boolean isAbsolute()</td><td style="text-align:center">判断文件或目录路径是否为绝对路径</td></tr><tr><td style="text-align:center">boolean isDirectory()</td><td style="text-align:center">判断是否为目录对象</td></tr><tr><td style="text-align:center">boolean isFile()</td><td style="text-align:center">判断是否为文件对象</td></tr><tr><td style="text-align:center">boolean isHidden</td><td style="text-align:center">判断是否为隐藏文件或目录</td></tr></tbody></table><ul><li>负责修改文件和目录属性的方法</li></ul><table><thead><tr><th style="text-align:center">修改的方法</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">boolean renameTo(File dest)</td><td style="text-align:center">将文件或目录路径修改为dest的路径</td></tr></tbody></table><p>除此之外，有一些与文件遍历有关的方法，我们需重点掌握，总结如下：</p><table><thead><tr><th style="text-align:center">遍历的方法</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">String[] list()</td><td style="text-align:center">获取目录下所有文件和目录，以String类型返回</td></tr><tr><td style="text-align:center">File[] listFiles()</td><td style="text-align:center">获取目录下所有文件和目录，以File类型返回</td></tr><tr><td style="text-align:center">File[] listRoots()</td><td style="text-align:center">获取文件系统的根目录，win下为盘符，linux下为“\”，以File类型返回</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;类初识&quot;&gt;&lt;a href=&quot;#类初识&quot; class=&quot;headerlink&quot; title=&quot;类初识&quot;&gt;&lt;/a&gt;类初识&lt;/h2&gt;&lt;p&gt;&lt;code&gt;File&lt;/code&gt;是java中文件管理工具类，主要负责文件和目录的相关操作。&lt;/p&gt;&lt;p&gt;JDK1.8中对其描述如下
      
    
    </summary>
    
      <category term="java-se" scheme="http://rqsir.github.io/categories/java-se/"/>
    
    
      <category term="java - File类" scheme="http://rqsir.github.io/tags/java-File%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>java -- 增强for循环</title>
    <link href="http://rqsir.github.io/2019/05/14/java-%E5%A2%9E%E5%BC%BAfor%E5%BE%AA%E7%8E%AF/"/>
    <id>http://rqsir.github.io/2019/05/14/java-增强for循环/</id>
    <published>2019-05-13T16:00:00.000Z</published>
    <updated>2019-05-21T04:13:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>增强for循环是JDK1.5后引入java的一种语法，其目的主要是方便遍历集合中的元素。</p><h2 id="干什么"><a href="#干什么" class="headerlink" title="干什么"></a>干什么</h2><p>对于集合的遍历，我们先看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; c = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">c.add(<span class="string">"I"</span>);</span><br><span class="line">c.add(<span class="string">"love"</span>);</span><br><span class="line">c.add(<span class="string">"java"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(String str:c)&#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出为：</span><br><span class="line">I</span><br><span class="line">love</span><br><span class="line">java</span><br></pre></td></tr></table></figure><p>这种方法相对于以前的将集合转数组，抑或是通过迭代器遍历，都显得更为简单直接。</p><h2 id="什么时候可以用"><a href="#什么时候可以用" class="headerlink" title="什么时候可以用"></a>什么时候可以用</h2><p>在JDK文档中指出，凡是实现了<code>iterable</code>接口的子类对象都可以使用增强for循环。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>如果我们在增强for中，同时修改了遍历集合，就会抛出<code>ConcurrentModificationException</code>异常。这里为深入了解其中机制，我们有必要知道增强for在遍历时，到底做了什么？</p><p>利用反编译工具<code>procyon.jar</code>，我们对上述代码进行了反编译，过程如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">rqsir@rqsir-TM1604:~/IdeaProjects/EnhancedForLoop/out/production/EnhancedForLoop$ java -jar /opt/procyon.jar -b EnhancedForLoopTest.class</span><br><span class="line">public class EnhancedForLoopTest &#123;</span><br><span class="line">    public void <span class="function"><span class="title">EnhancedForLoopTest</span></span>() &#123;</span><br><span class="line">        invokespecial:Object(Object::&lt;init&gt;, this:EnhancedForLoopTest)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(java.lang.String[] args) &#123;</span><br><span class="line">        c : Collection&lt;String&gt;</span><br><span class="line">        var_2_29 : Iterator&lt;String&gt;</span><br><span class="line">        str : String</span><br><span class="line">        </span><br><span class="line">        c = initobject:ArrayList&lt;String&gt;[expected:Collection&lt;String&gt;](ArrayList&lt;E&gt;::&lt;init&gt;)</span><br><span class="line">        invokeinterface:boolean(Collection&lt;String&gt;::add, c:Collection&lt;String&gt;, ldc:String(<span class="string">"I"</span>))</span><br><span class="line">        invokeinterface:boolean(Collection&lt;String&gt;::add, c:Collection&lt;String&gt;, ldc:String(<span class="string">"love"</span>))</span><br><span class="line">        invokeinterface:boolean(Collection&lt;String&gt;::add, c:Collection&lt;String&gt;, ldc:String(<span class="string">"java"</span>))</span><br><span class="line">        var_2_29 = invokeinterface:Iterator&lt;String&gt;(Collection&lt;String&gt;::iterator, c:Collection&lt;String&gt;)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (invokeinterface:boolean(Iterator&lt;E&gt;::hasNext, var_2_29:Iterator&lt;String&gt;)) &#123;</span><br><span class="line">            str = checkcast:String(java.lang.String.class, invokeinterface:String(Iterator&lt;String&gt;::next, var_2_29:Iterator&lt;String&gt;))</span><br><span class="line">            invokevirtual:void(PrintStream::println, getstatic:PrintStream(System::out), str:String)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从上面的反编译结果中，我们不能发现，所谓的增强for循环，实际上是由编译器在底层帮我们装换成了<code>iterator</code>的while遍历。既然调用了<code>iterator</code>，那么并发修改就需要上心了，详情可以参考<a href>java – 迭代器并发修改异常</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;是什么&quot;&gt;&lt;a href=&quot;#是什么&quot; class=&quot;headerlink&quot; title=&quot;是什么&quot;&gt;&lt;/a&gt;是什么&lt;/h2&gt;&lt;p&gt;增强for循环是JDK1.5后引入java的一种语法，其目的主要是方便遍历集合中的元素。&lt;/p&gt;&lt;h2 id=&quot;干什么&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="java-se" scheme="http://rqsir.github.io/categories/java-se/"/>
    
    
      <category term="java - 增强for" scheme="http://rqsir.github.io/tags/java-%E5%A2%9E%E5%BC%BAfor/"/>
    
  </entry>
  
  <entry>
    <title>java -- 迭代器并发修改异常</title>
    <link href="http://rqsir.github.io/2019/05/14/java-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%B9%B6%E5%8F%91%E4%BF%AE%E6%94%B9%E5%BC%82%E5%B8%B8/"/>
    <id>http://rqsir.github.io/2019/05/14/java-迭代器并发修改异常/</id>
    <published>2019-05-13T16:00:00.000Z</published>
    <updated>2019-05-21T04:21:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>我们在使用<code>iterator</code>对象遍历集合时，时常会遇到<code>ConcurrentModificationException</code>这类的错误</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line">       </span><br><span class="line">   c.add(<span class="string">"I"</span>);</span><br><span class="line">   c.add(<span class="string">"love"</span>);</span><br><span class="line">   c.add(<span class="string">"java"</span>);</span><br><span class="line"></span><br><span class="line">   Iterator&lt;String&gt; it = c.iterator();</span><br><span class="line">   <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">       <span class="keyword">if</span>(it.next().equals(<span class="string">"love"</span>))</span><br><span class="line">           c.add(<span class="string">"Oracle"</span>); <span class="comment">//在使用迭代器遍历集合时，修改了原集合</span></span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception <span class="keyword">in</span> thread <span class="string">"main"</span> java.util.ConcurrentModificationException</span><br><span class="line">at java.util.ArrayList<span class="variable">$Itr</span>.checkForComodification(ArrayList.java:909)</span><br><span class="line">at java.util.ArrayList<span class="variable">$Itr</span>.next(ArrayList.java:859)</span><br><span class="line">at IteratorTest.main(IteratorTest.java:15)</span><br></pre></td></tr></table></figure><p>这主要是因为，迭代器遍历集合，实际上是对集合的副本进行操作；这期间，如果迭代器发现自己和集合不一样了，就会报<code>ConcurrentModificationException</code>异常。</p><h2 id="原因-–-迭代器的并发检测"><a href="#原因-–-迭代器的并发检测" class="headerlink" title="原因 – 迭代器的并发检测"></a>原因 – 迭代器的并发检测</h2><p>我们可以从JDK源码的获知，当程序执行到<code>it.next()</code>，实际上调用了如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkForComodification(); <span class="comment">//在这里迭代器将自己与原始集合进行了比较</span></span><br><span class="line">    <span class="keyword">int</span> i = cursor;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    cursor = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于第一个函数<code>checkForComodification()</code>，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法主要是通过比较<code>modConut</code>和<code>expectedModCount</code>是否相等，来判断迭代器运行期间，原集合是否发生了变化。其中<code>modCount</code>为<code>ArrayList</code>的类成员变量，用来记录其变化次数；而<code>expectedModCount</code>作为迭代器成员变量，则存储了<code>iterator</code>初始化时记录到的<code>ArrayList</code>中的<code>modCount</code>值。两者相比，即可判断集合是否在迭代器操作期间发生了变化。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>为了解决这个并发修改异常，最直接的方法就是在<code>iterator</code>运行期间，不要修改原集合。但万一我们业务需要，必须得修改，又该怎么办呢？</p><p>既然不允许我们直接修改原集合，那么我们可以考虑通过迭代器去间接操作原集合。通过查询API文档，我们在<code>Iterator</code>接口中并未发现<code>add()</code>方法。既然根类<code>Iterator</code>中没有，我们就到其子接口中去寻找。不出所料，在其<code>Iterator</code>子接口<code>ListIterator</code>中，我们发现了<code>add()</code>方法。首先看一下它的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = cursor;</span><br><span class="line">            ArrayList.<span class="keyword">this</span>.add(i, e); <span class="comment">//调用了ArrayList当前对象的成员方法</span></span><br><span class="line">            cursor = i + <span class="number">1</span>;</span><br><span class="line">            lastRet = -<span class="number">1</span>;</span><br><span class="line">        expectedModCount = modCount; <span class="comment">//这里将expectedModCount与modCount进行了同步</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>从源码中，我们可以看到，虽然任然存在并发检测函数<code>checkForComodification()</code>，但<code>add()</code>在内部为我们完成了集合元素的添加，最最关键的是它还进行了<code>expectedModCount</code>与<code>modCount</code>同步操作，这就保证了并发修改异常不会被触发。</p><p>终上所述，最开始的问题代码可以修改如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List c = new ArrayList(); //这里将c的引用类型从Collection换成List，是因为Collection接//口中没有listIterator()方法，多态无法调用父接口中没有的方法</span><br><span class="line">    </span><br><span class="line">c.add(&quot;I&quot;);</span><br><span class="line">c.add(&quot;love&quot;);</span><br><span class="line">c.add(&quot;java&quot;);</span><br><span class="line"></span><br><span class="line">ListIterator&lt;String&gt; it = c.listIterator();//理由同上，Iterator中没有add方法</span><br><span class="line">while (it.hasNext())&#123;</span><br><span class="line">    if(it.next().equals(&quot;love&quot;))</span><br><span class="line">        it.add(&quot;Oracle&quot;); </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;我们在使用&lt;code&gt;iterator&lt;/code&gt;对象遍历集合时，时常会遇到&lt;code&gt;ConcurrentModific
      
    
    </summary>
    
      <category term="java-se" scheme="http://rqsir.github.io/categories/java-se/"/>
    
    
      <category term="java - 迭代器并发修改异常" scheme="http://rqsir.github.io/tags/java-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%B9%B6%E5%8F%91%E4%BF%AE%E6%94%B9%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>linux中的SysRq魔术键</title>
    <link href="http://rqsir.github.io/2019/05/02/linux%E4%B8%AD%E7%9A%84SysRq%E9%AD%94%E6%9C%AF%E9%94%AE/"/>
    <id>http://rqsir.github.io/2019/05/02/linux中的SysRq魔术键/</id>
    <published>2019-05-01T16:00:00.000Z</published>
    <updated>2019-06-29T13:11:29.775Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>接触<code>SysRq</code>完全是一种巧合。由于平时手比较欠，总是冷不丁地就将<code>ubuntu</code>给整死机了，这要是在以前我大概是选择按下电源键重启了。但这样做的危害也是显而易见的，轻则数据丢失，重则系统直接挂掉重启一片黑。于是乎，我给自己告诫再三：<strong>死机切记不要暴力重启</strong>。</p></blockquote><h2 id="linux应对死机三步骤"><a href="#linux应对死机三步骤" class="headerlink" title="linux应对死机三步骤"></a>linux应对死机三步骤</h2><p>经过多方查阅与实践总结，我大致摸索出了如下应对系统死机的解决方案，流程如下：</p><ol><li>如果死机是由<code>xwindow</code>等窗口程序引起的，如因为<code>gnome</code>导致的假死机，这时候可以按下<code>alt+F2</code>调出<code>gnome</code>运行窗口，接着输入<code>r</code>回车，来刷新<code>gnome</code>。</li><li>如果第一步不奏效，可能是<code>xwindow</code>已经挂掉了，这时候可以选择进入<code>tty</code>终端。按下快捷键组合<code>ctrl+alt+F3</code>就进入了<code>tty3</code>（类似的还可以进入<code>tty4</code>、<code>tty5</code>等）。这是一个类似<code>shell</code>的界面，在这里我们可以先通过<code>top</code>命令获取高<code>cpu</code>占用进程，再通过<code>pkill 进程名</code>或者<code>kill -9 pid</code>的方式杀死死锁进程。最后通过<code>ctrl+alt+F2</code>返回<code>xwindow</code>界面。</li><li>如果以上都无效，那大概率是系统定底层出现了问题，这时候就要祭出<code>SysRq</code>魔术键了。</li></ol><h2 id="什么是SysRq"><a href="#什么是SysRq" class="headerlink" title="什么是SysRq"></a>什么是SysRq</h2><p><code>SysRq</code> 经常被称为 <code>Magic System Request</code>，它被定义为一系列按键组合。当系统因为某种原因已经停止对大部分正常服务的响应，但是系统仍然可以响应键盘的按键中断请求。在这种情况下，<code>SysRq</code> 的按键组合将发挥它的神奇作用。</p><p>通过它，不但可以在保证磁盘数据安全的情况下重启一台挂起的服务器，避免数据丢失和重启后长时间的文件系统检查，还可以收集包括系统内存使用，CPU 任务处理，进程运行状态等系统运行信息，甚至还可能在无需重启的情况下挽回一台已经停止响应的服务器。</p><h2 id="启动SysRq"><a href="#启动SysRq" class="headerlink" title="启动SysRq"></a>启动SysRq</h2><p>首先检查<code>SysRq</code>是否开启</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/kernel/sysrq</span><br></pre></td></tr></table></figure><p>若输出为0，则还未开启。可以通过<code>systcl</code>命令开启<code>SysRq</code>，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sysctl -w kernel.sysrq=1</span><br></pre></td></tr></table></figure><p>由于以上操作只在本次开机运行时有效，为保证下次开机<code>SysRq</code>服务自动启用，需进行如下配置：</p><p>编辑<code>/etc/sysctl.conf</code>，添加如下一行内容(或去掉其前注释)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel.sysrq = 1</span><br></pre></td></tr></table></figure><h2 id="常用SysRq组合键"><a href="#常用SysRq组合键" class="headerlink" title="常用SysRq组合键"></a>常用SysRq组合键</h2><h4 id="R-E-I-S-U-B-–-安全重启万精油"><a href="#R-E-I-S-U-B-–-安全重启万精油" class="headerlink" title="R-E-I-S-U-B – 安全重启万精油"></a><code>R-E-I-S-U-B</code> – 安全重启万精油</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">R - 把键盘设置为 ASCII 模式 (用于接收后面键盘输入)</span><br><span class="line">SysRq: Keyboard mode set to XLATE</span><br><span class="line"></span><br><span class="line">E - 向除 init 以外所有进程发送 SIGTERM 信号 (让进程自己正常退出)</span><br><span class="line">SysRq: Terminate All Tasks</span><br><span class="line"></span><br><span class="line">I - 向除 init 以外所有进程发送 SIGKILL 信号 (强制结束进程)</span><br><span class="line">SysRq: Kill All Tasks</span><br><span class="line"></span><br><span class="line">S - 磁盘缓冲区同步</span><br><span class="line">SysRq : Emergency Sync</span><br><span class="line"></span><br><span class="line">U - 重新挂载为只读模式</span><br><span class="line">SysRq : Emergency Remount R/O</span><br><span class="line"></span><br><span class="line">B - 立即重启系统</span><br><span class="line">SysRq: Resetting</span><br></pre></td></tr></table></figure><p>由于系统环境与后台进程个数的不确定性，每一步按键操作执行完成所费时间无法确定。为保险起见，一般采用<strong>R – 1 秒 – E – 30 秒 – I – 10 秒 – S – 5 秒 – U – 5 秒 – B，而不是一气呵成地按下这六个键</strong>。</p><h4 id="E-I-K-–-解决系统假死利器"><a href="#E-I-K-–-解决系统假死利器" class="headerlink" title="E-I-K – 解决系统假死利器"></a><code>E-I-K</code> – 解决系统假死利器</h4><p>有时候系统的死机仅仅是因为个别进程过分消耗<code>cpu</code>或内存等系统资源所引发的，这时候就没有必要非得重启来解决问题。我们需要做的就是找出“幕后黑手”，结束掉该进程就行了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">E - 向除 init 以外所有进程发送 SIGTERM 信号 (让进程自己正常退出)</span><br><span class="line">SysRq: Terminate All Tasks</span><br><span class="line"></span><br><span class="line">I - 向除 init 以外所有进程发送 SIGKILL 信号 (强制结束进程)</span><br><span class="line">SysRq: Kill All Tasks</span><br><span class="line"></span><br><span class="line">K - 结束与当前控制台相关的全部进程</span><br><span class="line">SysRq : SAK </span><br><span class="line"></span><br><span class="line">F - 人为触发 OOM Killer (可选，除非可以确认是内存使用问题，尽量避免使用这个组合键)</span><br><span class="line">SysRq : Manual OOM execution </span><br><span class="line">(OOM Killer 将根据各进程的内存处理情况选取最合适的“凶手”进程，并向其发送 SIGKILL 信号，中止其运行。)</span><br></pre></td></tr></table></figure><h4 id="M-P-T-W-–-系统死机证据收集机"><a href="#M-P-T-W-–-系统死机证据收集机" class="headerlink" title="M-P-T-W – 系统死机证据收集机"></a><code>M-P-T-W</code> – 系统死机证据收集机</h4><p><code>SysRq</code> 提供了 M-P-T-W 序列，在恢复系统挂起之前，这是一个推荐执行的序列。它会记录下当前系统的内存使用情况，当前 CPU 寄存器的状态，进程运行状态，以及所有 CPU 及寄存器的状态。通过这些信息，可以对挂起的原因做粗略的分析。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">M - 打印内存使用信息</span><br><span class="line">SysRq : Show Memory</span><br><span class="line"></span><br><span class="line">P - 打印当前 CPU 寄存器信息</span><br><span class="line">SysRq : Show Regs</span><br><span class="line"></span><br><span class="line">T - 打印进程列表</span><br><span class="line">SysRq : Show State</span><br><span class="line"></span><br><span class="line">W - 打印 CPU 信息</span><br><span class="line">SysRq : Show CPUs</span><br></pre></td></tr></table></figure><h4 id="其它功能键组合"><a href="#其它功能键组合" class="headerlink" title="其它功能键组合"></a>其它功能键组合</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">H - 帮助</span><br><span class="line">它显示了当前系统支持的所有 SysRq 组合，所有的按键均用大写字母表示。</span><br><span class="line"></span><br><span class="line">C - 触发 Crashdump</span><br><span class="line">更详细系统挂起的诊断和数据收集</span><br><span class="line"></span><br><span class="line">N - 降低实时任务运行优化级</span><br><span class="line">这对于由实时任务消耗 CPU 引起的系统挂起会起到立竿见影的作用。</span><br></pre></td></tr></table></figure><h2 id="查看SysRq输出"><a href="#查看SysRq输出" class="headerlink" title="查看SysRq输出"></a>查看SysRq输出</h2><ol><li><p>输出到本地终端</p><p><code>SysRq</code> 默认会根据<code>console_loglevel</code>输出到本地终端。只要 <code>console_loglevel</code> 大于 <code>default_message_loglevel</code>，<code>SysRq</code>信息就会输出到本地控制台终端。</p></li><li><p>输出到 syslog</p><p>根据 <code>syslog</code> 的默认配置，<code>SysRq</code>默认会记录到 <code>/var/log/messages</code>，并且这里记录的信息与<br><code>console_loglevel</code> 无关，基本是完整的。但是由于负责记录日志的 <code>syslogd</code> 本身也是一个用户进程，在执行后面即将介绍的 <code>SysRq-E</code>, <code>SysRq-I</code> 时也会被终结，这就意味着 <code>syslog</code> 记录的信息在一定情况下将不再完整。</p></li><li><p>通过 netconsole 输出</p></li><li><p>输出到串口终端</p></li></ol><h2 id="附录-–-SysRq-txt"><a href="#附录-–-SysRq-txt" class="headerlink" title="附录 – SysRq.txt"></a>附录 – SysRq.txt</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line">Linux Magic System Request Key Hacks</span><br><span class="line">Documentation for sysrq.c version 1.15</span><br><span class="line">Last update: $Date: 2001/01/28 10:15:59 $</span><br><span class="line">*  What is the magic SysRq key?</span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">It is a &apos;magical&apos; key combo you can hit which the kernel will respond to</span><br><span class="line">regardless of whatever else it is doing, unless it is completely locked up.</span><br><span class="line">*  How do I enable the magic SysRq key?</span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">You need to say &quot;yes&quot; to &apos;Magic SysRq key (CONFIG_MAGIC_SYSRQ)&apos; when</span><br><span class="line">configuring the kernel. When running a kernel with SysRq compiled in,</span><br><span class="line">/proc/sys/kernel/sysrq controls the functions allowed to be invoked via</span><br><span class="line">the SysRq key. By default the file contains 1 which means that every</span><br><span class="line">possible SysRq request is allowed (in older versions SysRq was disabled</span><br><span class="line">by default, and you were required to specifically enable it at run-time</span><br><span class="line">but this is not the case any more). Here is the list of possible values</span><br><span class="line">in /proc/sys/kernel/sysrq:</span><br><span class="line">   0 - disable sysrq completely</span><br><span class="line">   1 - enable all functions of sysrq</span><br><span class="line">  &gt;1 - bitmask of allowed sysrq functions (see below for detailed function</span><br><span class="line">       description):</span><br><span class="line">          2 - enable control of console logging level</span><br><span class="line">          4 - enable control of keyboard (SAK, unraw)</span><br><span class="line">          8 - enable debugging dumps of processes etc.</span><br><span class="line">         16 - enable sync command</span><br><span class="line">         32 - enable remount read-only</span><br><span class="line">         64 - enable signalling of processes (term, kill, oom-kill)</span><br><span class="line">        128 - allow reboot/poweroff</span><br><span class="line">        256 - allow nicing of all RT tasks</span><br><span class="line">You can set the value in the file by the following command:</span><br><span class="line">    echo &quot;number&quot; &gt;/proc/sys/kernel/sysrq</span><br><span class="line">Note that the value of /proc/sys/kernel/sysrq influences only the invocation</span><br><span class="line">via a keyboard. Invocation of any operation via /proc/sysrq-trigger is always</span><br><span class="line">allowed.</span><br><span class="line">*  How do I use the magic SysRq key?</span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">On x86   - You press the key combo &apos;ALT-SysRq-&lt;command key&gt;&apos;. Note - Some</span><br><span class="line">           keyboards may not have a key labeled &apos;SysRq&apos;. The &apos;SysRq&apos; key is</span><br><span class="line">           also known as the &apos;Print Screen&apos; key. Also some keyboards cannot</span><br><span class="line">   handle so many keys being pressed at the same time, so you might</span><br><span class="line">   have better luck with &quot;press Alt&quot;, &quot;press SysRq&quot;, &quot;release Alt&quot;,</span><br><span class="line">   &quot;press &lt;command key&gt;&quot;, release everything.</span><br><span class="line">On SPARC - You press &apos;ALT-STOP-&lt;command key&gt;&apos;, I believe.</span><br><span class="line">On the serial console (PC style standard serial ports only) -</span><br><span class="line">           You send a BREAK, then within 5 seconds a command key. Sending</span><br><span class="line">           BREAK twice is interpreted as a normal BREAK.</span><br><span class="line">On PowerPC - Press &apos;ALT - Print Screen (or F13) - &lt;command key&gt;,  </span><br><span class="line">             Print Screen (or F13) - &lt;command key&gt; may suffice.</span><br><span class="line">On other - If you know of the key combos for other architectures, please</span><br><span class="line">           let me know so I can add them to this section.</span><br><span class="line">On all -  write a character to /proc/sysrq-trigger.  eg:</span><br><span class="line">echo t &gt; /proc/sysrq-trigger</span><br><span class="line">*  What are the &apos;command&apos; keys?</span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">&apos;r&apos;     - Turns off keyboard raw mode and sets it to XLATE.</span><br><span class="line">&apos;k&apos;     - Secure Access Key (SAK) Kills all programs on the current virtual</span><br><span class="line">          console. NOTE: See important comments below in SAK section.</span><br><span class="line">&apos;b&apos;     - Will immediately reboot the system without syncing or unmounting</span><br><span class="line">          your disks.</span><br><span class="line">&apos;c&apos;- Will perform a kexec reboot in order to take a crashdump.</span><br><span class="line">&apos;o&apos;     - Will shut your system off (if configured and supported).</span><br><span class="line">&apos;s&apos;     - Will attempt to sync all mounted filesystems.</span><br><span class="line">&apos;u&apos;     - Will attempt to remount all mounted filesystems read-only.</span><br><span class="line">&apos;p&apos;     - Will dump the current registers and flags to your console.</span><br><span class="line">&apos;t&apos;     - Will dump a list of current tasks and their information to your</span><br><span class="line">          console.</span><br><span class="line">&apos;m&apos;     - Will dump current memory info to your console.</span><br><span class="line">&apos;v&apos;- Dumps Voyager SMP processor info to your console.</span><br><span class="line">&apos;0&apos;-&apos;9&apos; - Sets the console log level, controlling which kernel messages</span><br><span class="line">          will be printed to your console. (&apos;0&apos;, for example would make</span><br><span class="line">          it so that only emergency messages like PANICs or OOPSes would</span><br><span class="line">          make it to your console.)</span><br><span class="line">&apos;f&apos;- Will call oom_kill to kill a memory hog process</span><br><span class="line">&apos;e&apos;     - Send a SIGTERM to all processes, except for init.</span><br><span class="line">&apos;i&apos;     - Send a SIGKILL to all processes, except for init.</span><br><span class="line">&apos;l&apos;     - Send a SIGKILL to all processes, INCLUDING init. (Your system</span><br><span class="line">          will be non-functional after this.)</span><br><span class="line">&apos;h&apos;     - Will display help ( actually any other key than those listed</span><br><span class="line">          above will display help. but &apos;h&apos; is easy to remember :-)</span><br><span class="line">*  Okay, so what can I use them for?</span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">Well, un&apos;R&apos;aw is very handy when your X server or a svgalib program crashes.</span><br><span class="line">sa&apos;K&apos; (Secure Access Key) is useful when you want to be sure there are no</span><br><span class="line">trojan program is running at console and which could grab your password</span><br><span class="line">when you would try to login. It will kill all programs on given console</span><br><span class="line">and thus letting you make sure that the login prompt you see is actually</span><br><span class="line">the one from init, not some trojan program.</span><br><span class="line">IMPORTANT:In its true form it is not a true SAK like the one in   :IMPORTANT</span><br><span class="line">IMPORTANT:c2 compliant systems, and it should be mistook as such. :IMPORTANT</span><br><span class="line">       It seems other find it useful as (System Attention Key) which is</span><br><span class="line">useful when you want to exit a program that will not let you switch consoles.</span><br><span class="line">(For example, X or a svgalib program.)</span><br><span class="line">re&apos;B&apos;oot is good when you&apos;re unable to shut down. But you should also &apos;S&apos;ync</span><br><span class="line">and &apos;U&apos;mount first.</span><br><span class="line">&apos;C&apos;rashdump can be used to manually trigger a crashdump when the system is hung.</span><br><span class="line">The kernel needs to have been built with CONFIG_KEXEC enabled.</span><br><span class="line">&apos;S&apos;ync is great when your system is locked up, it allows you to sync your</span><br><span class="line">disks and will certainly lessen the chance of data loss and fscking. Note</span><br><span class="line">that the sync hasn&apos;t taken place until you see the &quot;OK&quot; and &quot;Done&quot; appear</span><br><span class="line">on the screen. (If the kernel is really in strife, you may not ever get the</span><br><span class="line">OK or Done message...)</span><br><span class="line">&apos;U&apos;mount is basically useful in the same ways as &apos;S&apos;ync. I generally &apos;S&apos;ync,</span><br><span class="line">&apos;U&apos;mount, then re&apos;B&apos;oot when my system locks. It&apos;s saved me many a fsck.</span><br><span class="line">Again, the unmount (remount read-only) hasn&apos;t taken place until you see the</span><br><span class="line">&quot;OK&quot; and &quot;Done&quot; message appear on the screen.</span><br><span class="line">The loglevel&apos;0&apos;-&apos;9&apos; is useful when your console is being flooded with</span><br><span class="line">kernel messages you do not want to see. Setting &apos;0&apos; will prevent all but</span><br><span class="line">the most urgent kernel messages from reaching your console. (They will</span><br><span class="line">still be logged if syslogd/klogd are alive, though.)</span><br><span class="line">t&apos;E&apos;rm and k&apos;I&apos;ll are useful if you have some sort of runaway process you</span><br><span class="line">are unable to kill any other way, especially if it&apos;s spawning other</span><br><span class="line">processes.</span><br><span class="line">*  Sometimes SysRq seems to get &apos;stuck&apos; after using it, what can I do?</span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">That happens to me, also. I&apos;ve found that tapping shift, alt, and control</span><br><span class="line">on both sides of the keyboard, and hitting an invalid sysrq sequence again</span><br><span class="line">will fix the problem. (ie, something like alt-sysrq-z). Switching to another</span><br><span class="line">virtual console (ALT+Fn) and then back again should also help.</span><br><span class="line">*  I hit SysRq, but nothing seems to happen, what&apos;s wrong?</span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">There are some keyboards that send different scancodes for SysRq than the</span><br><span class="line">pre-defined 0x54. So if SysRq doesn&apos;t work out of the box for a certain</span><br><span class="line">keyboard, run &apos;showkey -s&apos; to find out the proper scancode sequence. Then</span><br><span class="line">use &apos;setkeycodes &lt;sequence&gt; 84&apos; to define this sequence to the usual SysRq</span><br><span class="line">code (84 is decimal for 0x54). It&apos;s probably best to put this command in a</span><br><span class="line">boot script. Oh, and by the way, you exit &apos;showkey&apos; by not typing anything</span><br><span class="line">for ten seconds.</span><br><span class="line">*  I want to add SysRQ key events to a module, how does it work?</span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">In order to register a basic function with the table, you must first include</span><br><span class="line">the header &apos;include/linux/sysrq.h&apos;, this will define everything else you need.</span><br><span class="line">Next, you must create a sysrq_key_op struct, and populate it with A) the key</span><br><span class="line">handler function you will use, B) a help_msg string, that will print when SysRQ</span><br><span class="line">prints help, and C) an action_msg string, that will print right before your</span><br><span class="line">handler is called. Your handler must conform to the protoype in &apos;sysrq.h&apos;.</span><br><span class="line">After the sysrq_key_op is created, you can call the macro </span><br><span class="line">register_sysrq_key(int key, struct sysrq_key_op *op_p) that is defined in</span><br><span class="line">sysrq.h, this will register the operation pointed to by &apos;op_p&apos; at table</span><br><span class="line">key &apos;key&apos;, if that slot in the table is blank. At module unload time, you must</span><br><span class="line">call the macro unregister_sysrq_key(int key, struct sysrq_key_op *op_p), which</span><br><span class="line">will remove the key op pointed to by &apos;op_p&apos; from the key &apos;key&apos;, if and only if</span><br><span class="line">it is currently registered in that slot. This is in case the slot has been</span><br><span class="line">overwritten since you registered it.</span><br><span class="line">The Magic SysRQ system works by registering key operations against a key op</span><br><span class="line">lookup table, which is defined in &apos;drivers/char/sysrq.c&apos;. This key table has</span><br><span class="line">a number of operations registered into it at compile time, but is mutable,</span><br><span class="line">and 4 functions are exported for interface to it: __sysrq_lock_table,</span><br><span class="line">__sysrq_unlock_table, __sysrq_get_key_op, and __sysrq_put_key_op. The</span><br><span class="line">functions __sysrq_swap_key_ops and __sysrq_swap_key_ops_nolock are defined</span><br><span class="line">in the header itself, and the REGISTER and UNREGISTER macros are built from</span><br><span class="line">these. More complex (and dangerous!) manipulations of the table are possible</span><br><span class="line">using these functions, but you must be careful to always lock the table before</span><br><span class="line">you read or write from it, and to unlock it again when you are done. (And of</span><br><span class="line">course, to never ever leave an invalid pointer in the table). Null pointers in</span><br><span class="line">the table are always safe :)</span><br><span class="line">If for some reason you feel the need to call the handle_sysrq function from</span><br><span class="line">within a function called by handle_sysrq, you must be aware that you are in</span><br><span class="line">a lock (you are also in an interrupt handler, which means don&apos;t sleep!), so</span><br><span class="line">you must call __handle_sysrq_nolock instead.</span><br><span class="line">*  I have more questions, who can I ask?</span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">You may feel free to send email to myrdraal@deathsdoor.com, and I will</span><br><span class="line">respond as soon as possible.</span><br><span class="line"> -Myrdraal</span><br><span class="line">And I&apos;ll answer any questions about the registration system you got, also</span><br><span class="line">responding as soon as possible.</span><br><span class="line"> -Crutcher</span><br><span class="line">*  Credits</span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">Written by Mydraal &lt;myrdraal@deathsdoor.com&gt;</span><br><span class="line">Updated by Adam Sulmicki &lt;adam@cfar.umd.edu&gt;</span><br><span class="line">Updated by Jeremy M. Dolan &lt;jmd@turbogeek.org&gt; 2001/01/28 10:15:59</span><br><span class="line">Added to by Crutcher Dunnavant &lt;crutcher+kernel@datastacks.com&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;接触&lt;code&gt;SysRq&lt;/code&gt;完全是一种巧合。由于平时手比较欠，总是冷不丁地就将&lt;code&gt;ubuntu&lt;/code&gt;给整死机了，这要是在以前我大概是选择按下电源键重启了。但这样做的危害也是显而易见的，轻则数据丢失，重则系统直接挂掉重启一片
      
    
    </summary>
    
      <category term="linux" scheme="http://rqsir.github.io/categories/linux/"/>
    
    
      <category term="SysRq魔术键" scheme="http://rqsir.github.io/tags/SysRq%E9%AD%94%E6%9C%AF%E9%94%AE/"/>
    
  </entry>
  
  <entry>
    <title>java -- 自动拆装箱 &amp;&amp; 正则表达式</title>
    <link href="http://rqsir.github.io/2019/05/01/java-%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://rqsir.github.io/2019/05/01/java-自动拆装箱-正则表达式/</id>
    <published>2019-04-30T16:00:00.000Z</published>
    <updated>2019-05-21T02:39:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a>自动拆装箱</h2><p><strong>基本概念</strong></p><p>自动拆装箱是<code>jdk-1.５</code>引入的新特性，目的是为了简化<strong>包装类</strong>与对应<strong>基本数据类型</strong>之间的相互转化，这点有点类似<code>java</code>值类型的自动转换。举例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在java中我们可以进行如下赋值(自动装箱)</span></span><br><span class="line">Integer i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//而实际上，java底层为我们完成了如下操作：</span></span><br><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//也可以进行如下算术运算(自动拆箱)</span></span><br><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实际上，java会将i自动转换为int</span></span><br><span class="line"><span class="keyword">int</span> j = i.intValue() + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong>面试中相关问题</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">        Integer i1 = <span class="number">100</span>;</span><br><span class="line">        Integer i2 = <span class="number">100</span>;</span><br><span class="line">        Integer i3 = <span class="number">200</span>;</span><br><span class="line">        Integer i4 = <span class="number">200</span>;</span><br><span class="line">         </span><br><span class="line">        System.out.println(i1==i2);</span><br><span class="line">        System.out.println(i3==i4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line"><span class="keyword">true</span>  </span><br><span class="line"><span class="comment">//这里比较的是两个对象内存地址是否一样，因为Integer自动装箱的缓存机制([-128,127])，所以100自动装箱，指向的是同一个对象。</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="comment">//由于200已经超出[-128,127]范围，故重新new了两个对象，地址不一致</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">        Double i1 = <span class="number">100.0</span>;</span><br><span class="line">        Double i2 = <span class="number">100.0</span>;</span><br><span class="line">        Double i3 = <span class="number">200.0</span>;</span><br><span class="line">        Double i4 = <span class="number">200.0</span>;</span><br><span class="line">         </span><br><span class="line">        System.out.println(i1==i2);</span><br><span class="line">        System.out.println(i3==i4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="comment">//因为Double中不存在像Integer那样的缓存机制</span></span><br><span class="line"><span class="comment">//总结：</span></span><br><span class="line"><span class="comment">//Integer、Short、Byte、Character、Long这几个类的valueOf方法的实现是类似的(存在缓存)</span></span><br><span class="line"><span class="comment">//Double、Float的valueOf方法的实现是类似的(不存在缓存)</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">        Boolean i1 = <span class="keyword">false</span>;</span><br><span class="line">        Boolean i2 = <span class="keyword">false</span>;</span><br><span class="line">        Boolean i3 = <span class="keyword">true</span>;</span><br><span class="line">        Boolean i4 = <span class="keyword">true</span>;</span><br><span class="line">         </span><br><span class="line">        System.out.println(i1==i2);</span><br><span class="line">        System.out.println(i3==i4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="comment">//Boolean的自动装箱，生成的对象都是预先定义好的静态成员变量，如下：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean TRUE = <span class="keyword">new</span> Boolean(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean FALSE = <span class="keyword">new</span> Boolean(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">        Integer a = <span class="number">1</span>;</span><br><span class="line">        Integer b = <span class="number">2</span>;</span><br><span class="line">        Integer c = <span class="number">3</span>;</span><br><span class="line">        Integer d = <span class="number">3</span>;</span><br><span class="line">        Integer e = <span class="number">321</span>;</span><br><span class="line">        Integer f = <span class="number">321</span>;</span><br><span class="line">        Long g = <span class="number">3L</span>;</span><br><span class="line">        Long h = <span class="number">2L</span>;</span><br><span class="line">         </span><br><span class="line">        System.out.println(c==d);</span><br><span class="line">        System.out.println(e==f);</span><br><span class="line">        System.out.println(c==(a+b));</span><br><span class="line">        System.out.println(c.equals(a+b));</span><br><span class="line">        System.out.println(g==(a+b));</span><br><span class="line">        System.out.println(g.equals(a+b));</span><br><span class="line">        System.out.println(g.equals(a+h));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里对双目运算符“==”总结如下：</span></span><br><span class="line"><span class="number">1</span>.当“==”两端是同一数据类型时：若都为类类型，则比较地址；若都为值类型，则比较数值大小</span><br><span class="line"><span class="number">2</span>.当“==”两端数据类型不一致时：将“类类型”拆箱为“值类型”，即Integer转为<span class="keyword">int</span></span><br><span class="line"><span class="comment">//对“+”、“-”、“*”、“/”算术运算符总结如下：</span></span><br><span class="line">所有“类类型”统一转为“值类型”(统一拆箱)参与运算</span><br><span class="line"><span class="comment">//对equals()总结如下：</span></span><br><span class="line">  满足<span class="number">2</span>点，才返回<span class="keyword">true</span>：</span><br><span class="line"><span class="number">1</span>.数据类型一致（由于equals中形参类型是Object，若传入基本数据类型，会自动装箱，<span class="keyword">int</span>—&gt;Integer <span class="keyword">double</span> -&gt; Double,以此类推）</span><br><span class="line"><span class="number">2</span>.value相等</span><br><span class="line"></span><br><span class="line">输出为：</span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p><strong>什么是正则表达式</strong></p><p>可以简单的理解为：一种用于检测给定字符串是否满足特定规则的表达式</p><p><strong>常用正则表达式</strong></p><table><thead><tr><th style="text-align:center">正则表达式</th><th style="text-align:center">匹配规则</th></tr></thead><tbody><tr><td style="text-align:center">x</td><td style="text-align:center">字符x</td></tr><tr><td style="text-align:center">\</td><td style="text-align:center">反斜线字符</td></tr><tr><td style="text-align:center">[abc]</td><td style="text-align:center">a、b或c</td></tr><tr><td style="text-align:center">[^abc]</td><td style="text-align:center">除了a、b和c以外的任何字符</td></tr><tr><td style="text-align:center">[a-zA-Z]</td><td style="text-align:center">a 到 z 或 A 到 Z（两头字母包含在内）</td></tr><tr><td style="text-align:center">.</td><td style="text-align:center">任何字符（与行结束符可能匹配也可能不匹配）</td></tr><tr><td style="text-align:center">\d 或 [0-9]</td><td style="text-align:center">数字</td></tr><tr><td style="text-align:center">\D 或 [ ^0-9 ]</td><td style="text-align:center">非数字</td></tr><tr><td style="text-align:center">\s 或 [\t\n\x0B\f\r]</td><td style="text-align:center">空白字符</td></tr><tr><td style="text-align:center">\S 或 [ ^\s ]</td><td style="text-align:center">非空白字符</td></tr><tr><td style="text-align:center">\w 或 [a-zA-Z_0-9]</td><td style="text-align:center">单词字符</td></tr><tr><td style="text-align:center">\W 或 [ ^\w ]</td><td style="text-align:center">非单词字符</td></tr><tr><td style="text-align:center">X?</td><td style="text-align:center">X，一次或一次也没有</td></tr><tr><td style="text-align:center">X*</td><td style="text-align:center">X，零次或多次</td></tr><tr><td style="text-align:center">X+</td><td style="text-align:center">X，一次或多次</td></tr><tr><td style="text-align:center">X{n}</td><td style="text-align:center">X，恰好n次</td></tr><tr><td style="text-align:center">X{n, }</td><td style="text-align:center">X，至少n次</td></tr><tr><td style="text-align:center">X{n,m}</td><td style="text-align:center">X，至少n次，但是不超过m次</td></tr></tbody></table><p><strong>使用</strong></p><p>一般在<code>String</code>的成员函数<code>matches(String regex)</code> 中使用，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String QQ = <span class="string">"12345678"</span>;</span><br><span class="line"><span class="comment">//要求QQ不能以零开头，只能包含数字，位数不少于5不大于15；</span></span><br><span class="line"><span class="keyword">boolean</span> isValid = QQ.matches(<span class="string">"[1-9][0-9]&#123;4,14&#125;"</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;自动拆装箱&quot;&gt;&lt;a href=&quot;#自动拆装箱&quot; class=&quot;headerlink&quot; title=&quot;自动拆装箱&quot;&gt;&lt;/a&gt;自动拆装箱&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;基本概念&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;自动拆装箱是&lt;code&gt;jdk-1.５&lt;/code&gt;引入的新
      
    
    </summary>
    
      <category term="java-se" scheme="http://rqsir.github.io/categories/java-se/"/>
    
    
      <category term="java - 自动拆装箱" scheme="http://rqsir.github.io/tags/java-%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1/"/>
    
      <category term="正则表达式" scheme="http://rqsir.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>vscode 使用技巧</title>
    <link href="http://rqsir.github.io/2019/05/01/vscode-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>http://rqsir.github.io/2019/05/01/vscode-使用技巧/</id>
    <published>2019-04-30T16:00:00.000Z</published>
    <updated>2019-05-21T02:54:46.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>神器vscode，无需多言，但其默认配置往往有许多让人不满意的地方；本文着力于收集总结自己在使用vscode中遇到到一些配置设置和使用技巧，分享如下，同时会不定期更新</p></blockquote><h2 id="vscode-如何在新的tab打开文件"><a href="#vscode-如何在新的tab打开文件" class="headerlink" title="vscode 如何在新的tab打开文件"></a>vscode 如何在新的tab打开文件</h2><p>问题描述：</p><p>​ 每次在vscode中打开文件都会覆盖之前打开的标签</p><p>解决方法：</p><p>​ 按<code>ctrl+p</code>打开快速文件窗口，找到<code>settings.json</code>，在其中添加如下内容：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"workbench.editor.enablePreview": false,</span><br></pre></td></tr></table></figure><h2 id="vscode-如何修改所在行背景颜色"><a href="#vscode-如何修改所在行背景颜色" class="headerlink" title="vscode 如何修改所在行背景颜色"></a>vscode 如何修改所在行背景颜色</h2><p>问题描述：</p><p>​ vscode默认选中行背景色过浅，无法很好的识别</p><p>解决方法：</p><p>​ 按<code>ctrl+p</code>打开快速文件窗口，找到<code>settings.json</code>，在其中添加如下内容：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">"workbench.colorCustomizations": &#123;</span><br><span class="line">        "editor.lineHighlightBackground": "#00000000",</span><br><span class="line">         "editor.lineHighlightBorder": "#FF7F50CC"</span><br><span class="line">        &#125;,</span><br></pre></td></tr></table></figure><p>“editor.lineHighlightBackground”对应的是行背景十六进制：#000000(前6位为颜色)00(后2位为透明度)</p><p>“editor.lineHighlightBorder”对应边框色，其余设置一样</p><p><em>链接</em>：<br><a href="https://link.zhihu.com/?target=http%3A//www.sioe.cn/yingyong/yanse-rgb-16/" target="_blank" rel="noopener">RGB颜色值与十六进制颜色码转换工具</a><br><a href="https://link.zhihu.com/?target=https%3A//blog.csdn.net/sky1203850702/article/details/44916819" target="_blank" rel="noopener">透明度与十六进制代码转</a></p><h2 id="vscode常用快捷键"><a href="#vscode常用快捷键" class="headerlink" title="vscode常用快捷键"></a>vscode常用快捷键</h2><table><thead><tr><th style="text-align:center">快捷键</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">ctrl+shift+p</td><td style="text-align:center">打开命令行窗口</td></tr><tr><td style="text-align:center">ctrl+p</td><td style="text-align:center">打开快速文件窗口</td></tr><tr><td style="text-align:center">ctrl+shift+f</td><td style="text-align:center">在所有文件中查找</td></tr></tbody></table><h2 id="vscode关闭标题栏"><a href="#vscode关闭标题栏" class="headerlink" title="vscode关闭标题栏"></a>vscode关闭标题栏</h2><p>按<code>ctrl+p</code>打开快速文件窗口，找到<code>settings.json</code>，在其中添加如下内容：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"window.menuBarVisibility": "toggle",</span><br></pre></td></tr></table></figure><p>通过<code>alt</code>键进行切换</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;神器vscode，无需多言，但其默认配置往往有许多让人不满意的地方；本文着力于收集总结自己在使用vscode中遇到到一些配置设置和使用技巧，分享如下，同时会不定期更新&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;vscode-如何在新的tab打开
      
    
    </summary>
    
      <category term="IDE" scheme="http://rqsir.github.io/categories/IDE/"/>
    
    
      <category term="vscode" scheme="http://rqsir.github.io/tags/vscode/"/>
    
  </entry>
  
  <entry>
    <title>java -- 包装类</title>
    <link href="http://rqsir.github.io/2019/05/01/java-%E5%8C%85%E8%A3%85%E7%B1%BB/"/>
    <id>http://rqsir.github.io/2019/05/01/java-包装类/</id>
    <published>2019-04-30T16:00:00.000Z</published>
    <updated>2019-05-21T02:34:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是包装类"><a href="#什么是包装类" class="headerlink" title="什么是包装类"></a>什么是包装类</h2><p>包装类可以简单理解为对<code>基本数据类型</code>的功能拓展，最终以封装为<code>class</code>的形式呈现。这是因为八大基本数据类型只能完成基本的算术或逻辑操作，无法实现诸如“字符串转换”等特殊操作。在以上背景下，包装类应运而生。</p><h2 id="包装类分类"><a href="#包装类分类" class="headerlink" title="包装类分类"></a>包装类分类</h2><p>根据八大基本数据类型，包装类相应的可以分为八类，具体如下：</p><table><thead><tr><th style="text-align:center">基本数据类型</th><th style="text-align:center">对应包装类</th></tr></thead><tbody><tr><td style="text-align:center">int</td><td style="text-align:center"><strong>Integer</strong></td></tr><tr><td style="text-align:center">byte</td><td style="text-align:center">Byte</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">Short</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">Long</td></tr><tr><td style="text-align:center">char</td><td style="text-align:center"><strong>Character</strong></td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">Float</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">Double</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">Boolean</td></tr></tbody></table><h2 id="包装类详解（以Integer为例）"><a href="#包装类详解（以Integer为例）" class="headerlink" title="包装类详解（以Integer为例）"></a>包装类详解（以Integer为例）</h2><p><strong>所在包</strong></p><p>该类位于<code>java.lang</code>包下，使用时无需导包。</p><p><strong>简述</strong></p><p>先看一段<code>JDK</code>关于<code>Integer</code>的注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The &#123;<span class="doctag">@code</span> Integer&#125; class wraps a value of the primitive type</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> int&#125; in an object. An object of type &#123;<span class="doctag">@code</span> Integer&#125;</span></span><br><span class="line"><span class="comment"> * contains a single field whose type is &#123;<span class="doctag">@code</span> int&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;In addition, this class provides several methods for converting</span></span><br><span class="line"><span class="comment"> * an &#123;<span class="doctag">@code</span> int&#125; to a &#123;<span class="doctag">@code</span> String&#125; and a &#123;<span class="doctag">@code</span> String&#125; to an</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> int&#125;, as well as other constants and methods useful when</span></span><br><span class="line"><span class="comment"> * dealing with an &#123;<span class="doctag">@code</span> int&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>大体上是说，这是一个包含唯一类字段的类；类字段为<code>int</code>型，用来存储<code>int</code>型变量。除此之外，该类还提供了一些诸如<code>int</code>与<code>String</code>之间相互转换的方法，用于实现一些常见操作。</p><p><strong>构造方法</strong></p><p>有2个有参构造方法，分别为：<code>Integer(int)</code>和<code>Integer(String)</code>。<code>JDK</code>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a newly allocated &#123;<span class="doctag">@code</span> Integer&#125; object that</span></span><br><span class="line"><span class="comment">     * represents the specified &#123;<span class="doctag">@code</span> int&#125; value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   value   the value to be represented by the</span></span><br><span class="line"><span class="comment">     *                  &#123;<span class="doctag">@code</span> Integer&#125; object.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Integer</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a newly allocated &#123;<span class="doctag">@code</span> Integer&#125; object that</span></span><br><span class="line"><span class="comment">     * represents the &#123;<span class="doctag">@code</span> int&#125; value indicated by the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> String&#125; parameter. The string is converted to an</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> int&#125; value in exactly the manner used by the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> parseInt&#125; method for radix 10.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>      s   the &#123;<span class="doctag">@code</span> String&#125; to be converted to an</span></span><br><span class="line"><span class="comment">     *                 &#123;<span class="doctag">@code</span> Integer&#125;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@exception</span>  NumberFormatException  if the &#123;<span class="doctag">@code</span> String&#125; does not</span></span><br><span class="line"><span class="comment">     *               contain a parsable integer.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>        java.lang.Integer#parseInt(java.lang.String, int)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Integer</span><span class="params">(String s)</span> <span class="keyword">throws</span> NumberFormatException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = parseInt(s, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先来看<code>Integer(int)</code>，该方法是根据一个形参<code>int</code>实例化一个<code>Integer</code>对象，内部细节就是将形参<code>int</code>赋值给<code>Integer</code>的类字段<code>value</code>。</p><p>再来看<code>Integer(String)</code>，该方法使用一个<code>String</code>类型对象实例化<code>Integer</code>。内部实现稍微复杂一点点，先是用<code>Integer</code>静态成员方法将<code>String</code>转化为对应<code>int</code>值，然后再将获得的<code>int</code>值赋值给<code>Integer</code>类字段<code>value</code>。</p><p><strong>成员方法</strong></p><p>由于在实际开发中，我们用的最多的无非就是<code>String</code>与<code>int</code>的相互转化。因此，接着来我们主要总结一下这方面的成员方法。</p><table><thead><tr><th style="text-align:center">用途</th><th style="text-align:center">静态成员方法</th><th style="text-align:center">非静态成员方法</th></tr></thead><tbody><tr><td style="text-align:center"><code>String</code> –&gt; <code>int</code></td><td style="text-align:center"><code>parseInt(String s)</code><br><code>parseInt(String s, int radix)</code></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><code>int</code> –&gt; <code>String</code></td><td style="text-align:center"><code>toString(int i)</code><br><code>toString(int i, int radix)</code></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><code>String</code> –&gt; <code>Integer</code></td><td style="text-align:center"><code>valueOf(String s)</code><br><code>valueOf(String s, int radix)</code><br></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><code>Integer</code> –&gt; <code>String</code></td><td style="text-align:center"></td><td style="text-align:center"><code>toString()</code></td></tr><tr><td style="text-align:center"><code>int</code> –&gt; <code>Integer</code></td><td style="text-align:center"><code>valueOf(int i)</code></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><code>Integer</code> –&gt; <code>int</code></td><td style="text-align:center"></td><td style="text-align:center"><code>intValue()</code></td></tr></tbody></table><p>另外，在阅读<code>Integer</code>源码中，发现了两个好玩的成员方法<code>reverse(int i)</code>和<code>rotateLeft(int i, int distance)</code>，其中对于<code>bit</code>的操作很有启发性，现直接将源码贴在下方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns the value obtained by reversing the order of the bits in the</span></span><br><span class="line"><span class="comment">    * two's complement binary representation of the specified &#123;<span class="doctag">@code</span> int&#125;</span></span><br><span class="line"><span class="comment">    * value.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> i the value to be reversed</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the value obtained by reversing order of the bits in the</span></span><br><span class="line"><span class="comment">    *     specified &#123;<span class="doctag">@code</span> int&#125; value.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// HD, Figure 7-1</span></span><br><span class="line">       <span class="comment">// 举个例子：对于一个字节"abcdefgh"</span></span><br><span class="line">       i = (i &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span> | (i &gt;&gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>; <span class="comment">// abcd efgh --&gt; badc fehg</span></span><br><span class="line">       i = (i &amp; <span class="number">0x33333333</span>) &lt;&lt; <span class="number">2</span> | (i &gt;&gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>; <span class="comment">// badc fehg --&gt; dcba hgfe</span></span><br><span class="line">       i = (i &amp; <span class="number">0x0f0f0f0f</span>) &lt;&lt; <span class="number">4</span> | (i &gt;&gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0f0f0f0f</span>; <span class="comment">// dcba hgfe --&gt; hgfe dcba</span></span><br><span class="line">       <span class="comment">// 下面是完成4个字节的反向 1 &lt;--&gt; 4  以及  2 &lt;--&gt; 3</span></span><br><span class="line">       i = (i &lt;&lt; <span class="number">24</span>) | ((i &amp; <span class="number">0xff00</span>) &lt;&lt; <span class="number">8</span>) |</span><br><span class="line">           ((i &gt;&gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff00</span>) | (i &gt;&gt;&gt; <span class="number">24</span>);</span><br><span class="line">       <span class="keyword">return</span> i;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns the value obtained by rotating the two's complement binary</span></span><br><span class="line"><span class="comment">    * representation of the specified &#123;<span class="doctag">@code</span> int&#125; value left by the</span></span><br><span class="line"><span class="comment">    * specified number of bits.  (Bits shifted out of the left hand, or</span></span><br><span class="line"><span class="comment">    * high-order, side reenter on the right, or low-order.)</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Note that left rotation with a negative distance is equivalent to</span></span><br><span class="line"><span class="comment">    * right rotation: &#123;<span class="doctag">@code</span> rotateLeft(val, -distance) == rotateRight(val,</span></span><br><span class="line"><span class="comment">    * distance)&#125;.  Note also that rotation by any multiple of 32 is a</span></span><br><span class="line"><span class="comment">    * no-op, so all but the last five bits of the rotation distance can be</span></span><br><span class="line"><span class="comment">    * ignored, even if the distance is negative: &#123;<span class="doctag">@code</span> rotateLeft(val,</span></span><br><span class="line"><span class="comment">    * distance) == rotateLeft(val, distance &amp; 0x1F)&#125;.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> i the value whose bits are to be rotated left</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> distance the number of bit positions to rotate left</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the value obtained by rotating the two's complement binary</span></span><br><span class="line"><span class="comment">    *     representation of the specified &#123;<span class="doctag">@code</span> int&#125; value left by the</span></span><br><span class="line"><span class="comment">    *     specified number of bits.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rotateLeft</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> distance)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> (i &lt;&lt; distance) | (i &gt;&gt;&gt; -distance);</span><br><span class="line">       <span class="comment">// i &gt;&gt;&gt; -distance 意思是</span></span><br><span class="line">       <span class="comment">// 如果 distance &gt; 0: i &gt;&gt;&gt; -distance = i &gt;&gt;&gt; (32-(distance % 32)) </span></span><br><span class="line">       <span class="comment">// 如果 distance &lt; 0: 与普通 i &gt;&gt;&gt; 正数 并无二致</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是包装类&quot;&gt;&lt;a href=&quot;#什么是包装类&quot; class=&quot;headerlink&quot; title=&quot;什么是包装类&quot;&gt;&lt;/a&gt;什么是包装类&lt;/h2&gt;&lt;p&gt;包装类可以简单理解为对&lt;code&gt;基本数据类型&lt;/code&gt;的功能拓展，最终以封装为&lt;code&gt;class&lt;
      
    
    </summary>
    
      <category term="java-se" scheme="http://rqsir.github.io/categories/java-se/"/>
    
    
      <category term="java - 包装类" scheme="http://rqsir.github.io/tags/java-%E5%8C%85%E8%A3%85%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>java -- 内部类</title>
    <link href="http://rqsir.github.io/2019/04/29/java-%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <id>http://rqsir.github.io/2019/04/29/java-内部类/</id>
    <published>2019-04-28T16:00:00.000Z</published>
    <updated>2019-05-21T02:32:22.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>java中的内部类，按类型看大致可以分为3类，分别是：<code>成员内部类</code>、<code>局部内部类</code>以及<code>匿名内部类</code></p></blockquote><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>形式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是外部内中的方法speak"</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">tell</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"我是成员内部类中的方法tell"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>外部类<code>Outer</code>中位于成员位置，再定义一个类<code>Inner</code>，这个类就是<code>Outer</code>的内部类。</p><p>内部类在编译时，会生成自己对应的class文件，但它的访问要通过其外部类完成。</p><p>这里，我们要运行内部类<code>Inner</code>中的<code>tell</code>方法，流程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.首先，要访问成员内部类，我们得先得到外部类`Outer`的对象</span></span><br><span class="line">        Outer o = <span class="keyword">new</span> Outer();</span><br><span class="line">        <span class="comment">//2.然后，通过外部类对象`o`得到内部类`Inner`</span></span><br><span class="line">        Inner i = o.new Inner();</span><br><span class="line">        <span class="comment">//3.通过内部类对象`i`调用内部类方法`tell`</span></span><br><span class="line">        i.tell();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//以上可以简写为</span></span><br><span class="line">        <span class="keyword">new</span> Outer().new Inner().tell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果，我们给<code>Inner</code>加上<code>static</code>修饰符，那么我们就能通过<code>Outer.Inner</code>调用内部类的class。进一步，要想获得<code>Inner</code>的对象，可以通过<code>Outer.new Inner()</code>获得。如果，<code>Inner</code>中的<code>tell</code>方法也加上<code>static</code>修饰符，我们直接通过<code>Outer.Inner.tell()</code>，就可以执行<code>tell</code>方法，整个过程没有实例化任何对象。</p><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>顾名思义，和局部变量类似，局部内部类是存在与方法体中的类，形式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是外部内中的方法speak"</span>);</span><br><span class="line">        </span><br><span class="line">         <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">tell</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"我是成员内部类中的方法tell"</span>);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//实例化局部内部类`Inner`，并调用其中的方法`tell`</span></span><br><span class="line">        Inner i = <span class="keyword">new</span> Inner();</span><br><span class="line">        i.tell();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>局部内部类的作用域范围仅局限于方法内部，出了方法之后就无法使用了</p><p>因此，无法在其他类，例如测试类<code>Test</code>中实例化局部内部类<code>Inner</code>，更不用说调用其中的<code>tell</code>方法了。</p><p>唯一的途径是，直接在<code>Inner</code>所在的方法体中，实例化<code>Inner</code>对象<code>i</code>，然后调用<code>tell</code>方法，如上所示。</p><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p><strong>特点</strong></p><ul><li>可以看做是一种没有名字的局部内部类</li><li>定义在方法中</li><li>必须在定义匿名内部类时创建它的对象</li></ul><p><strong>格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 类/接口()&#123;</span><br><span class="line">    如果是创建了继承这个类的子类对象，我们可以重写父类的方法</span><br><span class="line">    如果是创建了实现这个接口的子类对象，我们必须实现接口的全部抽象方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理：创建了<code>继承了这个类</code>的子类对象或者<code>实现了这个接口</code>的子类对象</p><p><strong>应用场景</strong></p><p>​ 作为参数进行传递，因为只使用一次，无需专门写一个java文件继承父类或接口，直接通过匿名内部类的方式比较简洁。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;java中的内部类，按类型看大致可以分为3类，分别是：&lt;code&gt;成员内部类&lt;/code&gt;、&lt;code&gt;局部内部类&lt;/code&gt;以及&lt;code&gt;匿名内部类&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;成员内部类&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="java-se" scheme="http://rqsir.github.io/categories/java-se/"/>
    
    
      <category term="java - 内部类" scheme="http://rqsir.github.io/tags/java-%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>java API -- Date &amp;&amp; SimpleDateFormat &amp;&amp; Calendar</title>
    <link href="http://rqsir.github.io/2019/04/29/java-API-Date-SimpleDateFormat-Calendar/"/>
    <id>http://rqsir.github.io/2019/04/29/java-API-Date-SimpleDateFormat-Calendar/</id>
    <published>2019-04-28T16:00:00.000Z</published>
    <updated>2019-05-18T17:12:33.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>java中有一种特殊的对象，我们平时都是通过字符串的形式使用它，但在底层却时不时涉及到一些数字运算；除此之外，我们对它的字符串输出形式，往往还是百般挑剔，猜猜它是谁？</p><p>：-）没错，它就是java中的Date对象</p></blockquote><p>java <code>API</code>下为我们封装了有关时间和日期操作了相关函数，总结如下：</p><h2 id="Date类-–-日期获取的好帮手"><a href="#Date类-–-日期获取的好帮手" class="headerlink" title="Date类 – 日期获取的好帮手"></a>Date类 – 日期获取的好帮手</h2><p>首先，学习一个类，大致分为以下几个步骤：</p><ol><li>看类所在<code>package</code>，如果在<code>java.lang</code>包下，则使用时可以省去导包操作。</li><li>接着看类的说明，了解类的大致用途即可。</li><li>查看类的构造函数</li><li>查看类的常用成员方法</li></ol><p>好，我们按照上述步骤，来学习一下<code>Date</code>。</p><h3 id="所在package"><a href="#所在package" class="headerlink" title="所在package"></a>所在package</h3><p>由<code>package java.util;</code>可知，<code>Date</code>包位于<code>java.util</code>包下，所有使用时需要导包。</p><h3 id="类的介绍"><a href="#类的介绍" class="headerlink" title="类的介绍"></a>类的介绍</h3><p>查看源码注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The class &lt;code&gt;Date&lt;/code&gt; represents a specific instant</span></span><br><span class="line"><span class="comment"> * in time, with millisecond precision.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Prior to JDK&amp;nbsp;1.1, the class &lt;code&gt;Date&lt;/code&gt; had two additional</span></span><br><span class="line"><span class="comment"> * functions.  It allowed the interpretation of dates as year, month, day, hour,</span></span><br><span class="line"><span class="comment"> * minute, and second values.  It also allowed the formatting and parsing</span></span><br><span class="line"><span class="comment"> * of date strings.  Unfortunately, the API for these functions was not</span></span><br><span class="line"><span class="comment"> * amenable to internationalization.  As of JDK&amp;nbsp;1.1, the</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;Calendar&lt;/code&gt; class should be used to convert between dates and time</span></span><br><span class="line"><span class="comment"> * fields and the &lt;code&gt;DateFormat&lt;/code&gt; class should be used to format and</span></span><br><span class="line"><span class="comment"> * parse date strings.</span></span><br><span class="line"><span class="comment"> * The corresponding methods in &lt;code&gt;Date&lt;/code&gt; are deprecated.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>首先，它告诉我们：<code>Date</code>是用来表示一个以毫秒为单位的确定时刻的类。<code>Date</code>可以表征“年”、“月”、“日”、“时”、“分”和“秒”。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>由于一些方法已经过时，这里我们只提及两个常用的构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Allocates a &lt;code&gt;Date&lt;/code&gt; object and initializes it so that</span></span><br><span class="line"><span class="comment">     * it represents the time at which it was allocated, measured to the</span></span><br><span class="line"><span class="comment">     * nearest millisecond.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     java.lang.System#currentTimeMillis()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Date</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Allocates a &lt;code&gt;Date&lt;/code&gt; object and initializes it to</span></span><br><span class="line"><span class="comment">     * represent the specified number of milliseconds since the</span></span><br><span class="line"><span class="comment">     * standard base time known as "the epoch", namely January 1,</span></span><br><span class="line"><span class="comment">     * 1970, 00:00:00 GMT.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   date   the milliseconds since January 1, 1970, 00:00:00 GMT.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     java.lang.System#currentTimeMillis()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Date</span><span class="params">(<span class="keyword">long</span> date)</span> </span>&#123;</span><br><span class="line">        fastTime = date;  <span class="comment">// fastTime 是成员变量</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>空参构造方法<code>Date()</code>用来初始化一个<code>Date</code>对象，其时间基准线为<code>jvm</code>运行环境的当前时间，也就是说这个<code>Date</code>对象的时间值与当前时间一致。</p><p>有参构造方法<code>Date(long date)</code>用来初始化一个相对时间基准线，时间值为<code>long date</code>的<code>Date</code>对象。其中，时间基准线为<code>1970-1-1 00:00:00</code>，俗称“计算机元年”。举个例子，<code>Date(1000)</code>代表的是<code>1970-1-1 00:00:01</code>这个时刻。</p><h3 id="常用成员方法"><a href="#常用成员方法" class="headerlink" title="常用成员方法"></a>常用成员方法</h3><p>这里我们介绍两个常用成员函数<code>setTime()</code>和<code>getTime()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Sets this &lt;code&gt;Date&lt;/code&gt; object to represent a point in time that is</span></span><br><span class="line"><span class="comment">    * &lt;code&gt;time&lt;/code&gt; milliseconds after January 1, 1970 00:00:00 GMT.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>   time   the number of milliseconds.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTime</span><span class="params">(<span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">       fastTime = time;</span><br><span class="line">       cdate = <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns the number of milliseconds since January 1, 1970, 00:00:00 GMT</span></span><br><span class="line"><span class="comment">    * represented by this &lt;tt&gt;Date&lt;/tt&gt; object.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  the number of milliseconds since January 1, 1970, 00:00:00 GMT</span></span><br><span class="line"><span class="comment">    *          represented by this date.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> getTimeImpl();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getTimeImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (cdate != <span class="keyword">null</span> &amp;&amp; !cdate.isNormalized()) &#123;</span><br><span class="line">           normalize();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> fastTime;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>其中<code>setTime(long time)</code>用来设置时间，参数<code>time</code>为相对于“1970-1-1 00:00:00”的时间值，单位为毫秒。</p><p>而<code>getTime()</code>代表的是当前时间的毫秒值，同样是相对于“1970-1-1 00:00:00”。</p><h2 id="SimpleDateFormat类-–-日期格式化-amp-解析神器"><a href="#SimpleDateFormat类-–-日期格式化-amp-解析神器" class="headerlink" title="SimpleDateFormat类 – 日期格式化&amp;解析神器"></a>SimpleDateFormat类 – 日期格式化&amp;解析神器</h2><h3 id="所在包"><a href="#所在包" class="headerlink" title="所在包"></a>所在包</h3><p><code>SimpleDateFormat</code>位于包<code>java.text</code>下，使用前需要导包。</p><h3 id="类概述"><a href="#类概述" class="headerlink" title="类概述"></a>类概述</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;SimpleDateFormat&lt;/code&gt; is a concrete class for formatting and</span></span><br><span class="line"><span class="comment"> * parsing dates in a locale-sensitive manner. It allows for formatting</span></span><br><span class="line"><span class="comment"> * (date &amp;rarr; text), parsing (text &amp;rarr; date), and normalization.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br></pre></td></tr></table></figure><p>大意是说：<code>SimpleDateFormat</code>是一个用来格式化<code>Date</code>（输入为<code>Date</code>，输出为<code>String</code>），以及解析Date字符串（输入为<code>String</code>，输出为<code>Date</code>）的具体类。<code>SimpleDateFormat</code>特色是支持用户自定义格式，格式化<code>Date</code>。</p><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><p>这里我们主要讲解两个常用构造方法，分别是：空参构造方法<code>SimpleDateFormat()</code>，以及有参构造方法<code>SimpleDateFormat(String)</code>。</p><p>下面是它们的jdk源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constructs a &lt;code&gt;SimpleDateFormat&lt;/code&gt; using the default pattern and</span></span><br><span class="line"><span class="comment">    * date format symbols for the default</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> java.util.Locale.Category#FORMAT FORMAT&#125; locale.</span></span><br><span class="line"><span class="comment">    * &lt;b&gt;Note:&lt;/b&gt; This constructor may not support all locales.</span></span><br><span class="line"><span class="comment">    * For full coverage, use the factory methods in the &#123;<span class="doctag">@link</span> DateFormat&#125;</span></span><br><span class="line"><span class="comment">    * class.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">SimpleDateFormat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(<span class="string">""</span>, Locale.getDefault(Locale.Category.FORMAT));           applyPatternImpl(LocaleProviderAdapter.getResourceBundleBased().getLocaleResources(locale).getDateTimePattern(SHORT, SHORT, calendar));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constructs a &lt;code&gt;SimpleDateFormat&lt;/code&gt; using the given pattern and</span></span><br><span class="line"><span class="comment">    * the default date format symbols for the default</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> java.util.Locale.Category#FORMAT FORMAT&#125; locale.</span></span><br><span class="line"><span class="comment">    * &lt;b&gt;Note:&lt;/b&gt; This constructor may not support all locales.</span></span><br><span class="line"><span class="comment">    * For full coverage, use the factory methods in the &#123;<span class="doctag">@link</span> DateFormat&#125;</span></span><br><span class="line"><span class="comment">    * class.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;This is equivalent to calling</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> #SimpleDateFormat(String, Locale)</span></span><br><span class="line"><span class="comment">    *     SimpleDateFormat(pattern, Locale.getDefault(Locale.Category.FORMAT))&#125;.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> java.util.Locale#getDefault(java.util.Locale.Category)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> java.util.Locale.Category#FORMAT</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> pattern the pattern describing the date and time format</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@exception</span> NullPointerException if the given pattern is null</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@exception</span> IllegalArgumentException if the given pattern is invalid</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">SimpleDateFormat</span><span class="params">(String pattern)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(pattern, Locale.getDefault(Locale.Category.FORMAT));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>其中，空参构造方法<code>SimpleDateFormat()</code>是以默认格式<code>Sun Apr 28 20:45:54 CST 2019</code>构造<code>SimpleDateFormat</code>对象，在之后的<code>format</code>过程中，会以这个格式来生成对应的字符串。</p><p>而有参构造方法<code>SimpleDateFormat(String)</code>，则是用给定的格式（如：yyyy:MM:dd HH:mm:ss）来生成对应<code>SimpleDateFormat</code>对象，在之后的<code>format</code>过程中，会以这个格式来生成对应的字符串。</p><h3 id="常用成员方法-1"><a href="#常用成员方法-1" class="headerlink" title="常用成员方法"></a>常用成员方法</h3><p>这里要注意一下，我们一般不怎么使用<code>SimpleDateFormat</code>自己特有的成员方法；相反，我们比较爱用其继承于父类<code>DateFormat</code>的方法<code>formate(Date)</code>和<code>parse(String)</code>。</p><p>相关源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Formats a Date into a date/time string.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> date the time value to be formatted into a time string.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the formatted time string.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">format</span><span class="params">(Date date)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> format(date, <span class="keyword">new</span> StringBuffer(),</span><br><span class="line">                      DontCareFieldPosition.INSTANCE).toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Parses text from the beginning of the given string to produce a date.</span></span><br><span class="line"><span class="comment">     * The method may not use the entire text of the given string.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * See the &#123;<span class="doctag">@link</span> #parse(String, ParsePosition)&#125; method for more information</span></span><br><span class="line"><span class="comment">     * on date parsing.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source A &lt;code&gt;String&lt;/code&gt; whose beginning should be parsed.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A &lt;code&gt;Date&lt;/code&gt; parsed from the string.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@exception</span> ParseException if the beginning of the specified string</span></span><br><span class="line"><span class="comment">     *            cannot be parsed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">parse</span><span class="params">(String source)</span> <span class="keyword">throws</span> ParseException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ParsePosition pos = <span class="keyword">new</span> ParsePosition(<span class="number">0</span>);</span><br><span class="line">        Date result = parse(source, pos);</span><br><span class="line">        <span class="keyword">if</span> (pos.index == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ParseException(<span class="string">"Unparseable date: \""</span> + source + <span class="string">"\""</span> ,</span><br><span class="line">                pos.errorIndex);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从以上代码可知，方法<code>format</code>主要完成了<code>Date</code>对象到指定格式字符串的转换；而<code>parse</code>方法主要完成了<code>String</code>对象到<code>Date</code>对象的转化。</p><h2 id="Calendar类-–-日期操作的手术刀"><a href="#Calendar类-–-日期操作的手术刀" class="headerlink" title="Calendar类 – 日期操作的手术刀"></a>Calendar类 – 日期操作的手术刀</h2><h3 id="所在包-1"><a href="#所在包-1" class="headerlink" title="所在包"></a>所在包</h3><p>位于<code>java.util</code>包下，使用前需执行导包操作。</p><h3 id="类简述"><a href="#类简述" class="headerlink" title="类简述"></a>类简述</h3><p>见看一段jdk英文注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The &lt;code&gt;Calendar&lt;/code&gt; class is an abstract class that provides methods</span></span><br><span class="line"><span class="comment"> * for converting between a specific instant in time and a set of &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * #fields calendar fields&#125; such as &lt;code&gt;YEAR&lt;/code&gt;, &lt;code&gt;MONTH&lt;/code&gt;,</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;DAY_OF_MONTH&lt;/code&gt;, &lt;code&gt;HOUR&lt;/code&gt;, and so on, and for</span></span><br><span class="line"><span class="comment"> * manipulating the calendar fields, such as getting the date of the next</span></span><br><span class="line"><span class="comment"> * week. An instant in time can be represented by a millisecond value that is</span></span><br><span class="line"><span class="comment"> * an offset from the &lt;a name="Epoch"&gt;&lt;em&gt;Epoch&lt;/em&gt;&lt;/a&gt;, January 1, 1970</span></span><br><span class="line"><span class="comment"> * 00:00:00.000 GMT (Gregorian).</span></span><br></pre></td></tr></table></figure><p>翻译过来，大致意思就是：<code>Calendar</code>是一个在“年”、“月”、“日”、“时”等日历属性，以及时间点（以毫秒为单位）之间进行转化的一个工具类。它可以对“年”、“月”、“日”、“时”等日历属性进行相关算术运算，最终反应在<code>Date</code>中的就是属性值<code>fastTime</code>的变化（即毫秒值的变化）。</p><h3 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h3><p><code>Calendar</code>构造函数有两个，分别为<code>Calendar()</code>以及<code>Calendar(TimeZone zone, Locale aLocale)</code>，但平时使用中我们基本不用。</p><p>实例化<code>Calendar</code>类，我们一般选择使用ta的静态成员方法<code>getInstance()</code>，实例化的是其子类对象。原因是：我们使用的某些成员方法如<code>add(int, int)</code>，它的实现是在<code>Calendar</code>的子类中完成的，这里用到了多态的向上转型。相应源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Gets a calendar using the default time zone and locale. The</span></span><br><span class="line"><span class="comment">    * &lt;code&gt;Calendar&lt;/code&gt; returned is based on the current time</span></span><br><span class="line"><span class="comment">    * in the default time zone with the default</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> Locale.Category#FORMAT FORMAT&#125; locale.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> a Calendar.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Calendar <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> createCalendar(TimeZone.getDefault(),     Locale.getDefault(Locale.Category.FORMAT));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>需要注意的是：通过<code>getInstance()</code>方法获取的<code>Calendar</code>子类对象，其时间值是相对“计算机元年”而言的。</p><h3 id="常用成员方法-2"><a href="#常用成员方法-2" class="headerlink" title="常用成员方法"></a>常用成员方法</h3><p>这里，我们主要讲解“查询”、“设置”、“修改”<code>calendar</code>指定字段(<code>filed</code>)的成员方法。它们分别对应为：<code>get(int)</code>方法、<code>set(int,int)</code>方法、<code>add(int,int)</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value of the given calendar field. In lenient mode,</span></span><br><span class="line"><span class="comment">     * all calendar fields are normalized. In non-lenient mode, all</span></span><br><span class="line"><span class="comment">     * calendar fields are validated and this method throws an</span></span><br><span class="line"><span class="comment">     * exception if any calendar fields have out-of-range values. The</span></span><br><span class="line"><span class="comment">     * normalization and validation are handled by the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #complete()&#125; method, which process is calendar</span></span><br><span class="line"><span class="comment">     * system dependent.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> field the given calendar field.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the value for the given calendar field.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ArrayIndexOutOfBoundsException if the specified field is out of range</span></span><br><span class="line"><span class="comment">     *             (&lt;code&gt;field &amp;lt; 0 || field &amp;gt;= FIELD_COUNT&lt;/code&gt;).</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #set(int,int)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #complete()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> field)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        complete();</span><br><span class="line">        <span class="keyword">return</span> internalGet(field);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the given calendar field to the given value. The value is not</span></span><br><span class="line"><span class="comment">     * interpreted by this method regardless of the leniency mode.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> field the given calendar field.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value the value to be set for the given calendar field.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ArrayIndexOutOfBoundsException if the specified field is out of range</span></span><br><span class="line"><span class="comment">     *             (&lt;code&gt;field &amp;lt; 0 || field &amp;gt;= FIELD_COUNT&lt;/code&gt;).</span></span><br><span class="line"><span class="comment">     * in non-lenient mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #set(int,int,int)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #set(int,int,int,int,int)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #set(int,int,int,int,int,int)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #get(int)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> field, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// If the fields are partially normalized, calculate all the</span></span><br><span class="line">        <span class="comment">// fields before changing any fields.</span></span><br><span class="line">        <span class="keyword">if</span> (areFieldsSet &amp;&amp; !areAllFieldsSet) &#123;</span><br><span class="line">            computeFields();</span><br><span class="line">        &#125;</span><br><span class="line">        internalSet(field, value);</span><br><span class="line">        isTimeSet = <span class="keyword">false</span>;</span><br><span class="line">        areFieldsSet = <span class="keyword">false</span>;</span><br><span class="line">        isSet[field] = <span class="keyword">true</span>;</span><br><span class="line">        stamp[field] = nextStamp++;</span><br><span class="line">        <span class="keyword">if</span> (nextStamp == Integer.MAX_VALUE) &#123;</span><br><span class="line">            adjustStamp();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Adds or subtracts the specified amount of time to the given calendar field,</span></span><br><span class="line"><span class="comment">     * based on the calendar's rules. For example, to subtract 5 days from</span></span><br><span class="line"><span class="comment">     * the current time of the calendar, you can achieve it by calling:</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;&lt;code&gt;add(Calendar.DAY_OF_MONTH, -5)&lt;/code&gt;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> field the calendar field.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> amount the amount of date or time to be added to the field.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #roll(int,int)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #set(int,int)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> field, <span class="keyword">int</span> amount)</span></span>;</span><br></pre></td></tr></table></figure><p>先说<code>get(int)</code>方法，这个方法主要通过指定<code>int</code>型字段来获取相应字段的整数型值。例如，<code>get(Calendar.YEAR)</code>返回的就是当前系统的年份值。</p><p>常用的字段总结如下：</p><table><thead><tr><th style="text-align:center">字段名</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">YEAR</td><td style="text-align:center">年份</td></tr><tr><td style="text-align:center">MONTH</td><td style="text-align:center">月份</td></tr><tr><td style="text-align:center">DAY_OF_MONTH</td><td style="text-align:center">月份中的日子</td></tr><tr><td style="text-align:center">HOUR_OF_DAY</td><td style="text-align:center">一天中的小时</td></tr><tr><td style="text-align:center">MINUTE</td><td style="text-align:center">小时中的分钟</td></tr><tr><td style="text-align:center">SECOND</td><td style="text-align:center">分钟中的秒</td></tr></tbody></table><p>接着谈谈<code>set(int field, int value)</code>方法，这个方法是给指定字段设置给定值。例如，我们可以将月份设置为一月，即<code>set(Calendar.MONTH, Calendar.JANUARY)</code>或者<code>set(Calendar.MONTH, 0)</code>（因为这里采用的是格里高利纪年法，0表示一月）。</p><p>最后轮到<code>add(int field, int amount)</code>了，这个方法和<code>set(int ,int )</code>方法的区别有点类似“绝对路径”和“相对路径”的关系。<code>add</code>方法更加偏向于通过运算（相对与当前字段而言）来更改字段值。举个栗子：如果当前月份是二月，我们向将其改为三月，可以这样<code>add(Calendar.MONTH, 1)</code>；如果我们想将其改为一月，可以这样<code>add(Calendar.MONTH, -1)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;java中有一种特殊的对象，我们平时都是通过字符串的形式使用它，但在底层却时不时涉及到一些数字运算；除此之外，我们对它的字符串输出形式，往往还是百般挑剔，猜猜它是谁？&lt;/p&gt;&lt;p&gt;：-）没错，它就是java中的Date对象&lt;/p&gt;&lt;/blockquo
      
    
    </summary>
    
      <category term="java-se" scheme="http://rqsir.github.io/categories/java-se/"/>
    
    
      <category term="java - Date" scheme="http://rqsir.github.io/tags/java-Date/"/>
    
      <category term="java - SimpleDateFormat" scheme="http://rqsir.github.io/tags/java-SimpleDateFormat/"/>
    
      <category term="java - Calendar" scheme="http://rqsir.github.io/tags/java-Calendar/"/>
    
  </entry>
  
  <entry>
    <title>java API -- System类</title>
    <link href="http://rqsir.github.io/2019/04/29/java-API-System%E7%B1%BB/"/>
    <id>http://rqsir.github.io/2019/04/29/java-API-System类/</id>
    <published>2019-04-28T16:00:00.000Z</published>
    <updated>2019-05-18T17:16:31.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>System类是我们一开始学习java就接触到的一个常用类，在这个类中封装了许多和系统底层有关的方法供我们调用。</p></blockquote><h2 id="所属包"><a href="#所属包" class="headerlink" title="所属包"></a>所属包</h2><p>首先，查看jdk我们可以知道，<code>System</code>类是位于<code>java.lang</code>包下的。因此，是无需导包就能直接使用的。</p><h2 id="类描述"><a href="#类描述" class="headerlink" title="类描述"></a>类描述</h2><p>我们先看一段官方注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The &lt;code&gt;System&lt;/code&gt; class contains several useful class fields</span></span><br><span class="line"><span class="comment"> * and methods. It cannot be instantiated.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Among the facilities provided by the &lt;code&gt;System&lt;/code&gt; class</span></span><br><span class="line"><span class="comment"> * are standard input, standard output, and error output streams;</span></span><br><span class="line"><span class="comment"> * access to externally defined properties and environment</span></span><br><span class="line"><span class="comment"> * variables; a means of loading files and libraries; and a utility</span></span><br><span class="line"><span class="comment"> * method for quickly copying a portion of an array.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  unascribed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>   JDK1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>大意就是，<code>System</code>这个类一个基础工具类，它无法被实例化。</p><p>它主要用于标准输入、输出流的控制，以及数组的操作等。</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Don't let anyone instantiate this class */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">System</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>由于构造函数的私有属性，因此<code>System</code>类是无法实例化的。</p><h2 id="常用成员方法"><a href="#常用成员方法" class="headerlink" title="常用成员方法"></a>常用成员方法</h2><p><strong>输出方法</strong></p><p>这里介绍两个方法，分别是：<code>System.out.println()</code>以及<code>System.err.println()</code>。</p><p>实际上，这两个方法都是通过<code>System</code>内的静态不可变成员变量<code>out</code>或<code>err</code>，并且它们都是<code>PrintStream</code>类的的对象引用，然后通过对象调用类中方法。</p><p><strong>数组操作方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">* <span class="meta">@param</span>      src      the source array.</span><br><span class="line">    * <span class="meta">@param</span>      srcPos   starting position in the source array.</span><br><span class="line">    * <span class="meta">@param</span>      dest     the destination array.</span><br><span class="line">    * <span class="meta">@param</span>      destPos  starting position in the destination data.</span><br><span class="line">    * <span class="meta">@param</span>      length   the number of array elements to be copied.</span><br><span class="line">    * <span class="meta">@exception</span>  IndexOutOfBoundsException  <span class="keyword">if</span> copying would cause</span><br><span class="line">    *               access of data outside array bounds.</span><br><span class="line">    * @exception  ArrayStoreException  if an element in the &lt;code&gt;src&lt;/code&gt;</span><br><span class="line">    *               array could not be stored into the &lt;code&gt;dest&lt;/code&gt; array</span><br><span class="line">    *               because of a type mismatch.</span><br><span class="line">    * @exception  NullPointerException if either &lt;code&gt;src&lt;/code&gt; or</span><br><span class="line">    *               &lt;code&gt;dest&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.</span><br><span class="line">    */</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,  <span class="keyword">int</span>  srcPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       Object dest, <span class="keyword">int</span> destPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">int</span> length)</span></span>;</span><br></pre></td></tr></table></figure><p>从源数组<code>src</code>向目的数组<code>dest</code>，复制给定长度<code>length</code>的数据。</p><p><strong>退出<code>jvm</code>方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Terminates the currently running Java Virtual Machine. The</span></span><br><span class="line"><span class="comment">    * argument serves as a status code; by convention, a nonzero status</span></span><br><span class="line"><span class="comment">    * code indicates abnormal termination.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * This method calls the &lt;code&gt;exit&lt;/code&gt; method in class</span></span><br><span class="line"><span class="comment">    * &lt;code&gt;Runtime&lt;/code&gt;. This method never returns normally.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * The call &lt;code&gt;System.exit(n)&lt;/code&gt; is effectively equivalent to</span></span><br><span class="line"><span class="comment">    * the call:</span></span><br><span class="line"><span class="comment">    * &lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment">    * Runtime.getRuntime().exit(n)</span></span><br><span class="line"><span class="comment">    * &lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>      status   exit status.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span>  SecurityException</span></span><br><span class="line"><span class="comment">    *        if a security manager exists and its &lt;code&gt;checkExit&lt;/code&gt;</span></span><br><span class="line"><span class="comment">    *        method doesn't allow exit with the specified status.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>        java.lang.Runtime#exit(int)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span> </span>&#123;</span><br><span class="line">       Runtime.getRuntime().exit(status);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>方法描述为：终止正在运行的<code>jvm</code>，并返回一个状态码。依照惯例：返回‘0’，代表正常退出 ；其他值，代表异常退出。</p><p><strong>垃圾回收方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Runs the garbage collector.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Calling the &lt;code&gt;gc&lt;/code&gt; method suggests that the Java Virtual</span></span><br><span class="line"><span class="comment">     * Machine expend effort toward recycling unused objects in order to</span></span><br><span class="line"><span class="comment">     * make the memory they currently occupy available for quick reuse.</span></span><br><span class="line"><span class="comment">     * When control returns from the method call, the Java Virtual</span></span><br><span class="line"><span class="comment">     * Machine has made a best effort to reclaim space from all discarded</span></span><br><span class="line"><span class="comment">     * objects.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The call &lt;code&gt;System.gc()&lt;/code&gt; is effectively equivalent to the</span></span><br><span class="line"><span class="comment">     * call:</span></span><br><span class="line"><span class="comment">     * &lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment">     * Runtime.getRuntime().gc()</span></span><br><span class="line"><span class="comment">     * &lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     java.lang.Runtime#gc()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Runtime.getRuntime().gc();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>调用<code>jvm</code>的垃圾回收机制，去尽可能的回收系统资源。一般与<code>Object</code>类的<code>finalize()</code>方法配套使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Called by the garbage collector on an object when garbage collection</span><br><span class="line">    * determines that there are no more references to the object.</span><br><span class="line">    * A subclass overrides the &#123;@code finalize&#125; method to dispose of</span><br><span class="line">    * system resources or to perform other cleanup.</span><br><span class="line">    * &lt;p&gt;</span><br><span class="line"> protected void finalize() throws Throwable &#123; &#125;</span><br></pre></td></tr></table></figure><p>流程是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Student(); <span class="comment">//创建匿名对象，方便gc回收</span></span><br><span class="line">        System.gc();   <span class="comment">//调用jvm回收机制</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"在这里完成一些收尾工作"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果是：可能打印出“在这里完成一些收尾工作”。因为gc不能保证每次都能回收<code>Student</code>资源（the Java Virtual Machine has made a best effort to reclaim space from all discarded）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;System类是我们一开始学习java就接触到的一个常用类，在这个类中封装了许多和系统底层有关的方法供我们调用。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;所属包&quot;&gt;&lt;a href=&quot;#所属包&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
      <category term="java-se" scheme="http://rqsir.github.io/categories/java-se/"/>
    
    
      <category term="java - System" scheme="http://rqsir.github.io/tags/java-System/"/>
    
  </entry>
  
  <entry>
    <title>java中根类Object的常用方法</title>
    <link href="http://rqsir.github.io/2019/04/29/java%E4%B8%AD%E6%A0%B9%E7%B1%BBObject%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://rqsir.github.io/2019/04/29/java中根类Object的常用方法/</id>
    <published>2019-04-28T16:00:00.000Z</published>
    <updated>2019-05-18T17:21:15.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Object类，一般我们习惯称之为超类或根父类，这代表了它至高无上的低位。它是所有类的父类，它当中的一些属性将被所有类继承。</p><p>这里我主要总结了<code>toString()</code>、<code>equals()</code>以及<code>hashCode()</code>这3个方法。</p></blockquote><h2 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString()方法"></a><code>toString()</code>方法</h2><p>这里首先引入一段jdk源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns a string representation of the object. In general, the</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> toString&#125; method returns a string that</span></span><br><span class="line"><span class="comment">    * "textually represents" this object. The result should</span></span><br><span class="line"><span class="comment">    * be a concise but informative representation that is easy for a</span></span><br><span class="line"><span class="comment">    * person to read.</span></span><br><span class="line"><span class="comment">    * It is recommended that all subclasses override this method.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * The &#123;<span class="doctag">@code</span> toString&#125; method for class &#123;<span class="doctag">@code</span> Object&#125;</span></span><br><span class="line"><span class="comment">    * returns a string consisting of the name of the class of which the</span></span><br><span class="line"><span class="comment">    * object is an instance, the at-sign character `&#123;<span class="doctag">@code</span> @&#125;', and</span></span><br><span class="line"><span class="comment">    * the unsigned hexadecimal representation of the hash code of the</span></span><br><span class="line"><span class="comment">    * object. In other words, this method returns a string equal to the</span></span><br><span class="line"><span class="comment">    * value of:</span></span><br><span class="line"><span class="comment">    * &lt;blockquote&gt;</span></span><br><span class="line"><span class="comment">    * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">    * getClass().getName() + '@' + Integer.toHexString(hashCode())</span></span><br><span class="line"><span class="comment">    * &lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  a string representation of the object.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这个方法主要完成<code>Object</code>对象的文本化输出。输出内容由<code>getClass().getName()</code>和<code>Integer.toHexString(hashCode())</code>两部分组成。第一部分是：对象所属的包名加类名，第二个部分是：对象地址的<code>hash</code>表示。</p><p>在实际的开发中，我们一般会通过<code>IDE</code>自动重写该方法。</p><h2 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals()方法"></a><code>equals()</code>方法</h2><p>二话不说，上jdk源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Indicates whether some other object is "equal to" this one.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The &#123;<span class="doctag">@code</span> equals&#125; method implements an equivalence relation</span></span><br><span class="line"><span class="comment">     * on non-null object references:</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;It is &lt;i&gt;reflexive&lt;/i&gt;: for any non-null reference value</span></span><br><span class="line"><span class="comment">     *     &#123;<span class="doctag">@code</span> x&#125;, &#123;<span class="doctag">@code</span> x.equals(x)&#125; should return</span></span><br><span class="line"><span class="comment">     *     &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;It is &lt;i&gt;symmetric&lt;/i&gt;: for any non-null reference values</span></span><br><span class="line"><span class="comment">     *     &#123;<span class="doctag">@code</span> x&#125; and &#123;<span class="doctag">@code</span> y&#125;, &#123;<span class="doctag">@code</span> x.equals(y)&#125;</span></span><br><span class="line"><span class="comment">     *     should return &#123;<span class="doctag">@code</span> true&#125; if and only if</span></span><br><span class="line"><span class="comment">     *     &#123;<span class="doctag">@code</span> y.equals(x)&#125; returns &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;It is &lt;i&gt;transitive&lt;/i&gt;: for any non-null reference values</span></span><br><span class="line"><span class="comment">     *     &#123;<span class="doctag">@code</span> x&#125;, &#123;<span class="doctag">@code</span> y&#125;, and &#123;<span class="doctag">@code</span> z&#125;, if</span></span><br><span class="line"><span class="comment">     *     &#123;<span class="doctag">@code</span> x.equals(y)&#125; returns &#123;<span class="doctag">@code</span> true&#125; and</span></span><br><span class="line"><span class="comment">     *     &#123;<span class="doctag">@code</span> y.equals(z)&#125; returns &#123;<span class="doctag">@code</span> true&#125;, then</span></span><br><span class="line"><span class="comment">     *     &#123;<span class="doctag">@code</span> x.equals(z)&#125; should return &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;It is &lt;i&gt;consistent&lt;/i&gt;: for any non-null reference values</span></span><br><span class="line"><span class="comment">     *     &#123;<span class="doctag">@code</span> x&#125; and &#123;<span class="doctag">@code</span> y&#125;, multiple invocations of</span></span><br><span class="line"><span class="comment">     *     &#123;<span class="doctag">@code</span> x.equals(y)&#125; consistently return &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment">     *     or consistently return &#123;<span class="doctag">@code</span> false&#125;, provided no</span></span><br><span class="line"><span class="comment">     *     information used in &#123;<span class="doctag">@code</span> equals&#125; comparisons on the</span></span><br><span class="line"><span class="comment">     *     objects is modified.</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;For any non-null reference value &#123;<span class="doctag">@code</span> x&#125;,</span></span><br><span class="line"><span class="comment">     *     &#123;<span class="doctag">@code</span> x.equals(null)&#125; should return &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The &#123;<span class="doctag">@code</span> equals&#125; method for class &#123;<span class="doctag">@code</span> Object&#125; implements</span></span><br><span class="line"><span class="comment">     * the most discriminating possible equivalence relation on objects;</span></span><br><span class="line"><span class="comment">     * that is, for any non-null reference values &#123;<span class="doctag">@code</span> x&#125; and</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> y&#125;, this method returns &#123;<span class="doctag">@code</span> true&#125; if and only</span></span><br><span class="line"><span class="comment">     * if &#123;<span class="doctag">@code</span> x&#125; and &#123;<span class="doctag">@code</span> y&#125; refer to the same object</span></span><br><span class="line"><span class="comment">     * (&#123;<span class="doctag">@code</span> x == y&#125; has the value &#123;<span class="doctag">@code</span> true&#125;).</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Note that it is generally necessary to override the &#123;<span class="doctag">@code</span> hashCode&#125;</span></span><br><span class="line"><span class="comment">     * method whenever this method is overridden, so as to maintain the</span></span><br><span class="line"><span class="comment">     * general contract for the &#123;<span class="doctag">@code</span> hashCode&#125; method, which states</span></span><br><span class="line"><span class="comment">     * that equal objects must have equal hash codes.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   obj   the reference object with which to compare.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  &#123;<span class="doctag">@code</span> true&#125; if this object is the same as the obj</span></span><br><span class="line"><span class="comment">     *          argument; &#123;<span class="doctag">@code</span> false&#125; otherwise.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     #hashCode()</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     java.util.HashMap</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如注释所述，<code>equals</code>方法主要用于判断非空对象与另一给定对象，是否为同一对象（在堆内存中位于同一地址空间）。在实际开发中，我们一般会选择重写该方法去完成更具体的功能。例如，在jdk中的<code>String</code>类中，就重写了<code>equals</code>方法，去判断两个字符串是否相等。</p><h2 id="hashCode-方法"><a href="#hashCode-方法" class="headerlink" title="hashCode()方法"></a><code>hashCode()</code>方法</h2><p>jdk源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns a hash code value for the object. This method is</span></span><br><span class="line"><span class="comment">    * supported for the benefit of hash tables such as those provided by</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> java.util.HashMap&#125;.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * The general contract of &#123;<span class="doctag">@code</span> hashCode&#125; is:</span></span><br><span class="line"><span class="comment">    * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">    * &lt;li&gt;Whenever it is invoked on the same object more than once during</span></span><br><span class="line"><span class="comment">    *     an execution of a Java application, the &#123;<span class="doctag">@code</span> hashCode&#125; method</span></span><br><span class="line"><span class="comment">    *     must consistently return the same integer, provided no information</span></span><br><span class="line"><span class="comment">    *     used in &#123;<span class="doctag">@code</span> equals&#125; comparisons on the object is modified.</span></span><br><span class="line"><span class="comment">    *     This integer need not remain consistent from one execution of an</span></span><br><span class="line"><span class="comment">    *     application to another execution of the same application.</span></span><br><span class="line"><span class="comment">    * &lt;li&gt;If two objects are equal according to the &#123;<span class="doctag">@code</span> equals(Object)&#125;</span></span><br><span class="line"><span class="comment">    *     method, then calling the &#123;<span class="doctag">@code</span> hashCode&#125; method on each of</span></span><br><span class="line"><span class="comment">    *     the two objects must produce the same integer result.</span></span><br><span class="line"><span class="comment">    * &lt;li&gt;It is &lt;em&gt;not&lt;/em&gt; required that if two objects are unequal</span></span><br><span class="line"><span class="comment">    *     according to the &#123;<span class="doctag">@link</span> java.lang.Object#equals(java.lang.Object)&#125;</span></span><br><span class="line"><span class="comment">    *     method, then calling the &#123;<span class="doctag">@code</span> hashCode&#125; method on each of the</span></span><br><span class="line"><span class="comment">    *     two objects must produce distinct integer results.  However, the</span></span><br><span class="line"><span class="comment">    *     programmer should be aware that producing distinct integer results</span></span><br><span class="line"><span class="comment">    *     for unequal objects may improve the performance of hash tables.</span></span><br><span class="line"><span class="comment">    * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * As much as is reasonably practical, the hashCode method defined by</span></span><br><span class="line"><span class="comment">    * class &#123;<span class="doctag">@code</span> Object&#125; does return distinct integers for distinct</span></span><br><span class="line"><span class="comment">    * objects. (This is typically implemented by converting the internal</span></span><br><span class="line"><span class="comment">    * address of the object into an integer, but this implementation</span></span><br><span class="line"><span class="comment">    * technique is not required by the</span></span><br><span class="line"><span class="comment">    * Java&amp;trade; programming language.)</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  a hash code value for this object.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>     java.lang.Object#equals(java.lang.Object)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>     java.lang.System#identityHashCode</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p><code>hashCode</code>方法，返回的是对象在内存中地址的<code>hash</code>编码。这在<code>HashTable</code>中会用到，主要是用作对象存储的<code>index</code>使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;Object类，一般我们习惯称之为超类或根父类，这代表了它至高无上的低位。它是所有类的父类，它当中的一些属性将被所有类继承。&lt;/p&gt;&lt;p&gt;这里我主要总结了&lt;code&gt;toString()&lt;/code&gt;、&lt;code&gt;equals()&lt;/code&gt;以及&lt;
      
    
    </summary>
    
      <category term="java-se" scheme="http://rqsir.github.io/categories/java-se/"/>
    
    
      <category term="java - Object" scheme="http://rqsir.github.io/tags/java-Object/"/>
    
  </entry>
  
  <entry>
    <title>java -- 修饰符总结</title>
    <link href="http://rqsir.github.io/2019/04/26/java-%E4%BF%AE%E9%A5%B0%E7%AC%A6%E6%80%BB%E7%BB%93/"/>
    <id>http://rqsir.github.io/2019/04/26/java-修饰符总结/</id>
    <published>2019-04-25T16:00:00.000Z</published>
    <updated>2019-05-26T02:09:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h2><ul><li><code>public</code>：所有类都可以访问</li><li><code>private</code>：当前类可以访问</li><li><code>default（默认，什么都不写）</code>：同一包下，可以访问</li><li><code>protected</code>：子类可以访问</li></ul><h2 id="修饰符总结"><a href="#修饰符总结" class="headerlink" title="修饰符总结"></a>修饰符总结</h2><table><thead><tr><th style="text-align:center">修饰符</th><th style="text-align:center">类</th><th style="text-align:center">成员变量</th><th style="text-align:center">成员方法</th><th style="text-align:center">构造方法</th></tr></thead><tbody><tr><td style="text-align:center">public</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">default</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">protected</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">private</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">abstract</td><td style="text-align:center">√</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">static</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">final</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr></tbody></table><p>修饰符使用常用规则：</p><ul><li>一般使用<code>public</code>修饰类，一个java文件中最好只有一个类。如果一个文件中有多个类，类名和文件名相同的类，必须用<code>public</code>修饰；其余类不能用<code>public</code>修饰。</li><li>一般用<code>private</code>修饰成员变量，并提供相应的<code>get</code>、<code>set</code>方法</li><li>一般用<code>public</code>修饰成员方法，除非那些你不想让人调用的方法，可以用<code>private</code>修饰。</li><li>一般用<code>public</code>修饰构造方法，除非你不想让别人实例化这个类，可以用<code>private</code>修饰。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;权限修饰符&quot;&gt;&lt;a href=&quot;#权限修饰符&quot; class=&quot;headerlink&quot; title=&quot;权限修饰符&quot;&gt;&lt;/a&gt;权限修饰符&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;public&lt;/code&gt;：所有类都可以访问&lt;/li&gt;&lt;li&gt;&lt;code&gt;private&lt;/c
      
    
    </summary>
    
      <category term="java-se" scheme="http://rqsir.github.io/categories/java-se/"/>
    
    
      <category term="java修饰符" scheme="http://rqsir.github.io/tags/java%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>java -- 多态</title>
    <link href="http://rqsir.github.io/2019/04/26/java-%E5%A4%9A%E6%80%81/"/>
    <id>http://rqsir.github.io/2019/04/26/java-多态/</id>
    <published>2019-04-25T16:00:00.000Z</published>
    <updated>2019-05-25T14:51:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>多态的前提</strong>：</p><ul><li>存在子父类继承关系（或子类和父类接口实现关系）</li><li>存在方法重写</li><li>父类（或父接口）引用指向子类对象</li></ul><p><strong>动态绑定</strong>：</p><p>​ 运行期间调用的方法，是根据具体的类型决定的。</p><h2 id="多态的成员特点"><a href="#多态的成员特点" class="headerlink" title="多态的成员特点"></a>多态的成员特点</h2><table><thead><tr><th style="text-align:center">成员分类</th><th style="text-align:center">特点</th></tr></thead><tbody><tr><td style="text-align:center">成员变量</td><td style="text-align:center">编译时看的是左边，运行时看的是左边</td></tr><tr><td style="text-align:center">成员方法</td><td style="text-align:center">编译时看的是左边，运行时看的是右边（动态绑定）</td></tr><tr><td style="text-align:center">静态成员方法</td><td style="text-align:center">编译时看的是左边，运行时看的也是左边</td></tr></tbody></table><p><strong>举例说明</strong></p><p>先定义父类和子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dad</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"我是父类方法"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"我是父类静态方法"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Kid</span> <span class="keyword">extends</span> <span class="title">Dad</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"我是子类方法"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"我是子类静态方法"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1 对于成员变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoymorphicDemo</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">                Dad d = <span class="keyword">new</span> Kid(); </span><br><span class="line"><span class="comment">//d.num 编译时，首先会查看父类Dad中是否存在num成员变量，如不存在，则会报错，这就是“编译看左边”</span></span><br><span class="line">                System.out.println(d.num);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出 20</span></span><br><span class="line"><span class="comment">//这就说明最后输出的是父类Dad中的成员变量，即所谓“运行看左边”</span></span><br></pre></td></tr></table></figure><p>2 对于成员方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoymorphicDemo2</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">                Dad d = <span class="keyword">new</span> Kid();</span><br><span class="line"><span class="comment">//d.method()编译时，首先会查看父类Dad中是否存在method成员方法，不存在，就会报错，即“编译看左边”</span></span><br><span class="line">                d.method();</span><br><span class="line">      </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出  我是子类方法</span></span><br><span class="line"><span class="comment">//最后执行的是子类成员方法，即所谓的“运行看右边”，这里涉及运行期间的编译器“动态绑定”</span></span><br></pre></td></tr></table></figure><p>3 对于静态成员方法</p><p>与成员变量类似，这里不在赘述。</p><h2 id="多态中的向上转型和向下转型"><a href="#多态中的向上转型和向下转型" class="headerlink" title="多态中的向上转型和向下转型"></a>多态中的向上转型和向下转型</h2><p>本质上属于<strong>引用数据类型</strong>的转型问题。可以和基本数据类型转型进行对比</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">基本数据类型</th><th style="text-align:center">引用数据类型</th></tr></thead><tbody><tr><td style="text-align:center">自然转型</td><td style="text-align:center">小存储空间向大存储空间转型</td><td style="text-align:center">子类向父类转型（向上转型）</td></tr><tr><td style="text-align:center">强制转型</td><td style="text-align:center">大存储空间向小存储空间转型</td><td style="text-align:center">父类向子类转型（向下转型）</td></tr></tbody></table><p><em>说明：向上转型，只能调用父类中存在并被重写的方法；向下转型，可以调用子类中特有的方法</em></p><h2 id="多态的优缺点"><a href="#多态的优缺点" class="headerlink" title="多态的优缺点"></a>多态的优缺点</h2><p><strong>优点</strong>：</p><p>由于多态基于继承和接口，故继承和接口所具有的优点，它都具有（如减少代码冗余，可维护，模块化编程等）</p><p><strong>缺点</strong>：</p><p>无法访问子类特有成员和方法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;多态的前提&lt;/strong&gt;：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;存在子父类继承关系（或子类和父类接口实现关系）&lt;/li
      
    
    </summary>
    
      <category term="java-se" scheme="http://rqsir.github.io/categories/java-se/"/>
    
    
      <category term="java多态" scheme="http://rqsir.github.io/tags/java%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
</feed>
