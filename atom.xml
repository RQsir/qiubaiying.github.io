<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RQ Blog</title>
  
  <subtitle>真正的梦就是现实的彼岸。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://rqsir.github.io/"/>
  <updated>2019-05-18T17:12:33.356Z</updated>
  <id>http://rqsir.github.io/</id>
  
  <author>
    <name>RQsir</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java API -- Date &amp;&amp; SimpleDateFormat &amp;&amp; Calendar</title>
    <link href="http://rqsir.github.io/2019/04/29/java-API-Date-SimpleDateFormat-Calendar/"/>
    <id>http://rqsir.github.io/2019/04/29/java-API-Date-SimpleDateFormat-Calendar/</id>
    <published>2019-04-28T16:00:00.000Z</published>
    <updated>2019-05-18T17:12:33.356Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>java中有一种特殊的对象，我们平时都是通过字符串的形式使用它，但在底层却时不时涉及到一些数字运算；除此之外，我们对它的字符串输出形式，往往还是百般挑剔，猜猜它是谁？</p><p>：-）没错，它就是java中的Date对象</p></blockquote><p>java <code>API</code>下为我们封装了有关时间和日期操作了相关函数，总结如下：</p><h2 id="Date类-–-日期获取的好帮手"><a href="#Date类-–-日期获取的好帮手" class="headerlink" title="Date类 – 日期获取的好帮手"></a>Date类 – 日期获取的好帮手</h2><p>首先，学习一个类，大致分为以下几个步骤：</p><ol><li>看类所在<code>package</code>，如果在<code>java.lang</code>包下，则使用时可以省去导包操作。</li><li>接着看类的说明，了解类的大致用途即可。</li><li>查看类的构造函数</li><li>查看类的常用成员方法</li></ol><p>好，我们按照上述步骤，来学习一下<code>Date</code>。</p><h3 id="所在package"><a href="#所在package" class="headerlink" title="所在package"></a>所在package</h3><p>由<code>package java.util;</code>可知，<code>Date</code>包位于<code>java.util</code>包下，所有使用时需要导包。</p><h3 id="类的介绍"><a href="#类的介绍" class="headerlink" title="类的介绍"></a>类的介绍</h3><p>查看源码注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The class &lt;code&gt;Date&lt;/code&gt; represents a specific instant</span></span><br><span class="line"><span class="comment"> * in time, with millisecond precision.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Prior to JDK&amp;nbsp;1.1, the class &lt;code&gt;Date&lt;/code&gt; had two additional</span></span><br><span class="line"><span class="comment"> * functions.  It allowed the interpretation of dates as year, month, day, hour,</span></span><br><span class="line"><span class="comment"> * minute, and second values.  It also allowed the formatting and parsing</span></span><br><span class="line"><span class="comment"> * of date strings.  Unfortunately, the API for these functions was not</span></span><br><span class="line"><span class="comment"> * amenable to internationalization.  As of JDK&amp;nbsp;1.1, the</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;Calendar&lt;/code&gt; class should be used to convert between dates and time</span></span><br><span class="line"><span class="comment"> * fields and the &lt;code&gt;DateFormat&lt;/code&gt; class should be used to format and</span></span><br><span class="line"><span class="comment"> * parse date strings.</span></span><br><span class="line"><span class="comment"> * The corresponding methods in &lt;code&gt;Date&lt;/code&gt; are deprecated.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>首先，它告诉我们：<code>Date</code>是用来表示一个以毫秒为单位的确定时刻的类。<code>Date</code>可以表征“年”、“月”、“日”、“时”、“分”和“秒”。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>由于一些方法已经过时，这里我们只提及两个常用的构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Allocates a &lt;code&gt;Date&lt;/code&gt; object and initializes it so that</span></span><br><span class="line"><span class="comment">     * it represents the time at which it was allocated, measured to the</span></span><br><span class="line"><span class="comment">     * nearest millisecond.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     java.lang.System#currentTimeMillis()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Date</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Allocates a &lt;code&gt;Date&lt;/code&gt; object and initializes it to</span></span><br><span class="line"><span class="comment">     * represent the specified number of milliseconds since the</span></span><br><span class="line"><span class="comment">     * standard base time known as "the epoch", namely January 1,</span></span><br><span class="line"><span class="comment">     * 1970, 00:00:00 GMT.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   date   the milliseconds since January 1, 1970, 00:00:00 GMT.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     java.lang.System#currentTimeMillis()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Date</span><span class="params">(<span class="keyword">long</span> date)</span> </span>&#123;</span><br><span class="line">        fastTime = date;  <span class="comment">// fastTime 是成员变量</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>空参构造方法<code>Date()</code>用来初始化一个<code>Date</code>对象，其时间基准线为<code>jvm</code>运行环境的当前时间，也就是说这个<code>Date</code>对象的时间值与当前时间一致。</p><p>有参构造方法<code>Date(long date)</code>用来初始化一个相对时间基准线，时间值为<code>long date</code>的<code>Date</code>对象。其中，时间基准线为<code>1970-1-1 00:00:00</code>，俗称“计算机元年”。举个例子，<code>Date(1000)</code>代表的是<code>1970-1-1 00:00:01</code>这个时刻。</p><h3 id="常用成员方法"><a href="#常用成员方法" class="headerlink" title="常用成员方法"></a>常用成员方法</h3><p>这里我们介绍两个常用成员函数<code>setTime()</code>和<code>getTime()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Sets this &lt;code&gt;Date&lt;/code&gt; object to represent a point in time that is</span></span><br><span class="line"><span class="comment">    * &lt;code&gt;time&lt;/code&gt; milliseconds after January 1, 1970 00:00:00 GMT.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>   time   the number of milliseconds.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTime</span><span class="params">(<span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">       fastTime = time;</span><br><span class="line">       cdate = <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns the number of milliseconds since January 1, 1970, 00:00:00 GMT</span></span><br><span class="line"><span class="comment">    * represented by this &lt;tt&gt;Date&lt;/tt&gt; object.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  the number of milliseconds since January 1, 1970, 00:00:00 GMT</span></span><br><span class="line"><span class="comment">    *          represented by this date.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> getTimeImpl();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getTimeImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (cdate != <span class="keyword">null</span> &amp;&amp; !cdate.isNormalized()) &#123;</span><br><span class="line">           normalize();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> fastTime;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>其中<code>setTime(long time)</code>用来设置时间，参数<code>time</code>为相对于“1970-1-1 00:00:00”的时间值，单位为毫秒。</p><p>而<code>getTime()</code>代表的是当前时间的毫秒值，同样是相对于“1970-1-1 00:00:00”。</p><h2 id="SimpleDateFormat类-–-日期格式化-amp-解析神器"><a href="#SimpleDateFormat类-–-日期格式化-amp-解析神器" class="headerlink" title="SimpleDateFormat类 – 日期格式化&amp;解析神器"></a>SimpleDateFormat类 – 日期格式化&amp;解析神器</h2><h3 id="所在包"><a href="#所在包" class="headerlink" title="所在包"></a>所在包</h3><p><code>SimpleDateFormat</code>位于包<code>java.text</code>下，使用前需要导包。</p><h3 id="类概述"><a href="#类概述" class="headerlink" title="类概述"></a>类概述</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;SimpleDateFormat&lt;/code&gt; is a concrete class for formatting and</span></span><br><span class="line"><span class="comment"> * parsing dates in a locale-sensitive manner. It allows for formatting</span></span><br><span class="line"><span class="comment"> * (date &amp;rarr; text), parsing (text &amp;rarr; date), and normalization.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br></pre></td></tr></table></figure><p>大意是说：<code>SimpleDateFormat</code>是一个用来格式化<code>Date</code>（输入为<code>Date</code>，输出为<code>String</code>），以及解析Date字符串（输入为<code>String</code>，输出为<code>Date</code>）的具体类。<code>SimpleDateFormat</code>特色是支持用户自定义格式，格式化<code>Date</code>。</p><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><p>这里我们主要讲解两个常用构造方法，分别是：空参构造方法<code>SimpleDateFormat()</code>，以及有参构造方法<code>SimpleDateFormat(String)</code>。</p><p>下面是它们的jdk源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constructs a &lt;code&gt;SimpleDateFormat&lt;/code&gt; using the default pattern and</span></span><br><span class="line"><span class="comment">    * date format symbols for the default</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> java.util.Locale.Category#FORMAT FORMAT&#125; locale.</span></span><br><span class="line"><span class="comment">    * &lt;b&gt;Note:&lt;/b&gt; This constructor may not support all locales.</span></span><br><span class="line"><span class="comment">    * For full coverage, use the factory methods in the &#123;<span class="doctag">@link</span> DateFormat&#125;</span></span><br><span class="line"><span class="comment">    * class.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">SimpleDateFormat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(<span class="string">""</span>, Locale.getDefault(Locale.Category.FORMAT));           applyPatternImpl(LocaleProviderAdapter.getResourceBundleBased().getLocaleResources(locale).getDateTimePattern(SHORT, SHORT, calendar));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constructs a &lt;code&gt;SimpleDateFormat&lt;/code&gt; using the given pattern and</span></span><br><span class="line"><span class="comment">    * the default date format symbols for the default</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> java.util.Locale.Category#FORMAT FORMAT&#125; locale.</span></span><br><span class="line"><span class="comment">    * &lt;b&gt;Note:&lt;/b&gt; This constructor may not support all locales.</span></span><br><span class="line"><span class="comment">    * For full coverage, use the factory methods in the &#123;<span class="doctag">@link</span> DateFormat&#125;</span></span><br><span class="line"><span class="comment">    * class.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;This is equivalent to calling</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> #SimpleDateFormat(String, Locale)</span></span><br><span class="line"><span class="comment">    *     SimpleDateFormat(pattern, Locale.getDefault(Locale.Category.FORMAT))&#125;.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> java.util.Locale#getDefault(java.util.Locale.Category)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> java.util.Locale.Category#FORMAT</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> pattern the pattern describing the date and time format</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@exception</span> NullPointerException if the given pattern is null</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@exception</span> IllegalArgumentException if the given pattern is invalid</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">SimpleDateFormat</span><span class="params">(String pattern)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(pattern, Locale.getDefault(Locale.Category.FORMAT));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>其中，空参构造方法<code>SimpleDateFormat()</code>是以默认格式<code>Sun Apr 28 20:45:54 CST 2019</code>构造<code>SimpleDateFormat</code>对象，在之后的<code>format</code>过程中，会以这个格式来生成对应的字符串。</p><p>而有参构造方法<code>SimpleDateFormat(String)</code>，则是用给定的格式（如：yyyy:MM:dd HH:mm:ss）来生成对应<code>SimpleDateFormat</code>对象，在之后的<code>format</code>过程中，会以这个格式来生成对应的字符串。</p><h3 id="常用成员方法-1"><a href="#常用成员方法-1" class="headerlink" title="常用成员方法"></a>常用成员方法</h3><p>这里要注意一下，我们一般不怎么使用<code>SimpleDateFormat</code>自己特有的成员方法；相反，我们比较爱用其继承于父类<code>DateFormat</code>的方法<code>formate(Date)</code>和<code>parse(String)</code>。</p><p>相关源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Formats a Date into a date/time string.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> date the time value to be formatted into a time string.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the formatted time string.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">format</span><span class="params">(Date date)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> format(date, <span class="keyword">new</span> StringBuffer(),</span><br><span class="line">                      DontCareFieldPosition.INSTANCE).toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Parses text from the beginning of the given string to produce a date.</span></span><br><span class="line"><span class="comment">     * The method may not use the entire text of the given string.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * See the &#123;<span class="doctag">@link</span> #parse(String, ParsePosition)&#125; method for more information</span></span><br><span class="line"><span class="comment">     * on date parsing.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source A &lt;code&gt;String&lt;/code&gt; whose beginning should be parsed.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A &lt;code&gt;Date&lt;/code&gt; parsed from the string.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@exception</span> ParseException if the beginning of the specified string</span></span><br><span class="line"><span class="comment">     *            cannot be parsed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">parse</span><span class="params">(String source)</span> <span class="keyword">throws</span> ParseException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ParsePosition pos = <span class="keyword">new</span> ParsePosition(<span class="number">0</span>);</span><br><span class="line">        Date result = parse(source, pos);</span><br><span class="line">        <span class="keyword">if</span> (pos.index == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ParseException(<span class="string">"Unparseable date: \""</span> + source + <span class="string">"\""</span> ,</span><br><span class="line">                pos.errorIndex);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从以上代码可知，方法<code>format</code>主要完成了<code>Date</code>对象到指定格式字符串的转换；而<code>parse</code>方法主要完成了<code>String</code>对象到<code>Date</code>对象的转化。</p><h2 id="Calendar类-–-日期操作的手术刀"><a href="#Calendar类-–-日期操作的手术刀" class="headerlink" title="Calendar类 – 日期操作的手术刀"></a>Calendar类 – 日期操作的手术刀</h2><h3 id="所在包-1"><a href="#所在包-1" class="headerlink" title="所在包"></a>所在包</h3><p>位于<code>java.util</code>包下，使用前需执行导包操作。</p><h3 id="类简述"><a href="#类简述" class="headerlink" title="类简述"></a>类简述</h3><p>见看一段jdk英文注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The &lt;code&gt;Calendar&lt;/code&gt; class is an abstract class that provides methods</span></span><br><span class="line"><span class="comment"> * for converting between a specific instant in time and a set of &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * #fields calendar fields&#125; such as &lt;code&gt;YEAR&lt;/code&gt;, &lt;code&gt;MONTH&lt;/code&gt;,</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;DAY_OF_MONTH&lt;/code&gt;, &lt;code&gt;HOUR&lt;/code&gt;, and so on, and for</span></span><br><span class="line"><span class="comment"> * manipulating the calendar fields, such as getting the date of the next</span></span><br><span class="line"><span class="comment"> * week. An instant in time can be represented by a millisecond value that is</span></span><br><span class="line"><span class="comment"> * an offset from the &lt;a name="Epoch"&gt;&lt;em&gt;Epoch&lt;/em&gt;&lt;/a&gt;, January 1, 1970</span></span><br><span class="line"><span class="comment"> * 00:00:00.000 GMT (Gregorian).</span></span><br></pre></td></tr></table></figure><p>翻译过来，大致意思就是：<code>Calendar</code>是一个在“年”、“月”、“日”、“时”等日历属性，以及时间点（以毫秒为单位）之间进行转化的一个工具类。它可以对“年”、“月”、“日”、“时”等日历属性进行相关算术运算，最终反应在<code>Date</code>中的就是属性值<code>fastTime</code>的变化（即毫秒值的变化）。</p><h3 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h3><p><code>Calendar</code>构造函数有两个，分别为<code>Calendar()</code>以及<code>Calendar(TimeZone zone, Locale aLocale)</code>，但平时使用中我们基本不用。</p><p>实例化<code>Calendar</code>类，我们一般选择使用ta的静态成员方法<code>getInstance()</code>，实例化的是其子类对象。原因是：我们使用的某些成员方法如<code>add(int, int)</code>，它的实现是在<code>Calendar</code>的子类中完成的，这里用到了多态的向上转型。相应源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Gets a calendar using the default time zone and locale. The</span></span><br><span class="line"><span class="comment">    * &lt;code&gt;Calendar&lt;/code&gt; returned is based on the current time</span></span><br><span class="line"><span class="comment">    * in the default time zone with the default</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> Locale.Category#FORMAT FORMAT&#125; locale.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> a Calendar.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Calendar <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> createCalendar(TimeZone.getDefault(),     Locale.getDefault(Locale.Category.FORMAT));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>需要注意的是：通过<code>getInstance()</code>方法获取的<code>Calendar</code>子类对象，其时间值是相对“计算机元年”而言的。</p><h3 id="常用成员方法-2"><a href="#常用成员方法-2" class="headerlink" title="常用成员方法"></a>常用成员方法</h3><p>这里，我们主要讲解“查询”、“设置”、“修改”<code>calendar</code>指定字段(<code>filed</code>)的成员方法。它们分别对应为：<code>get(int)</code>方法、<code>set(int,int)</code>方法、<code>add(int,int)</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value of the given calendar field. In lenient mode,</span></span><br><span class="line"><span class="comment">     * all calendar fields are normalized. In non-lenient mode, all</span></span><br><span class="line"><span class="comment">     * calendar fields are validated and this method throws an</span></span><br><span class="line"><span class="comment">     * exception if any calendar fields have out-of-range values. The</span></span><br><span class="line"><span class="comment">     * normalization and validation are handled by the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #complete()&#125; method, which process is calendar</span></span><br><span class="line"><span class="comment">     * system dependent.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> field the given calendar field.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the value for the given calendar field.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ArrayIndexOutOfBoundsException if the specified field is out of range</span></span><br><span class="line"><span class="comment">     *             (&lt;code&gt;field &amp;lt; 0 || field &amp;gt;= FIELD_COUNT&lt;/code&gt;).</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #set(int,int)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #complete()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> field)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        complete();</span><br><span class="line">        <span class="keyword">return</span> internalGet(field);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the given calendar field to the given value. The value is not</span></span><br><span class="line"><span class="comment">     * interpreted by this method regardless of the leniency mode.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> field the given calendar field.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value the value to be set for the given calendar field.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ArrayIndexOutOfBoundsException if the specified field is out of range</span></span><br><span class="line"><span class="comment">     *             (&lt;code&gt;field &amp;lt; 0 || field &amp;gt;= FIELD_COUNT&lt;/code&gt;).</span></span><br><span class="line"><span class="comment">     * in non-lenient mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #set(int,int,int)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #set(int,int,int,int,int)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #set(int,int,int,int,int,int)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #get(int)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> field, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// If the fields are partially normalized, calculate all the</span></span><br><span class="line">        <span class="comment">// fields before changing any fields.</span></span><br><span class="line">        <span class="keyword">if</span> (areFieldsSet &amp;&amp; !areAllFieldsSet) &#123;</span><br><span class="line">            computeFields();</span><br><span class="line">        &#125;</span><br><span class="line">        internalSet(field, value);</span><br><span class="line">        isTimeSet = <span class="keyword">false</span>;</span><br><span class="line">        areFieldsSet = <span class="keyword">false</span>;</span><br><span class="line">        isSet[field] = <span class="keyword">true</span>;</span><br><span class="line">        stamp[field] = nextStamp++;</span><br><span class="line">        <span class="keyword">if</span> (nextStamp == Integer.MAX_VALUE) &#123;</span><br><span class="line">            adjustStamp();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Adds or subtracts the specified amount of time to the given calendar field,</span></span><br><span class="line"><span class="comment">     * based on the calendar's rules. For example, to subtract 5 days from</span></span><br><span class="line"><span class="comment">     * the current time of the calendar, you can achieve it by calling:</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;&lt;code&gt;add(Calendar.DAY_OF_MONTH, -5)&lt;/code&gt;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> field the calendar field.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> amount the amount of date or time to be added to the field.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #roll(int,int)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #set(int,int)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> field, <span class="keyword">int</span> amount)</span></span>;</span><br></pre></td></tr></table></figure><p>先说<code>get(int)</code>方法，这个方法主要通过指定<code>int</code>型字段来获取相应字段的整数型值。例如，<code>get(Calendar.YEAR)</code>返回的就是当前系统的年份值。</p><p>常用的字段总结如下：</p><table><thead><tr><th style="text-align:center">字段名</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">YEAR</td><td style="text-align:center">年份</td></tr><tr><td style="text-align:center">MONTH</td><td style="text-align:center">月份</td></tr><tr><td style="text-align:center">DAY_OF_MONTH</td><td style="text-align:center">月份中的日子</td></tr><tr><td style="text-align:center">HOUR_OF_DAY</td><td style="text-align:center">一天中的小时</td></tr><tr><td style="text-align:center">MINUTE</td><td style="text-align:center">小时中的分钟</td></tr><tr><td style="text-align:center">SECOND</td><td style="text-align:center">分钟中的秒</td></tr></tbody></table><p>接着谈谈<code>set(int field, int value)</code>方法，这个方法是给指定字段设置给定值。例如，我们可以将月份设置为一月，即<code>set(Calendar.MONTH, Calendar.JANUARY)</code>或者<code>set(Calendar.MONTH, 0)</code>（因为这里采用的是格里高利纪年法，0表示一月）。</p><p>最后轮到<code>add(int field, int amount)</code>了，这个方法和<code>set(int ,int )</code>方法的区别有点类似“绝对路径”和“相对路径”的关系。<code>add</code>方法更加偏向于通过运算（相对与当前字段而言）来更改字段值。举个栗子：如果当前月份是二月，我们向将其改为三月，可以这样<code>add(Calendar.MONTH, 1)</code>；如果我们想将其改为一月，可以这样<code>add(Calendar.MONTH, -1)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;java中有一种特殊的对象，我们平时都是通过字符串的形式使用它，但在底层却时不时涉及到一些数字运算；除此之外，我们对它的字符串输出形式，往往还是百般挑剔，猜猜它是谁？&lt;/p&gt;&lt;p&gt;：-）没错，它就是java中的Date对象&lt;/p&gt;&lt;/blockquo
      
    
    </summary>
    
      <category term="java-se" scheme="http://rqsir.github.io/categories/java-se/"/>
    
    
      <category term="java - Date" scheme="http://rqsir.github.io/tags/java-Date/"/>
    
      <category term="java - SimpleDateFormat" scheme="http://rqsir.github.io/tags/java-SimpleDateFormat/"/>
    
      <category term="java - Calendar" scheme="http://rqsir.github.io/tags/java-Calendar/"/>
    
  </entry>
  
  <entry>
    <title>java中根类Object的常用方法</title>
    <link href="http://rqsir.github.io/2019/04/29/java%E4%B8%AD%E6%A0%B9%E7%B1%BBObject%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://rqsir.github.io/2019/04/29/java中根类Object的常用方法/</id>
    <published>2019-04-28T16:00:00.000Z</published>
    <updated>2019-05-18T17:21:15.257Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Object类，一般我们习惯称之为超类或根父类，这代表了它至高无上的低位。它是所有类的父类，它当中的一些属性将被所有类继承。</p><p>这里我主要总结了<code>toString()</code>、<code>equals()</code>以及<code>hashCode()</code>这3个方法。</p></blockquote><h2 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString()方法"></a><code>toString()</code>方法</h2><p>这里首先引入一段jdk源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns a string representation of the object. In general, the</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> toString&#125; method returns a string that</span></span><br><span class="line"><span class="comment">    * "textually represents" this object. The result should</span></span><br><span class="line"><span class="comment">    * be a concise but informative representation that is easy for a</span></span><br><span class="line"><span class="comment">    * person to read.</span></span><br><span class="line"><span class="comment">    * It is recommended that all subclasses override this method.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * The &#123;<span class="doctag">@code</span> toString&#125; method for class &#123;<span class="doctag">@code</span> Object&#125;</span></span><br><span class="line"><span class="comment">    * returns a string consisting of the name of the class of which the</span></span><br><span class="line"><span class="comment">    * object is an instance, the at-sign character `&#123;<span class="doctag">@code</span> @&#125;', and</span></span><br><span class="line"><span class="comment">    * the unsigned hexadecimal representation of the hash code of the</span></span><br><span class="line"><span class="comment">    * object. In other words, this method returns a string equal to the</span></span><br><span class="line"><span class="comment">    * value of:</span></span><br><span class="line"><span class="comment">    * &lt;blockquote&gt;</span></span><br><span class="line"><span class="comment">    * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">    * getClass().getName() + '@' + Integer.toHexString(hashCode())</span></span><br><span class="line"><span class="comment">    * &lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  a string representation of the object.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这个方法主要完成<code>Object</code>对象的文本化输出。输出内容由<code>getClass().getName()</code>和<code>Integer.toHexString(hashCode())</code>两部分组成。第一部分是：对象所属的包名加类名，第二个部分是：对象地址的<code>hash</code>表示。</p><p>在实际的开发中，我们一般会通过<code>IDE</code>自动重写该方法。</p><h2 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals()方法"></a><code>equals()</code>方法</h2><p>二话不说，上jdk源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Indicates whether some other object is "equal to" this one.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The &#123;<span class="doctag">@code</span> equals&#125; method implements an equivalence relation</span></span><br><span class="line"><span class="comment">     * on non-null object references:</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;It is &lt;i&gt;reflexive&lt;/i&gt;: for any non-null reference value</span></span><br><span class="line"><span class="comment">     *     &#123;<span class="doctag">@code</span> x&#125;, &#123;<span class="doctag">@code</span> x.equals(x)&#125; should return</span></span><br><span class="line"><span class="comment">     *     &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;It is &lt;i&gt;symmetric&lt;/i&gt;: for any non-null reference values</span></span><br><span class="line"><span class="comment">     *     &#123;<span class="doctag">@code</span> x&#125; and &#123;<span class="doctag">@code</span> y&#125;, &#123;<span class="doctag">@code</span> x.equals(y)&#125;</span></span><br><span class="line"><span class="comment">     *     should return &#123;<span class="doctag">@code</span> true&#125; if and only if</span></span><br><span class="line"><span class="comment">     *     &#123;<span class="doctag">@code</span> y.equals(x)&#125; returns &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;It is &lt;i&gt;transitive&lt;/i&gt;: for any non-null reference values</span></span><br><span class="line"><span class="comment">     *     &#123;<span class="doctag">@code</span> x&#125;, &#123;<span class="doctag">@code</span> y&#125;, and &#123;<span class="doctag">@code</span> z&#125;, if</span></span><br><span class="line"><span class="comment">     *     &#123;<span class="doctag">@code</span> x.equals(y)&#125; returns &#123;<span class="doctag">@code</span> true&#125; and</span></span><br><span class="line"><span class="comment">     *     &#123;<span class="doctag">@code</span> y.equals(z)&#125; returns &#123;<span class="doctag">@code</span> true&#125;, then</span></span><br><span class="line"><span class="comment">     *     &#123;<span class="doctag">@code</span> x.equals(z)&#125; should return &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;It is &lt;i&gt;consistent&lt;/i&gt;: for any non-null reference values</span></span><br><span class="line"><span class="comment">     *     &#123;<span class="doctag">@code</span> x&#125; and &#123;<span class="doctag">@code</span> y&#125;, multiple invocations of</span></span><br><span class="line"><span class="comment">     *     &#123;<span class="doctag">@code</span> x.equals(y)&#125; consistently return &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment">     *     or consistently return &#123;<span class="doctag">@code</span> false&#125;, provided no</span></span><br><span class="line"><span class="comment">     *     information used in &#123;<span class="doctag">@code</span> equals&#125; comparisons on the</span></span><br><span class="line"><span class="comment">     *     objects is modified.</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;For any non-null reference value &#123;<span class="doctag">@code</span> x&#125;,</span></span><br><span class="line"><span class="comment">     *     &#123;<span class="doctag">@code</span> x.equals(null)&#125; should return &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The &#123;<span class="doctag">@code</span> equals&#125; method for class &#123;<span class="doctag">@code</span> Object&#125; implements</span></span><br><span class="line"><span class="comment">     * the most discriminating possible equivalence relation on objects;</span></span><br><span class="line"><span class="comment">     * that is, for any non-null reference values &#123;<span class="doctag">@code</span> x&#125; and</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> y&#125;, this method returns &#123;<span class="doctag">@code</span> true&#125; if and only</span></span><br><span class="line"><span class="comment">     * if &#123;<span class="doctag">@code</span> x&#125; and &#123;<span class="doctag">@code</span> y&#125; refer to the same object</span></span><br><span class="line"><span class="comment">     * (&#123;<span class="doctag">@code</span> x == y&#125; has the value &#123;<span class="doctag">@code</span> true&#125;).</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Note that it is generally necessary to override the &#123;<span class="doctag">@code</span> hashCode&#125;</span></span><br><span class="line"><span class="comment">     * method whenever this method is overridden, so as to maintain the</span></span><br><span class="line"><span class="comment">     * general contract for the &#123;<span class="doctag">@code</span> hashCode&#125; method, which states</span></span><br><span class="line"><span class="comment">     * that equal objects must have equal hash codes.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   obj   the reference object with which to compare.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  &#123;<span class="doctag">@code</span> true&#125; if this object is the same as the obj</span></span><br><span class="line"><span class="comment">     *          argument; &#123;<span class="doctag">@code</span> false&#125; otherwise.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     #hashCode()</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     java.util.HashMap</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如注释所述，<code>equals</code>方法主要用于判断非空对象与另一给定对象，是否为同一对象（在堆内存中位于同一地址空间）。在实际开发中，我们一般会选择重写该方法去完成更具体的功能。例如，在jdk中的<code>String</code>类中，就重写了<code>equals</code>方法，去判断两个字符串是否相等。</p><h2 id="hashCode-方法"><a href="#hashCode-方法" class="headerlink" title="hashCode()方法"></a><code>hashCode()</code>方法</h2><p>jdk源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns a hash code value for the object. This method is</span></span><br><span class="line"><span class="comment">    * supported for the benefit of hash tables such as those provided by</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> java.util.HashMap&#125;.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * The general contract of &#123;<span class="doctag">@code</span> hashCode&#125; is:</span></span><br><span class="line"><span class="comment">    * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">    * &lt;li&gt;Whenever it is invoked on the same object more than once during</span></span><br><span class="line"><span class="comment">    *     an execution of a Java application, the &#123;<span class="doctag">@code</span> hashCode&#125; method</span></span><br><span class="line"><span class="comment">    *     must consistently return the same integer, provided no information</span></span><br><span class="line"><span class="comment">    *     used in &#123;<span class="doctag">@code</span> equals&#125; comparisons on the object is modified.</span></span><br><span class="line"><span class="comment">    *     This integer need not remain consistent from one execution of an</span></span><br><span class="line"><span class="comment">    *     application to another execution of the same application.</span></span><br><span class="line"><span class="comment">    * &lt;li&gt;If two objects are equal according to the &#123;<span class="doctag">@code</span> equals(Object)&#125;</span></span><br><span class="line"><span class="comment">    *     method, then calling the &#123;<span class="doctag">@code</span> hashCode&#125; method on each of</span></span><br><span class="line"><span class="comment">    *     the two objects must produce the same integer result.</span></span><br><span class="line"><span class="comment">    * &lt;li&gt;It is &lt;em&gt;not&lt;/em&gt; required that if two objects are unequal</span></span><br><span class="line"><span class="comment">    *     according to the &#123;<span class="doctag">@link</span> java.lang.Object#equals(java.lang.Object)&#125;</span></span><br><span class="line"><span class="comment">    *     method, then calling the &#123;<span class="doctag">@code</span> hashCode&#125; method on each of the</span></span><br><span class="line"><span class="comment">    *     two objects must produce distinct integer results.  However, the</span></span><br><span class="line"><span class="comment">    *     programmer should be aware that producing distinct integer results</span></span><br><span class="line"><span class="comment">    *     for unequal objects may improve the performance of hash tables.</span></span><br><span class="line"><span class="comment">    * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * As much as is reasonably practical, the hashCode method defined by</span></span><br><span class="line"><span class="comment">    * class &#123;<span class="doctag">@code</span> Object&#125; does return distinct integers for distinct</span></span><br><span class="line"><span class="comment">    * objects. (This is typically implemented by converting the internal</span></span><br><span class="line"><span class="comment">    * address of the object into an integer, but this implementation</span></span><br><span class="line"><span class="comment">    * technique is not required by the</span></span><br><span class="line"><span class="comment">    * Java&amp;trade; programming language.)</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  a hash code value for this object.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>     java.lang.Object#equals(java.lang.Object)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>     java.lang.System#identityHashCode</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p><code>hashCode</code>方法，返回的是对象在内存中地址的<code>hash</code>编码。这在<code>HashTable</code>中会用到，主要是用作对象存储的<code>index</code>使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;Object类，一般我们习惯称之为超类或根父类，这代表了它至高无上的低位。它是所有类的父类，它当中的一些属性将被所有类继承。&lt;/p&gt;&lt;p&gt;这里我主要总结了&lt;code&gt;toString()&lt;/code&gt;、&lt;code&gt;equals()&lt;/code&gt;以及&lt;
      
    
    </summary>
    
      <category term="java-se" scheme="http://rqsir.github.io/categories/java-se/"/>
    
    
      <category term="java - Object" scheme="http://rqsir.github.io/tags/java-Object/"/>
    
  </entry>
  
  <entry>
    <title>java API -- System类</title>
    <link href="http://rqsir.github.io/2019/04/29/java-API-System%E7%B1%BB/"/>
    <id>http://rqsir.github.io/2019/04/29/java-API-System类/</id>
    <published>2019-04-28T16:00:00.000Z</published>
    <updated>2019-05-18T17:16:31.180Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>System类是我们一开始学习java就接触到的一个常用类，在这个类中封装了许多和系统底层有关的方法供我们调用。</p></blockquote><h2 id="所属包"><a href="#所属包" class="headerlink" title="所属包"></a>所属包</h2><p>首先，查看jdk我们可以知道，<code>System</code>类是位于<code>java.lang</code>包下的。因此，是无需导包就能直接使用的。</p><h2 id="类描述"><a href="#类描述" class="headerlink" title="类描述"></a>类描述</h2><p>我们先看一段官方注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The &lt;code&gt;System&lt;/code&gt; class contains several useful class fields</span></span><br><span class="line"><span class="comment"> * and methods. It cannot be instantiated.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Among the facilities provided by the &lt;code&gt;System&lt;/code&gt; class</span></span><br><span class="line"><span class="comment"> * are standard input, standard output, and error output streams;</span></span><br><span class="line"><span class="comment"> * access to externally defined properties and environment</span></span><br><span class="line"><span class="comment"> * variables; a means of loading files and libraries; and a utility</span></span><br><span class="line"><span class="comment"> * method for quickly copying a portion of an array.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  unascribed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>   JDK1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>大意就是，<code>System</code>这个类一个基础工具类，它无法被实例化。</p><p>它主要用于标准输入、输出流的控制，以及数组的操作等。</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Don't let anyone instantiate this class */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">System</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>由于构造函数的私有属性，因此<code>System</code>类是无法实例化的。</p><h2 id="常用成员方法"><a href="#常用成员方法" class="headerlink" title="常用成员方法"></a>常用成员方法</h2><p><strong>输出方法</strong></p><p>这里介绍两个方法，分别是：<code>System.out.println()</code>以及<code>System.err.println()</code>。</p><p>实际上，这两个方法都是通过<code>System</code>内的静态不可变成员变量<code>out</code>或<code>err</code>，并且它们都是<code>PrintStream</code>类的的对象引用，然后通过对象调用类中方法。</p><p><strong>数组操作方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">* <span class="meta">@param</span>      src      the source array.</span><br><span class="line">    * <span class="meta">@param</span>      srcPos   starting position in the source array.</span><br><span class="line">    * <span class="meta">@param</span>      dest     the destination array.</span><br><span class="line">    * <span class="meta">@param</span>      destPos  starting position in the destination data.</span><br><span class="line">    * <span class="meta">@param</span>      length   the number of array elements to be copied.</span><br><span class="line">    * <span class="meta">@exception</span>  IndexOutOfBoundsException  <span class="keyword">if</span> copying would cause</span><br><span class="line">    *               access of data outside array bounds.</span><br><span class="line">    * @exception  ArrayStoreException  if an element in the &lt;code&gt;src&lt;/code&gt;</span><br><span class="line">    *               array could not be stored into the &lt;code&gt;dest&lt;/code&gt; array</span><br><span class="line">    *               because of a type mismatch.</span><br><span class="line">    * @exception  NullPointerException if either &lt;code&gt;src&lt;/code&gt; or</span><br><span class="line">    *               &lt;code&gt;dest&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.</span><br><span class="line">    */</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,  <span class="keyword">int</span>  srcPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       Object dest, <span class="keyword">int</span> destPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">int</span> length)</span></span>;</span><br></pre></td></tr></table></figure><p>从源数组<code>src</code>向目的数组<code>dest</code>，复制给定长度<code>length</code>的数据。</p><p><strong>退出<code>jvm</code>方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Terminates the currently running Java Virtual Machine. The</span></span><br><span class="line"><span class="comment">    * argument serves as a status code; by convention, a nonzero status</span></span><br><span class="line"><span class="comment">    * code indicates abnormal termination.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * This method calls the &lt;code&gt;exit&lt;/code&gt; method in class</span></span><br><span class="line"><span class="comment">    * &lt;code&gt;Runtime&lt;/code&gt;. This method never returns normally.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * The call &lt;code&gt;System.exit(n)&lt;/code&gt; is effectively equivalent to</span></span><br><span class="line"><span class="comment">    * the call:</span></span><br><span class="line"><span class="comment">    * &lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment">    * Runtime.getRuntime().exit(n)</span></span><br><span class="line"><span class="comment">    * &lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>      status   exit status.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span>  SecurityException</span></span><br><span class="line"><span class="comment">    *        if a security manager exists and its &lt;code&gt;checkExit&lt;/code&gt;</span></span><br><span class="line"><span class="comment">    *        method doesn't allow exit with the specified status.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>        java.lang.Runtime#exit(int)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span> </span>&#123;</span><br><span class="line">       Runtime.getRuntime().exit(status);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>方法描述为：终止正在运行的<code>jvm</code>，并返回一个状态码。依照惯例：返回‘0’，代表正常退出 ；其他值，代表异常退出。</p><p><strong>垃圾回收方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Runs the garbage collector.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Calling the &lt;code&gt;gc&lt;/code&gt; method suggests that the Java Virtual</span></span><br><span class="line"><span class="comment">     * Machine expend effort toward recycling unused objects in order to</span></span><br><span class="line"><span class="comment">     * make the memory they currently occupy available for quick reuse.</span></span><br><span class="line"><span class="comment">     * When control returns from the method call, the Java Virtual</span></span><br><span class="line"><span class="comment">     * Machine has made a best effort to reclaim space from all discarded</span></span><br><span class="line"><span class="comment">     * objects.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The call &lt;code&gt;System.gc()&lt;/code&gt; is effectively equivalent to the</span></span><br><span class="line"><span class="comment">     * call:</span></span><br><span class="line"><span class="comment">     * &lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment">     * Runtime.getRuntime().gc()</span></span><br><span class="line"><span class="comment">     * &lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     java.lang.Runtime#gc()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Runtime.getRuntime().gc();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>调用<code>jvm</code>的垃圾回收机制，去尽可能的回收系统资源。一般与<code>Object</code>类的<code>finalize()</code>方法配套使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Called by the garbage collector on an object when garbage collection</span><br><span class="line">    * determines that there are no more references to the object.</span><br><span class="line">    * A subclass overrides the &#123;@code finalize&#125; method to dispose of</span><br><span class="line">    * system resources or to perform other cleanup.</span><br><span class="line">    * &lt;p&gt;</span><br><span class="line"> protected void finalize() throws Throwable &#123; &#125;</span><br></pre></td></tr></table></figure><p>流程是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Student(); <span class="comment">//创建匿名对象，方便gc回收</span></span><br><span class="line">        System.gc();   <span class="comment">//调用jvm回收机制</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"在这里完成一些收尾工作"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果是：可能打印出“在这里完成一些收尾工作”。因为gc不能保证每次都能回收<code>Student</code>资源（the Java Virtual Machine has made a best effort to reclaim space from all discarded）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;System类是我们一开始学习java就接触到的一个常用类，在这个类中封装了许多和系统底层有关的方法供我们调用。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;所属包&quot;&gt;&lt;a href=&quot;#所属包&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
      <category term="java-se" scheme="http://rqsir.github.io/categories/java-se/"/>
    
    
      <category term="java - System" scheme="http://rqsir.github.io/tags/java-System/"/>
    
  </entry>
  
  <entry>
    <title>java -- 多态</title>
    <link href="http://rqsir.github.io/2019/04/26/java-%E5%A4%9A%E6%80%81/"/>
    <id>http://rqsir.github.io/2019/04/26/java-多态/</id>
    <published>2019-04-25T16:00:00.000Z</published>
    <updated>2019-05-18T16:55:39.397Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>多态的前提</strong>：</p><ul><li>存在子父类继承关系（或子类和父类接口实现关系）</li><li>存在方法重写</li><li>父类（或父接口）引用指向子类对象</li></ul><p><strong>动态绑定</strong>：</p><p>​ 运行期间调用的方法，是根据具体的类型决定的。</p><h2 id="多态的成员特点"><a href="#多态的成员特点" class="headerlink" title="多态的成员特点"></a>多态的成员特点</h2><table><thead><tr><th style="text-align:center">成员分类</th><th style="text-align:center">特点</th></tr></thead><tbody><tr><td style="text-align:center">成员变量</td><td style="text-align:center">编译时看的是左边，运行时看的是左边</td></tr><tr><td style="text-align:center">成员方法</td><td style="text-align:center">编译时看的是左边，运行时看的是右边（动态绑定）</td></tr><tr><td style="text-align:center">静态成员方法</td><td style="text-align:center">编译时看的是左边，运行时看的也是左边</td></tr></tbody></table><p><strong>举例说明</strong></p><p>先定义父类和子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dad</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"我是父类方法"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"我是父类静态方法"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Kid</span> <span class="keyword">extends</span> <span class="title">Dad</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"我是子类方法"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"我是子类静态方法"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1 对于成员变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoymorphicDemo</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">                Dad d = <span class="keyword">new</span> Kid(); </span><br><span class="line"><span class="comment">//d.num 编译时，首先会查看父类Dad中是否存在num成员变量，如不存在，则会报错，这就是“编译看左边”</span></span><br><span class="line">                System.out.println(d.num);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出 20</span></span><br><span class="line"><span class="comment">//这就说明最后输出的是父类Dad中的成员变量，即所谓“运行看左边”</span></span><br></pre></td></tr></table></figure><p>2 对于成员方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoymorphicDemo2</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">                Dad d = <span class="keyword">new</span> Kid();</span><br><span class="line"><span class="comment">//d.method()编译时，首先会查看父类Dad中是否存在method成员方法，不存在，就会报错，即“编译看左边”</span></span><br><span class="line">                d.method();</span><br><span class="line">      </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出  我是子类方法</span></span><br><span class="line"><span class="comment">//最后执行的是子类成员方法，即所谓的“运行看右边”，这里涉及运行期间的编译器“动态绑定”</span></span><br></pre></td></tr></table></figure><p>3 对于静态成员方法</p><p>与成员变量类似，这里不在赘述。</p><h2 id="多态中的向上转型和向下转型"><a href="#多态中的向上转型和向下转型" class="headerlink" title="多态中的向上转型和向下转型"></a>多态中的向上转型和向下转型</h2><p>本质上属于<strong>引用数据类型</strong>的转型问题。可以和基本数据类型转型进行对比</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">基本数据类型</th><th style="text-align:center">引用数据类型</th></tr></thead><tbody><tr><td style="text-align:center">自然转型</td><td style="text-align:center">小存储空间向大存储空间转型</td><td style="text-align:center">子类向父类转型（向上转型）</td></tr><tr><td style="text-align:center">强制转型</td><td style="text-align:center">大存储空间向小存储空间转型</td><td style="text-align:center">父类向子类转型（向下转型）</td></tr></tbody></table><p><em>说明：向上转型，只能调用父类中存在并被重写的方法；向下转型，可以调用子类中特有的方法</em></p><h2 id="多态的优缺点"><a href="#多态的优缺点" class="headerlink" title="多态的优缺点"></a>多态的优缺点</h2><p><strong>优点</strong>：</p><p>由于多态基于继承和接口，故继承和接口所具有的优点，它都具有（如减少代码冗余，可维护，模块化编程等）</p><p><strong>缺点</strong>：</p><p>无法访问子类特有成员</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;多态的前提&lt;/strong&gt;：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;存在子父类继承关系（或子类和父类接口实现关系）&lt;/li
      
    
    </summary>
    
      <category term="java-se" scheme="http://rqsir.github.io/categories/java-se/"/>
    
    
      <category term="java多态" scheme="http://rqsir.github.io/tags/java%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>java -- 修饰符总结</title>
    <link href="http://rqsir.github.io/2019/04/26/java-%E4%BF%AE%E9%A5%B0%E7%AC%A6%E6%80%BB%E7%BB%93/"/>
    <id>http://rqsir.github.io/2019/04/26/java-修饰符总结/</id>
    <published>2019-04-25T16:00:00.000Z</published>
    <updated>2019-05-18T17:02:26.308Z</updated>
    
    <content type="html"><![CDATA[<h2 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h2><ul><li><code>public</code>：所有类都可以访问</li><li><code>private</code>：当前类可以访问</li><li><code>default（默认，什么都不写）</code>：同一包下，可以访问</li><li><code>protected</code>：子类可以访问</li></ul><h2 id="修饰符总结"><a href="#修饰符总结" class="headerlink" title="修饰符总结"></a>修饰符总结</h2><table><thead><tr><th style="text-align:center">修饰符</th><th style="text-align:center">类</th><th style="text-align:center">成员变量</th><th style="text-align:center">成员方法</th><th style="text-align:center">构造方法</th></tr></thead><tbody><tr><td style="text-align:center">public</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">default</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">protected</td><td style="text-align:center"></td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">private</td><td style="text-align:center"></td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">abstract</td><td style="text-align:center">Y</td><td style="text-align:center"></td><td style="text-align:center">Y</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">static</td><td style="text-align:center"></td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">final</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr></tbody></table><p>修饰符使用常用规则：</p><ul><li>一般使用<code>public</code>修饰类，一个java文件中最好只有一个类。如果一个文件中有多个类，类名和文件名相同的类，必须用<code>public</code>修饰；其余类不能用<code>public</code>修饰。</li><li>一般用<code>private</code>修饰成员变量，并提供相应的<code>get</code>、<code>set</code>方法</li><li>一般用<code>public</code>修饰成员方法，除非那些你不想让人调用的方法，可以用<code>private</code>修饰。</li><li>一般用<code>public</code>修饰构造方法，除非你不想让别人实例化这个类，可以用<code>private</code>修饰。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;权限修饰符&quot;&gt;&lt;a href=&quot;#权限修饰符&quot; class=&quot;headerlink&quot; title=&quot;权限修饰符&quot;&gt;&lt;/a&gt;权限修饰符&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;public&lt;/code&gt;：所有类都可以访问&lt;/li&gt;&lt;li&gt;&lt;code&gt;private&lt;/c
      
    
    </summary>
    
      <category term="java-se" scheme="http://rqsir.github.io/categories/java-se/"/>
    
    
      <category term="java修饰符" scheme="http://rqsir.github.io/tags/java%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>java中的接口 &amp;&amp; 匿名对象</title>
    <link href="http://rqsir.github.io/2019/04/26/java%E4%B8%AD%E7%9A%84%E6%8E%A5%E5%8F%A3-%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1/"/>
    <id>http://rqsir.github.io/2019/04/26/java中的接口-匿名对象/</id>
    <published>2019-04-25T16:00:00.000Z</published>
    <updated>2019-05-18T17:00:09.015Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java中的接口"><a href="#java中的接口" class="headerlink" title="java中的接口"></a>java中的接口</h1><p>接口是为了解决<code>java</code>中继承的单一局限性，而提出来的。</p><p>接口是一个比抽象类还要抽象的类，其中所有成员方法都是抽象方法，类通过关键字<code>implements</code>来实现接口</p><p>接口可以看做是拓展类的各种功能的一个全抽象父类，它可以实现针对不同功能，开发不同接口，最后再将接口合并，实现了模块化独立编程的目的。</p><h2 id="接口的成员特点"><a href="#接口的成员特点" class="headerlink" title="接口的成员特点"></a>接口的成员特点</h2><table><thead><tr><th style="text-align:center">成员分类</th><th style="text-align:center">特点</th></tr></thead><tbody><tr><td style="text-align:center">成员方法</td><td style="text-align:center">全部为抽象方法<br>默认使用public abstract修饰<br>只能使用public abstract修饰</td></tr><tr><td style="text-align:center">成员变量</td><td style="text-align:center">默认使用public static final修饰，相当于常量</td></tr><tr><td style="text-align:center">构造方法</td><td style="text-align:center">没有构造方法，因为不需要初始化成员变量</td></tr></tbody></table><p><em>注意：接口不能实例化，实现接口需重写其中所有方法</em></p><h2 id="接口与类之间的关系"><a href="#接口与类之间的关系" class="headerlink" title="接口与类之间的关系"></a>接口与类之间的关系</h2><table><thead><tr><th style="text-align:center">分类</th><th style="text-align:center">关系</th></tr></thead><tbody><tr><td style="text-align:center">类与类</td><td style="text-align:center">继承关系，单一继承，多层继承</td></tr><tr><td style="text-align:center">类与接口</td><td style="text-align:center">实现关系，可以一对多，一个类实现多个接口</td></tr><tr><td style="text-align:center">接口与接口</td><td style="text-align:center">继承关系，单一继承，多层继承</td></tr></tbody></table><h2 id="类与接口的综合举例"><a href="#类与接口的综合举例" class="headerlink" title="类与接口的综合举例"></a>类与接口的综合举例</h2><p><img src="https://raw.githubusercontent.com/RQsir/blog_pic_bed/master/img/81a5cfb3ly1g2fscniptgj211r0f4t9b.jpg?token=AKZRZCYUW777DNU6XPFZ6324YQI4M" alt=""></p><h1 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h1><p><strong>匿名对象</strong>：没有名字的对象。</p><p><strong>应用场景</strong>：</p><ol><li>当方法只调用一次时，可以使用匿名对象</li><li>可以当作参数传递，但是无法在传参之前做其他事。</li></ol><p><em>注意：匿名对象可以调用成员变量进行赋值，但由于无法在后续操作中使用，所有没有意义</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java中的接口&quot;&gt;&lt;a href=&quot;#java中的接口&quot; class=&quot;headerlink&quot; title=&quot;java中的接口&quot;&gt;&lt;/a&gt;java中的接口&lt;/h1&gt;&lt;p&gt;接口是为了解决&lt;code&gt;java&lt;/code&gt;中继承的单一局限性，而提出来的。&lt;/p&gt;&lt;p
      
    
    </summary>
    
      <category term="java-se" scheme="http://rqsir.github.io/categories/java-se/"/>
    
    
      <category term="java匿名对象" scheme="http://rqsir.github.io/tags/java%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="java接口" scheme="http://rqsir.github.io/tags/java%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>java中的静态 &amp;&amp; 代码块</title>
    <link href="http://rqsir.github.io/2019/04/25/java%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81-%E4%BB%A3%E7%A0%81%E5%9D%97/"/>
    <id>http://rqsir.github.io/2019/04/25/java中的静态-代码块/</id>
    <published>2019-04-24T16:00:00.000Z</published>
    <updated>2019-05-18T16:53:19.864Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java中的静态修饰符"><a href="#java中的静态修饰符" class="headerlink" title="java中的静态修饰符"></a>java中的静态修饰符</h1><p>修饰符<code>static</code>： 是一个关键字，用于修饰成员变量和成员方法</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>被所有对象共享</li><li>可以使用类名调用</li><li>静态加载优先于对象</li><li>随着类的加载而加载</li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li><p>静态方法</p><p>静态方法只可以调用静态的成员（包括方法和变量）</p></li><li><p>非静态方法</p><p>既可以调用非静态方法和变量，也可以调用静态的方法和变量</p></li><li><p>由于静态方法优先于对象创建，故静态方法中没有<code>this</code>对象</p></li></ol><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p><code>static</code>常用来修饰工具类中的方法和变量，例如JDK中<code>Math</code>工具类等。</p><h1 id="java中的代码块"><a href="#java中的代码块" class="headerlink" title="java中的代码块"></a>java中的代码块</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>形式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">"这是一个java代码块"</span>);</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分类：</p><ol><li><p>局部代码块</p><p><em>和局部变量类似，出现在方法内部，主要用于限制变量和方法的作用域，即代码块外不能访问代码块中的变量和方法</em></p></li><li><p>构造代码块</p><p><em>和类中的构造方法类似，出现在类内部，用来存放基于类的所有对象的公共代码部分，可以降低代码冗余度，<strong>会随着对象的创建自动调用</strong></em></p></li><li><p>静态代码块</p><p><em>和静态方法类似，出现在类内部，用来存放类中需要初始化的一些代码（如驱动），<strong>随着类的加载而加载，并且自动调用</strong></em></p></li><li><p>同步代码块</p><p>用于不同线程间的同步问题</p></li></ol><h2 id="一个static和代码块的面试题"><a href="#一个static和代码块的面试题" class="headerlink" title="一个static和代码块的面试题"></a>一个static和代码块的面试题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockTest</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"BlockTest静态代码块执行"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">                System.out.println(<span class="string">"BlockTest构造代码块执行"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BlockTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"BlockTest无参构造执行了"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"BlockTest的主函数执行了"</span>);</span><br><span class="line">                Coder c = <span class="keyword">new</span> Coder();</span><br><span class="line">                Coder c2 = <span class="keyword">new</span> Coder();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"Coder静态代码块执行"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">                System.out.println(<span class="string">"Coder构造代码块执行"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Coder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Coder无参空构造执行"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题：代码如上，请写出程序的执行顺序</p><p>分析如下：</p><p>​ 首先，程序启动，<code>JVM</code>会加载<code>main</code>函数所在类，即<code>BlockTest</code>这个类，这时候它的静态代码块随之加载并自动执行，打印<code>&quot;BlockTest静态代码块执行&quot;</code>。由于<code>main</code>的调用是基于类的加载，并未实例化<code>BlockTest</code>，故其局部代码块和构造方法都不会执行。</p><p>​ 接着，调用<code>main</code>函数，打印<code>&quot;BlockTest的主函数执行了&quot;</code>。接着执行<code>Coder c = new Coder()</code>，会加载<code>Coder</code>类，调用其静态代码块，打印<code>&quot;Coder静态代码块执行&quot;</code>。随后，在生成<code>c</code>对象中，首先调用其类中代码块，打印<code>&quot;Coder构造代码块执行&quot;</code>，然后调用其构造方法，打印<code>&quot;Coder无参空构造执行&quot;</code>。</p><p>​ 最后，执行<code>Coder c2 = new Coder()</code>，和上面类似。不同的是，这时<code>Coder</code>类已经加载，故不会再次调用其静态代码块。但再次生成了一个新的对象<code>c2</code>，因此会调用其类中代码块，打印<code>&quot;Coder构造代码块执行&quot;</code>，接着调用其构造方法，打印<code>&quot;Coder无参空构造执行&quot;</code>。</p><p>​ 总结：整个程序的打印输出为：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BlockTest静态代码块执行</span><br><span class="line">BlockTest的主函数执行了</span><br><span class="line">Coder静态代码块执行</span><br><span class="line">Coder构造代码块执行</span><br><span class="line">Coder无参空构造执行</span><br><span class="line">Coder构造代码块执行</span><br><span class="line">Coder无参空构造执行</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java中的静态修饰符&quot;&gt;&lt;a href=&quot;#java中的静态修饰符&quot; class=&quot;headerlink&quot; title=&quot;java中的静态修饰符&quot;&gt;&lt;/a&gt;java中的静态修饰符&lt;/h1&gt;&lt;p&gt;修饰符&lt;code&gt;static&lt;/code&gt;： 是一个关键字，用于修
      
    
    </summary>
    
      <category term="java-se" scheme="http://rqsir.github.io/categories/java-se/"/>
    
    
      <category term="java静态" scheme="http://rqsir.github.io/tags/java%E9%9D%99%E6%80%81/"/>
    
      <category term="java代码块" scheme="http://rqsir.github.io/tags/java%E4%BB%A3%E7%A0%81%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>java中的继承 &amp;&amp; abstract &amp;&amp; final</title>
    <link href="http://rqsir.github.io/2019/04/25/java%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF-abstract-final/"/>
    <id>http://rqsir.github.io/2019/04/25/java中的继承-abstract-final/</id>
    <published>2019-04-24T16:00:00.000Z</published>
    <updated>2019-05-18T16:49:05.323Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java中的继承"><a href="#java中的继承" class="headerlink" title="java中的继承"></a>java中的继承</h1><p>java中的继承问题分为两类：一是成员变量的继承；二是成员方法的继承。</p><h2 id="成员变量的继承"><a href="#成员变量的继承" class="headerlink" title="成员变量的继承"></a>成员变量的继承</h2><p><strong>特点</strong></p><p>​ 子类只能继承父类的非私有成员变量</p><p><strong>成员变量引用原则（就近原则）</strong></p><p>​ 变量名相同，引用顺序为：局部变量 -&gt; 子类成员变量 -&gt; 父类成员变量</p><p><strong>变量之间的区别调用</strong></p><p>​ <code>this</code>调用子类的成员变量，<code>super</code>调用父类的成员变量</p><p><strong>继承的优点</strong></p><p>​ 能够减少代码冗余，方便代码维护</p><h2 id="成员方法的继承"><a href="#成员方法的继承" class="headerlink" title="成员方法的继承"></a>成员方法的继承</h2><p><strong>特点</strong></p><ul><li>子类只能继承父类的非私有成员方法</li><li>子类重写方法的权限修饰符要大于等于其父类，即父类方法是默认权限修饰，则子类方法可以是默认修饰符或者public修饰符</li></ul><p><strong>成员方法的调用原则（就近原则）</strong></p><p>​ 方法名相同，调用顺序为：子类方法 -&gt; 父类方法</p><p><strong>子父类方法之重写与重载</strong></p><p><em><u>方法重写</u></em>：子类方法与父类方法，不仅方法名相同，而且参数列表相同，返回值也相同，基本上一模一样。只是方法执行代码不同。</p><p><em><u>方法重载</u></em>：两个方法方法名相同，而参数列表不同，这是函数的重载，要与成员函数的重写加以区分。</p><h1 id="this和super总结"><a href="#this和super总结" class="headerlink" title="this和super总结"></a>this和super总结</h1><table><thead><tr><th style="text-align:center">关键词</th><th style="text-align:center">含义</th><th style="text-align:center">应用场景</th></tr></thead><tbody><tr><td style="text-align:center">this</td><td style="text-align:center">指向调用方法的当前对象</td><td style="text-align:center">1.调用子类的成员变量<br>2.调用子类的成员方法<br>3.在子类的构造函数的第一行调用子类的其他构造函数</td></tr><tr><td style="text-align:center">super</td><td style="text-align:center">指向当前对象的父类对象</td><td style="text-align:center">1.调用父类的成员变量<br>2.调用父类的成员方法<br>3.在子类的构造函数的第一行调用父类的构造函数</td></tr></tbody></table><h1 id="java关键字之abstract"><a href="#java关键字之abstract" class="headerlink" title="java关键字之abstract"></a>java关键字之<code>abstract</code></h1><p><code>abstract</code>可以用来修饰类和方法，被修饰的类和方法分别被称之为“抽象类”和“抽象方法”</p><p><strong>概念解析</strong></p><p>​ <em><u>抽象类</u></em>：只有含有抽象方法的类，肯定是抽象类；抽象类也可以没有抽象方法，不过这样就失去了抽象类的意义。另外，抽象类中可以含有非抽象方法。抽象类无法实例化，<u>但这并不是因为抽象类没有构造方法，只是因为抽象类中存在抽象函数。</u></p><p>​ <em><u>抽象方法</u></em>：没有方法体，由关键词<code>abstract</code>修饰的方法叫做抽象方法。</p><p><em>注意：一个类继承了抽象类，需要重写其中的所有抽象方法。否则，可以将其声明为抽象类</em></p><p><strong>抽象类的成员特点</strong></p><table><thead><tr><th style="text-align:center">分类</th><th style="text-align:center">特点</th></tr></thead><tbody><tr><td style="text-align:center">成员变量</td><td style="text-align:center">1. 可以有成员变量<br>2. 可以有常量</td></tr><tr><td style="text-align:center">成员方法</td><td style="text-align:center">1.可以有抽象方法<br>2.可以有非抽象方法</td></tr><tr><td style="text-align:center">构造方法</td><td style="text-align:center">有构造方法，需要对抽象类成员变量进行初始化<br>构造方法会在对象实例化时，自动调用；如果调用失败，则实例化也失败。</td></tr></tbody></table><h1 id="java关键字之final"><a href="#java关键字之final" class="headerlink" title="java关键字之final"></a>java关键字之<code>final</code></h1><ul><li><code>final</code>修饰的类，无法被继承</li><li><code>final</code>修饰的变量为常量，无法修改。且必须初始化，可以显示初始化（即声明时就初始化）或在构造函数初始化</li><li><code>final</code>修饰的成员方法，无法被重写</li></ul><h1 id="类无法实例化的两种方法"><a href="#类无法实例化的两种方法" class="headerlink" title="类无法实例化的两种方法"></a>类无法实例化的两种方法</h1><ol><li>给类加上<code>abstract</code>关键字，使其成为抽象类。</li><li>给类的构造函数加上<code>private</code>关键字，使其在<code>new</code>时，由于构造方法私有不可访问的特性，导致类实例化失败。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java中的继承&quot;&gt;&lt;a href=&quot;#java中的继承&quot; class=&quot;headerlink&quot; title=&quot;java中的继承&quot;&gt;&lt;/a&gt;java中的继承&lt;/h1&gt;&lt;p&gt;java中的继承问题分为两类：一是成员变量的继承；二是成员方法的继承。&lt;/p&gt;&lt;h2 id=
      
    
    </summary>
    
      <category term="java-se" scheme="http://rqsir.github.io/categories/java-se/"/>
    
    
      <category term="java继承" scheme="http://rqsir.github.io/tags/java%E7%BB%A7%E6%89%BF/"/>
    
      <category term="java - abstract" scheme="http://rqsir.github.io/tags/java-abstract/"/>
    
      <category term="java - fianl" scheme="http://rqsir.github.io/tags/java-fianl/"/>
    
      <category term="this &amp;&amp; super" scheme="http://rqsir.github.io/tags/this-super/"/>
    
      <category term="java中类无法实例化" scheme="http://rqsir.github.io/tags/java%E4%B8%AD%E7%B1%BB%E6%97%A0%E6%B3%95%E5%AE%9E%E4%BE%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>java -- 文本文件读写</title>
    <link href="http://rqsir.github.io/2019/04/24/java-%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/"/>
    <id>http://rqsir.github.io/2019/04/24/java-文本文件读写/</id>
    <published>2019-04-23T16:00:00.000Z</published>
    <updated>2019-05-18T16:36:24.018Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文本文件写操作"><a href="#文本文件写操作" class="headerlink" title="文本文件写操作"></a>文本文件写操作</h1><h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><p>1、创建<code>FileWriter</code>对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"~/a.txt"</span>); <span class="comment">//覆盖写入</span></span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"~/a.txt"</span>,<span class="keyword">true</span>); <span class="comment">//追加写入</span></span><br></pre></td></tr></table></figure><p>2、写入字符串及刷新缓冲区</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fw.write(<span class="string">"HelloWorld!"</span>);</span><br><span class="line">fw.flush();</span><br></pre></td></tr></table></figure><p>3、关闭IO，通知系统释放相关资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fw.close();</span><br></pre></td></tr></table></figure><h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><p>不同操作系统的换行转义字符存在差异，总结如下：</p><table><thead><tr><th style="text-align:center">系统</th><th style="text-align:center">换行转义字符</th></tr></thead><tbody><tr><td style="text-align:center">windows</td><td style="text-align:center">\r\n</td></tr><tr><td style="text-align:center">mactintosh</td><td style="text-align:center">\r</td></tr><tr><td style="text-align:center">linux</td><td style="text-align:center">\n</td></tr></tbody></table><h1 id="文本文件读操作"><a href="#文本文件读操作" class="headerlink" title="文本文件读操作"></a>文本文件读操作</h1><h2 id="通过字符进行读取"><a href="#通过字符进行读取" class="headerlink" title="通过字符进行读取"></a>通过字符进行读取</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建FileReader对象</span></span><br><span class="line">FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"a.txt"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.读取单个字符</span></span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.循环读取，结束标志为“-1”</span></span><br><span class="line"><span class="keyword">while</span> (-<span class="number">1</span> != (c = fr.read()))&#123;</span><br><span class="line">    System.out.print((<span class="keyword">char</span>)c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过字符数组读取"><a href="#通过字符数组读取" class="headerlink" title="通过字符数组读取"></a>通过字符数组读取</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建FileReader对象</span></span><br><span class="line">FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"a.txt"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.读取文件到字符数组</span></span><br><span class="line"><span class="keyword">char</span>[] str = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="comment">// len记录读取长度</span></span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.循环读取，结束标志为“-1”</span></span><br><span class="line"><span class="keyword">while</span> ((len = fr.read(str)) != -<span class="number">1</span>)&#123;</span><br><span class="line">    System.out.print(str,<span class="number">0</span>,len); <span class="comment">// 这里必须指定str长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="文本文件高效读写——BufferedReader-amp-BufferedWriter"><a href="#文本文件高效读写——BufferedReader-amp-BufferedWriter" class="headerlink" title="文本文件高效读写——BufferedReader &amp; BufferedWriter"></a>文本文件高效读写——<code>BufferedReader</code> &amp; <code>BufferedWriter</code></h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>基本读写方法和流程相同，只不过构造函数略有差异</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BufferedReader构造函数</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"a.txt"</span>));</span><br><span class="line"><span class="comment">//本质上是将字符暂存在输入流缓冲区，加快读取速率</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//BufferedWriter构造函数</span></span><br><span class="line">BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"a.txt"</span>));</span><br><span class="line"><span class="comment">//本质上是将字符暂存在输出流缓冲区，加快写入速率</span></span><br></pre></td></tr></table></figure><h2 id="特殊函数"><a href="#特殊函数" class="headerlink" title="特殊函数"></a>特殊函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BufferedWriter</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">newLine</span><span class="params">()</span></span>; <span class="comment">//写一个换行符，由系统决定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//BufferedReader</span></span><br><span class="line"><span class="function">String <span class="title">readLine</span><span class="params">()</span></span>; <span class="comment">//读取并返回一行数据，不包括换行符，为空则返回NULL</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;文本文件写操作&quot;&gt;&lt;a href=&quot;#文本文件写操作&quot; class=&quot;headerlink&quot; title=&quot;文本文件写操作&quot;&gt;&lt;/a&gt;文本文件写操作&lt;/h1&gt;&lt;h2 id=&quot;基本流程&quot;&gt;&lt;a href=&quot;#基本流程&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="java-se" scheme="http://rqsir.github.io/categories/java-se/"/>
    
    
      <category term="文本文件读写" scheme="http://rqsir.github.io/tags/%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/"/>
    
  </entry>
  
  <entry>
    <title>java中为何任何对象都可以和String进行拼接？</title>
    <link href="http://rqsir.github.io/2019/04/24/java%E4%B8%AD%E4%B8%BA%E4%BD%95%E4%BB%BB%E4%BD%95%E5%AF%B9%E8%B1%A1%E9%83%BD%E5%8F%AF%E4%BB%A5%E5%92%8CString%E8%BF%9B%E8%A1%8C%E6%8B%BC%E6%8E%A5%EF%BC%9F/"/>
    <id>http://rqsir.github.io/2019/04/24/java中为何任何对象都可以和String进行拼接？/</id>
    <published>2019-04-23T16:00:00.000Z</published>
    <updated>2019-05-18T16:41:11.206Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><p>在学习java-se中偶然对以下代码产生了兴趣，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> String s =<span class="string">"hello"</span> + <span class="number">123</span> + <span class="keyword">true</span> + <span class="number">1.32</span>;</span><br><span class="line"> System.out.println(<span class="string">"拼接后的String为："</span> + s);</span><br><span class="line"></span><br><span class="line"><span class="comment">//out:拼接后的String为：hello123true1.32</span></span><br></pre></td></tr></table></figure><p>由上可知，任何变量（不管是基本数据类型，还是引用数据类型）都可以自动向String进行转换，以完成最后的拼接。那么，这背后的操作是如何实现的呢？</p><h2 id="原理剖析"><a href="#原理剖析" class="headerlink" title="原理剖析"></a>原理剖析</h2><h3 id="引用数据类型向String的转换"><a href="#引用数据类型向String的转换" class="headerlink" title="引用数据类型向String的转换"></a>引用数据类型向String的转换</h3><p>引用数据类型，也就是我们常说的类类型，在java中都共同拥有一个顶层父类<code>Object</code>，而在这个<code>Object</code>类中，我们可以发现这样一个方法<code>toString()</code>，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns a string representation of the object. In general, the</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> toString&#125; method returns a string that</span></span><br><span class="line"><span class="comment">    * "textually represents" this object. The result should</span></span><br><span class="line"><span class="comment">    * be a concise but informative representation that is easy for a</span></span><br><span class="line"><span class="comment">    * person to read.</span></span><br><span class="line"><span class="comment">    * It is recommended that all subclasses override this method.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * The &#123;<span class="doctag">@code</span> toString&#125; method for class &#123;<span class="doctag">@code</span> Object&#125;</span></span><br><span class="line"><span class="comment">    * returns a string consisting of the name of the class of which the</span></span><br><span class="line"><span class="comment">    * object is an instance, the at-sign character `&#123;<span class="doctag">@code</span> @&#125;', and</span></span><br><span class="line"><span class="comment">    * the unsigned hexadecimal representation of the hash code of the</span></span><br><span class="line"><span class="comment">    * object. In other words, this method returns a string equal to the</span></span><br><span class="line"><span class="comment">    * value of:</span></span><br><span class="line"><span class="comment">    * &lt;blockquote&gt;</span></span><br><span class="line"><span class="comment">    * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">    * getClass().getName() + '@' + Integer.toHexString(hashCode())</span></span><br><span class="line"><span class="comment">    * &lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  a string representation of the object.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>通过阅读方法注释，我们不难知道：这个方法是用来输出一个object对象的。所有Java类都是object类的子类，因此所有Java对象都具有<code>toString</code>方法。</p><p>不仅如此，所有Java对象都可以和字符串进行连接运算，当Java对象和字符串进行连接运算时，系统自动调用Java对象toString()方法，返回值和字符串进行连接运算。</p><h3 id="基本数据类型向String的转换"><a href="#基本数据类型向String的转换" class="headerlink" title="基本数据类型向String的转换"></a>基本数据类型向String的转换</h3><p>首先，我们知道在Java中，一切皆对象，但八大基本类型却不是对象。通过上述分析，我们可以解释对象通过<code>toString()</code>转换为字符串后与String对象完成拼接，那么基本数据类型又是如何完成这一过程的呢？</p><p>要解释这一问题，就要涉及java中基本数据类型的自动装箱技术。</p><p>所谓<strong>装箱</strong>，就是把基本类型用它们相对应的引用类型包起来，使它们可以具有对象的特质，如我们可以把int型包装成Integer类的对象，或者把double包装成Double，等等。</p><p>J2SE5.0后提供了自动装箱与拆箱的功能，此功能事实上是<strong>编译器来帮您的忙，编译器在编译时期依您所编写的方法，决定是否进行装箱或拆箱动作</strong>。</p><p><strong>自动装箱</strong>的过程：每当需要一种类型的对象时，这种基本类型就自动地封装到与它相同类型的包装中。</p><p>通过<strong>自动装箱</strong>，我们就可以很好的解释为什么基本数据类型<code>int</code>、<code>float</code>等能够完成向<code>String</code>的转换与拼接。整个过程就是，编译器检测到我们需要进行<code>int</code>与字符串的拼接，首先自动帮我们将<code>int</code>自动装箱成<code>Integer</code>对象，然后<code>Integer</code>对象调用自身的<code>toString()</code>方法转为字符串，最终完成拼接工作。</p><p><em>参考文章</em></p><hr><p><a href="https://www.cnblogs.com/kongzhongqijing/articles/5497498.html" target="_blank" rel="noopener">Java 包装类 拆箱 装箱</a></p><p><a href="https://blog.csdn.net/u012339794/article/details/41223163" target="_blank" rel="noopener">java打印对象和toString方法</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题引入&quot;&gt;&lt;a href=&quot;#问题引入&quot; class=&quot;headerlink&quot; title=&quot;问题引入&quot;&gt;&lt;/a&gt;问题引入&lt;/h2&gt;&lt;p&gt;在学习java-se中偶然对以下代码产生了兴趣，如下：&lt;/p&gt;&lt;figure class=&quot;highlight java&quot;&gt;
      
    
    </summary>
    
      <category term="java-se" scheme="http://rqsir.github.io/categories/java-se/"/>
    
    
      <category term="String拼接" scheme="http://rqsir.github.io/tags/String%E6%8B%BC%E6%8E%A5/"/>
    
  </entry>
  
  <entry>
    <title>成员变量 &amp;&amp; 局部变量 &amp;&amp; 构造方法 &amp;&amp; 导包</title>
    <link href="http://rqsir.github.io/2019/04/22/%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-%E5%AF%BC%E5%8C%85/"/>
    <id>http://rqsir.github.io/2019/04/22/成员变量-局部变量-构造方法-导包/</id>
    <published>2019-04-21T16:00:00.000Z</published>
    <updated>2019-05-18T16:27:42.677Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java中的“成员变量”和“局部变量”"><a href="#java中的“成员变量”和“局部变量”" class="headerlink" title="java中的“成员变量”和“局部变量”"></a>java中的“成员变量”和“局部变量”</h2><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">成员变量</th><th style="text-align:center">局部变量</th></tr></thead><tbody><tr><td style="text-align:center">声明位置不同</td><td style="text-align:center">在方法外</td><td style="text-align:center">在方法内或方法声明上（形参）</td></tr><tr><td style="text-align:center">存储空间不同</td><td style="text-align:center">在堆内存</td><td style="text-align:center">在栈内存</td></tr><tr><td style="text-align:center">生命周期不同</td><td style="text-align:center">随着对象的产生而产生，随着对象的销毁而销毁</td><td style="text-align:center">随着方法的产生而产生，随着方法的销毁而销毁</td></tr><tr><td style="text-align:center">初始化不同</td><td style="text-align:center">系统自动初始化（通过构造函数完成）</td><td style="text-align:center">手动初始化（不初始化会报错）</td></tr></tbody></table><h2 id="java-中的构造方法"><a href="#java-中的构造方法" class="headerlink" title="java 中的构造方法"></a>java 中的构造方法</h2><ul><li><code>java</code>中的构造方法可以重载</li><li><code>java</code>中如果没有构造方法，编译器会自动补上无参构造方法；但一但编译器检测到有构造函数，则不会自动补上无参构造方法，如这时候再调用无参构造，则会报错，因此<strong>推荐手动书写无参构造方法</strong>。</li></ul><h2 id="java中的导包"><a href="#java中的导包" class="headerlink" title="java中的导包"></a>java中的导包</h2><p>属于<code>java.lang</code>包中的类，使用时无需导包，例如<code>Object</code>类、<code>String</code>类等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;java中的“成员变量”和“局部变量”&quot;&gt;&lt;a href=&quot;#java中的“成员变量”和“局部变量”&quot; class=&quot;headerlink&quot; title=&quot;java中的“成员变量”和“局部变量”&quot;&gt;&lt;/a&gt;java中的“成员变量”和“局部变量”&lt;/h2&gt;&lt;tabl
      
    
    </summary>
    
      <category term="java-se" scheme="http://rqsir.github.io/categories/java-se/"/>
    
    
      <category term="“成员变量”和“局部变量”" scheme="http://rqsir.github.io/tags/%E2%80%9C%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E2%80%9D%E5%92%8C%E2%80%9C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E2%80%9D/"/>
    
      <category term="构造方法" scheme="http://rqsir.github.io/tags/%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/"/>
    
      <category term="导包" scheme="http://rqsir.github.io/tags/%E5%AF%BC%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>java中数组是对象吗？</title>
    <link href="http://rqsir.github.io/2019/04/22/java%E4%B8%AD%E6%95%B0%E7%BB%84%E6%98%AF%E5%AF%B9%E8%B1%A1%E5%90%97%EF%BC%9F/"/>
    <id>http://rqsir.github.io/2019/04/22/java中数组是对象吗？/</id>
    <published>2019-04-21T16:00:00.000Z</published>
    <updated>2019-05-18T16:04:05.169Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在学习javaSE，其中印象最深的一句话便是“java中一切皆对象”；那么数组作为一种源自C语言的数据结构，在java中它也是对象吗？</p></blockquote><h1 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h1><p>这个疑问主要源自对以下代码的疑问：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">int size = arr.length; #得到数组长度</span><br></pre></td></tr></table></figure><p>数组居然存在length这个属性，这很明显是对象才具有的特性。同时，数组也排除于8大基本数组类型之外，《java核心卷一》中对数组的定义是：一个数据容器，用来存储相同数据类型的数据集合。</p><h1 id="相应解释"><a href="#相应解释" class="headerlink" title="相应解释"></a>相应解释</h1><p>通过万能的Google，让我找到了一篇博文<a href="https://blog.csdn.net/zhangjg_blog/article/details/16116613#t4" target="_blank" rel="noopener">Java中数组的特性</a> ,恰到好处地诠释了这个问题，现总结如下：</p><ul><li>可以认定，java中的数组也是对象，它具有java中其他对象的一些基本特点：封装了一些数据，可以访问属性，也可以调用方法。所以，数组是对象。</li><li>数组也是有类型的，例如<code>int[]</code>的类型是<code>[I</code>，<code>String []</code>的类型是<code>[[Ljava.lang.String</code>等。但是我们没有自己创建这个类，也没有在Java的标准库中找到这个类，这只能有一个解释，那就是<strong>虚拟机自动创建了数组类型</strong></li><li>数组的顶层父类为<code>Object</code>，虽然存在<code>Object[] = 引用数据类型[]</code>，这仅说明<code>引用数据类型[]</code><strong>不继承自Object[]，但是我可以允许你向上转型到Object[]，这种特性是赋予你的一项特权</strong>。换一种思考方式，<strong>如果有两个类A和B，如果B继承（extends）了A，那么A[]类型的引用就可以指向B[]类型的对象。</strong>这种情况同样适用于多维数组，因为我们可以将<strong>n维数组</strong>看做<strong>一维数组</strong>中存放着<strong>(n-1)维数组</strong></li></ul><p><em>几个易错点</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object[] objArr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]; </span><br><span class="line"><span class="comment">//错误因为int不是引用类型，Object不是int的父类，在这里自动装箱不起作用</span></span><br><span class="line"></span><br><span class="line">Object[] objArr2 = &#123;<span class="string">"aaa"</span>, <span class="number">1</span>, <span class="number">2.5</span>&#125;;</span><br><span class="line"><span class="comment">//这种情况下自动装箱可以工作，也就是说，Object数组中可以存放任何值，包括基本数据类型。</span></span><br><span class="line"><span class="comment">//这种特性主要是用于方法中多个参数的传递，方便方法内部访问或遍历数组中的各个元素</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;最近在学习javaSE，其中印象最深的一句话便是“java中一切皆对象”；那么数组作为一种源自C语言的数据结构，在java中它也是对象吗？&lt;/p&gt;&lt;/blockquote&gt;&lt;h1 id=&quot;提出问题&quot;&gt;&lt;a href=&quot;#提出问题&quot; class=&quot;he
      
    
    </summary>
    
      <category term="java-se" scheme="http://rqsir.github.io/categories/java-se/"/>
    
    
      <category term="数组" scheme="http://rqsir.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>java内存管理 -- 栈 &amp;&amp; 堆 &amp;&amp; 方法区</title>
    <link href="http://rqsir.github.io/2019/04/22/java%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E6%A0%88-%E5%A0%86-%E6%96%B9%E6%B3%95%E5%8C%BA/"/>
    <id>http://rqsir.github.io/2019/04/22/java内存管理-栈-堆-方法区/</id>
    <published>2019-04-21T16:00:00.000Z</published>
    <updated>2019-05-18T16:32:26.740Z</updated>
    
    <content type="html"><![CDATA[<h2 id="“栈”——存储方法及其中的局部变量"><a href="#“栈”——存储方法及其中的局部变量" class="headerlink" title="“栈”——存储方法及其中的局部变量"></a>“栈”——存储方法及其中的局部变量</h2><p>程序由数据和方法组成，而它们都可以用地址指代。栈便是存储这些地址的地方。</p><ul><li>栈中的内存是以方法为单位进行划分的，方法调用结束后，内存回收。</li><li>我们在栈中调用某个方法，首先先开辟一块栈内存区，内存区的开头存储的是被调用方法地址，其他内存空间用于存储方法中的局部变量地址。然后<code>cpu</code>通过方法的地址，到方法区查找并执行对应代码。遇到变量，则存储在之前的栈内存中；遇到方法，则在栈中开辟新的内存空间。</li><li>方法之间的调用是以“栈”的形式体现的，即“被调用”的方法，后入栈，先出栈。</li></ul><h2 id="“堆”——存储New出来的对象"><a href="#“堆”——存储New出来的对象" class="headerlink" title="“堆”——存储New出来的对象"></a>“堆”——存储New出来的对象</h2><p>由<code>JVM</code>的垃圾回收机制进行管理，空闲时回收</p><h2 id="“方法区”——存储方法代码"><a href="#“方法区”——存储方法代码" class="headerlink" title="“方法区”——存储方法代码"></a>“方法区”——存储方法代码</h2><p>在java中，方法区一般存储着class文件，而方法则包含在相应的class中</p><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>“堆”和“栈”的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>如上，我们声明并初始化了一个整型数组。其中整型数组 <code>arr</code> 就是“栈”变量，而 <code>new int[3]</code> 属于堆变量。</p><p>“方法区”的例子</p><p>如下图所示，当<code>jvm</code>调用方法时，无论是<code>main</code>方法还是<code>change</code>方法，其都是通过在方法区查找对应class文件中的对应方法，然后将对应代码加载到栈内存，最后由<code>cpu</code>去执行。</p><p><img src="https://raw.githubusercontent.com/RQsir/blog_pic_bed/master/img/81a5cfb3ly1g29bu9wfntj211v0jfq41.jpg?token=AKZRZC5CJQ7VBSBYGVI3KOC4YQIXS" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;“栈”——存储方法及其中的局部变量&quot;&gt;&lt;a href=&quot;#“栈”——存储方法及其中的局部变量&quot; class=&quot;headerlink&quot; title=&quot;“栈”——存储方法及其中的局部变量&quot;&gt;&lt;/a&gt;“栈”——存储方法及其中的局部变量&lt;/h2&gt;&lt;p&gt;程序由数据和方法组成
      
    
    </summary>
    
      <category term="java-se" scheme="http://rqsir.github.io/categories/java-se/"/>
    
    
      <category term="java内存管理" scheme="http://rqsir.github.io/tags/java%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>linux -- 编译JDK源码</title>
    <link href="http://rqsir.github.io/2019/04/19/linux-%E7%BC%96%E8%AF%91JDK%E6%BA%90%E7%A0%81/"/>
    <id>http://rqsir.github.io/2019/04/19/linux-编译JDK源码/</id>
    <published>2019-04-18T16:00:00.000Z</published>
    <updated>2019-05-18T15:56:24.678Z</updated>
    
    <content type="html"><![CDATA[<h2 id="获取JDK源码"><a href="#获取JDK源码" class="headerlink" title="获取JDK源码"></a>获取JDK源码</h2><ul><li>java 8 源代码地址：<a href="http://jdk.java.net/8/" target="_blank" rel="noopener">http://jdk.java.net/8/</a></li><li>java 9 源代码地址：<a href="http://jdk.java.net/java-se-ri/9" target="_blank" rel="noopener">http://jdk.java.net/java-se-ri/9</a></li><li>java 10 源代码地址：<a href="http://jdk.java.net/10/" target="_blank" rel="noopener">http://jdk.java.net/10/</a></li></ul><h2 id="环境构建"><a href="#环境构建" class="headerlink" title="环境构建"></a>环境构建</h2><p><strong>1</strong> <strong>安装相关依赖</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装aptitude（在处理依赖问题上更佳。aptitude 在删除一个包时，会同时删除本身所依赖的包）</span></span><br><span class="line">sudo apt-get install aptitude</span><br><span class="line"><span class="comment">#更新源信息</span></span><br><span class="line">sudo aptitude update</span><br><span class="line"><span class="comment">#安装编译openjdk8所需依赖</span></span><br><span class="line">sudo aptitude install  build-essential libx11-dev libxext-dev libxrender-dev libxtst-dev libxt-dev libcups2-dev libfreetype6-dev libasound2-dev ccache</span><br></pre></td></tr></table></figure><p><strong>2 下载Bootstrap JDK</strong></p><p>一般选择落后一个大版本的JDK作为Bootstrap JDK，这里安装了OpenJDK 7。据说Ubuntu18.04已经去除了openJdk-7的源，所以本次进行了下载后手动安装：</p><pre><code>[openjdk-7-jdk](https://packages.debian.org/experimental/openjdk-7-jdk)[openjdk-7-jre](https://packages.debian.org/experimental/openjdk-7-jre)[openjdk-7-jre-headless](https://packages.debian.org/experimental/openjdk-7-jre-headless)[libjpeg62-turbo](https://packages.debian.org/sid/libjpeg62-turbo)[libfontconfig1](https://packages.debian.org/sid/libfontconfig1)[fontconfig-config](https://packages.debian.org/sid/fontconfig-config)</code></pre><p>下载以上安装包，然后执行命令：</p><p><code>sudo dpkg -i openjdk-7-* libjpeg62-turbo* libfontconfig1* fontconfig-config*</code></p><p>如果在安装过程中报错，则执行以下命令：</p><p><code>sudo apt --fix-broken install</code></p><p><strong>3 切换默认jdk</strong></p><p>update-alternatives是Debian系统中专门维护系统命令链接符的工具，通过它可以很方便的设置系统默认使用哪个命令、哪个软件版本，比如系统中同时安装了open jdk和sun jdk两个版本，而我们又希望系统默认使用sun jdk，通过update-alternatives就可以方便实现管理。</p><p>通过<code>sudo update-alternatives --config java</code>进行java版本切换</p><p><strong>4 安装<code>gcc-4.8</code> 和<code>g++ 4.8</code></strong></p><p>之前使用<code>apt</code> 默认安装了最新的<code>gcc-7</code>，导致jdk编译中语法大量报错，浪费了大量时间进行改错</p><p>第一步：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install gcc-4.8</span><br></pre></td></tr></table></figure><p>第二步：设置默认的gcc版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.8 100</span><br></pre></td></tr></table></figure><p>如果用过此方法配置过多个gcc版本，会看到如下选项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  openjdk update-alternatives --config gcc             </span><br><span class="line">There are 2 choices <span class="keyword">for</span> the alternative gcc (providing /usr/bin/gcc).</span><br><span class="line"></span><br><span class="line">  Selection    Path              Priority   Status</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">  0            /usr/bin/gcc-7     50        auto mode</span><br><span class="line">* 1            /usr/bin/gcc-4.8   20        manual mode</span><br><span class="line">  2            /usr/bin/gcc-7     50        manual mode</span><br><span class="line"></span><br><span class="line">Press &lt;enter&gt; to keep the current choice[*], or <span class="built_in">type</span> selection number:</span><br></pre></td></tr></table></figure><p>按同样的方法配置g++</p><h2 id="配置、编译OpenJDK-8"><a href="#配置、编译OpenJDK-8" class="headerlink" title="配置、编译OpenJDK 8"></a>配置、编译OpenJDK 8</h2><p><strong>1 配置</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bash ./configure --with-target-bits=64 --with-debug-level=slowdebug --<span class="built_in">enable</span>-debug-symbols ZIP_DEBUGINFO_FILES=0</span><br></pre></td></tr></table></figure><p>一般没什么问题，有的话，按照提示进行fix</p><p><strong>2 编译及排错</strong></p><p><em>开始编译</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make all ZIP_DEBUGINFO_FILES=0</span><br></pre></td></tr></table></figure><p><em>排错</em></p><p>错误1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*** This OS is not supported: Linux ethan 4.4.0-133-generic #159~14.04.1-Ubuntu SMP Fri Aug 10 08:17:48 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux</span><br><span class="line">make[5]: *** [check_os_version] 错误 1</span><br><span class="line">make[4]: *** [linux_amd64_compiler2/debug] 错误 2</span><br></pre></td></tr></table></figure><p>解决1</p><p>修改文件 ./hotspot/make/linux/Makefile<br>修改 SUPPORTED_OS_VERSION = 2.4% 2.5% 2.6% 2.7% 为<br>SUPPORTED_OS_VERSION = 2.4% 2.5% 2.6% 2.7% 3% 4%</p><p>错误2</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error: ‘int readdir_r(DIR*, dirent*, dirent**)’ is deprecated [-Werror=deprecated-declarations]</span><br><span class="line">   <span class="keyword">if</span>((status = ::readdir_r(dirp, dbuf, &amp;p)) != 0) &#123;</span><br></pre></td></tr></table></figure><p>解决2</p><p>修改文件vim hotspot/make/linux/makefiles/gcc.make</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Compiler warnings are treated as errors</span><br><span class="line"># WARNINGS_ARE_ERRORS = -Werror</span><br></pre></td></tr></table></figure><p><strong>3 编译成功</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## Finished docs (build time 00:02:28)</span></span><br><span class="line"></span><br><span class="line">----- Build <span class="built_in">times</span> -------</span><br><span class="line">Start 2019-04-15 01:48:49</span><br><span class="line">End   2019-04-15 02:04:07</span><br><span class="line">00:00:30 corba</span><br><span class="line">00:00:24 demos</span><br><span class="line">00:02:28 docs</span><br><span class="line">00:07:24 hotspot</span><br><span class="line">00:00:27 images</span><br><span class="line">00:00:17 jaxp</span><br><span class="line">00:00:26 jaxws</span><br><span class="line">00:03:04 jdk</span><br><span class="line">00:00:01 langtools</span><br><span class="line">00:00:16 nashorn</span><br><span class="line">00:15:18 TOTAL</span><br><span class="line">-------------------------</span><br><span class="line">Finished building OpenJDK <span class="keyword">for</span> target <span class="string">'all'</span></span><br></pre></td></tr></table></figure><p><em>参考资料</em></p><p><a href="https://www.jianshu.com/p/ee7e9176632c" target="_blank" rel="noopener">mac下编译openjdk1.9及集成clion动态调试</a></p><p><a href="https://blog.csdn.net/tjiyu/article/details/53725247" target="_blank" rel="noopener">CentOS上编译OpenJDK8源码 以及 在eclipse上调试HotSpot虚拟机源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;获取JDK源码&quot;&gt;&lt;a href=&quot;#获取JDK源码&quot; class=&quot;headerlink&quot; title=&quot;获取JDK源码&quot;&gt;&lt;/a&gt;获取JDK源码&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;java 8 源代码地址：&lt;a href=&quot;http://jdk.java.net/8/&quot;
      
    
    </summary>
    
      <category term="JVM" scheme="http://rqsir.github.io/categories/JVM/"/>
    
    
      <category term="编译JDK" scheme="http://rqsir.github.io/tags/%E7%BC%96%E8%AF%91JDK/"/>
    
  </entry>
  
  <entry>
    <title>openjdk-8 -- 使用Clion调试源码</title>
    <link href="http://rqsir.github.io/2019/04/19/openjdk-8-%E4%BD%BF%E7%94%A8Clion%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81/"/>
    <id>http://rqsir.github.io/2019/04/19/openjdk-8-使用Clion调试源码/</id>
    <published>2019-04-18T16:00:00.000Z</published>
    <updated>2019-05-18T15:56:56.934Z</updated>
    
    <content type="html"><![CDATA[<h2 id="终端中gdb断点进入源码调试hotspot"><a href="#终端中gdb断点进入源码调试hotspot" class="headerlink" title="终端中gdb断点进入源码调试hotspot"></a>终端中gdb断点进入源码调试hotspot</h2><h3 id="1-编译class"><a href="#1-编译class" class="headerlink" title="1 编译class"></a>1 编译class</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ vim ~/Test.java</span><br><span class="line"><span class="comment"># 输入以下内容</span></span><br><span class="line">public class Test&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello world !"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$ /root/openjdk/build/linux-x86_64-normal-server-slowdebug/jdk/bin/javac Test.java</span><br><span class="line">$ /root/openjdk/build/linux-x86_64-normal-server-slowdebug/jdk/bin/java Test</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><h3 id="2-进入gdb测试"><a href="#2-进入gdb测试" class="headerlink" title="2 进入gdb测试"></a>2 进入gdb测试</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一步，启动gdb</span></span><br><span class="line">$ gdb --args /root/openjdk/build/linux-x86_64-normal-server-slowdebug/jdk/bin/java ~/Test</span><br><span class="line"><span class="comment"># 第二步，设置断点</span></span><br><span class="line">(gdb) <span class="built_in">break</span> init.cpp:95</span><br><span class="line"><span class="comment"># 第三步，开始debug</span></span><br><span class="line">(gdb) run</span><br><span class="line"><span class="comment"># debug会在断点处停止，可以查看断点处代码</span></span><br><span class="line">(gdb) l</span><br><span class="line"><span class="comment"># 最后，退出gdb</span></span><br><span class="line">(gdb) quit</span><br></pre></td></tr></table></figure><p>整个操作如下图所示：</p><p><img src="https://raw.githubusercontent.com/RQsir/blog_pic_bed/master/img/81a5cfb3ly1g2797m7485j21280pj1kx.jpg?token=AKZRZC4ZJT4QO2TTSVDUYOC4YQHTI" alt=""></p><h2 id="在IDE中调试，这里选择Clion"><a href="#在IDE中调试，这里选择Clion" class="headerlink" title="在IDE中调试，这里选择Clion"></a>在IDE中调试，这里选择Clion</h2><h3 id="1-导入项目"><a href="#1-导入项目" class="headerlink" title="1 导入项目"></a>1 导入项目</h3><p>打开clion，选择 <code>File-&gt;ImportProject</code>，选择到 <code>~/ClionProjects/openjdk-8/hotspot</code>作为jvm源码的根目录，这里导入的过程无脑点击<code>next</code>即可</p><p>对于可能遇到的头文件不包含问题，解决如下：</p><p>clion导入源码之后遇到头文件找不到的问题，而实际上这些头文件在源码里面是存在的，只不过在某些源文件里面是以相对路径的方式来搜索，可以在<code>CMakeLists.txt</code>里面添加一些根路径</p><p><img src="https://raw.githubusercontent.com/RQsir/blog_pic_bed/master/img/81a5cfb3ly1g279dsync5j20u30ismzl.jpg?token=AKZRZC4KFQNW6E6SO2KRTKS4YQIJC" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">include_directories(./src/share/vm)</span><br><span class="line">include_directories(./src/cpu/x86/vm)</span><br><span class="line">include_directories(./src/share/vm/precompiled)</span><br><span class="line">include_directories(./src/share/vm/utilities)</span><br></pre></td></tr></table></figure><p>另外，如果某些头文件依然找不到，可以手工导入，然后把导入的头文件加到<br><code>hotspot/src/share/vm/precompiled/precompiled.hpp</code>里，因为大多数源文件都会包含这个源文件</p><p><img src="https://raw.githubusercontent.com/RQsir/blog_pic_bed/master/img/81a5cfb3ly1g279fjj4vrj20rb0fkwgt.jpg?token=AKZRZC5LU33VX2PKH7HLPM24YQIKW" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># include &lt;cstdlib&gt;</span><br><span class="line"># include &lt;cstdint&gt;</span><br><span class="line"># include &quot;register_x86.hpp&quot;</span><br><span class="line"># include &quot;assembler_x86.hpp&quot;</span><br><span class="line"># include &quot;globalDefinitions.hpp&quot;</span><br><span class="line"># include &quot;globalDefinitions_x86.hpp&quot;</span><br><span class="line"># include &quot;assembler_x86.hpp&quot;</span><br><span class="line">#include &lt;stubRoutines_x86.hpp&gt;</span><br></pre></td></tr></table></figure><h3 id="2-配置debug"><a href="#2-配置debug" class="headerlink" title="2 配置debug"></a>2 配置debug</h3><p>右上角，点击<code>Edit Configuration</code></p><p><img src="https://raw.githubusercontent.com/RQsir/blog_pic_bed/master/img/81a5cfb3ly1g279hlchebj21hc0t846l.jpg?token=AKZRZC5TCVLPDXMWLBQ7F4K4YQIMO" alt=""></p><p>进入如下界面，添加Application：jdk-8，<code>Execuable</code>中选择<code>～/CLionProjects/openjdk-9/build/linux-x86_64-normal-serverANDclient-slowdebug/jdk/bin</code></p><p><strong>Before lauch: Activate tool window 下的预build项一定要去掉，我的已经去掉了</strong></p><p><img src="https://raw.githubusercontent.com/RQsir/blog_pic_bed/master/img/81a5cfb3ly1g279keh699j21450p2dhf.jpg?token=AKZRZC776R2WNNKYPMI7R6S4YQINW" alt=""></p><h3 id="3-设置断点，开始debug"><a href="#3-设置断点，开始debug" class="headerlink" title="3 设置断点，开始debug"></a>3 设置断点，开始debug</h3><p><img src="https://raw.githubusercontent.com/RQsir/blog_pic_bed/master/img/81a5cfb3ly1g279yehw2kj21hc0t8457.jpg?token=AKZRZC5LDP5TBBMWU5JBQ4K4YQIPI" alt=""></p><p>断点选在<code>jni.cpp</code>的创建vm处，然后开始debug</p><p>这里如果报错，如下图所示：</p><p><img src="https://raw.githubusercontent.com/RQsir/blog_pic_bed/master/img/81a5cfb3ly1g27a28e1t0j21hc0si0yq.jpg?token=AKZRZCY7IU7HDLQ2JASA2NS4YQIQ4" alt=""></p><p>可以在点击<code>LLDB</code>，输入<code>process handle SIGSEGV --stop=false</code>即可，这里告诉编译器忽略错误</p><p>一般Clion默认使用<code>GDB</code>进行debug，可以根据如下所示进行切换</p><p><img src="https://raw.githubusercontent.com/RQsir/blog_pic_bed/master/img/81a5cfb3ly1g27a8fhmwcj21690s6q5m.jpg?token=AKZRZC5EER7BDTGUWBCXRZ24YQISA" alt=""></p><p>同理，若为<code>GDB</code>的话，点击输入<code>handle SIGSEGV pass noprint nostop</code>即可</p><p>动图如下：</p><p><img src="https://raw.githubusercontent.com/RQsir/blog_pic_bed/master/img/81a5cfb3gy1g27p6zqufpg21ha0s3u0x.gif?token=AKZRZC5BNW3M2BOM6YLD5W24YQITQ" alt=""></p><p><em>参考资料</em></p><p><a href="https://zhuanlan.zhihu.com/p/44654332" target="_blank" rel="noopener">深入jvm内部掌握java线程的运行原理</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;终端中gdb断点进入源码调试hotspot&quot;&gt;&lt;a href=&quot;#终端中gdb断点进入源码调试hotspot&quot; class=&quot;headerlink&quot; title=&quot;终端中gdb断点进入源码调试hotspot&quot;&gt;&lt;/a&gt;终端中gdb断点进入源码调试hotspot&lt;/
      
    
    </summary>
    
      <category term="JVM" scheme="http://rqsir.github.io/categories/JVM/"/>
    
    
      <category term="Clion调试JDK" scheme="http://rqsir.github.io/tags/Clion%E8%B0%83%E8%AF%95JDK/"/>
    
  </entry>
  
  <entry>
    <title>linux -- make install的安装与卸载</title>
    <link href="http://rqsir.github.io/2019/04/13/linux%20--%20make%20install%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8D%B8%E8%BD%BD/"/>
    <id>http://rqsir.github.io/2019/04/13/linux -- make install的安装与卸载/</id>
    <published>2019-04-12T16:00:00.000Z</published>
    <updated>2019-05-18T16:05:38.462Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在ubuntu中安装程序时，并不能总能通过apt等包管理器完成；这时候就不得不通过编译源码，安装二进制程序解决。但如果make install默认安装的话，就会给之后的程序卸载带来隐患；基于这些问题，先记录如下：</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>make install</code> 一般会加上option参数<code>--prefix</code> ,表示安装对应目录。如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make install --prefix=/opt/application</span><br></pre></td></tr></table></figure><p>如果不配置该选项，安装后可执行文件默认放在<code>/usr/local/bin</code>，库文件默认放在<code>/usr/local/lib</code>，配置文件默认放在<code>/usr/local/etc</code>，其它的资源文件放在<code>/usr/local/share</code>，比较凌乱。</p><p>用<code>--prefix</code>选项的另一个好处是方便卸载软件或移植软件；当某个安装的软件不再需要时，只须简单的删除该安装目录，就可以把软件卸载得干干净净；而移植软件只需拷贝整个目录到另外一个机器即可（相同的操作系统下）。</p><h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><ul><li>如果按照上面的操作方式 ，即加上了<code>--prefix</code>参数，那么直接删除对应配置目录，卸载就完成了</li><li>万一在<code>make install</code>时，忘记加上<code>--prefix</code>参数，那么可以采取</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make install &amp; &gt; Log_install</span><br></pre></td></tr></table></figure><p>这样做，会重新覆盖安装，并且将对应的安装信息写入<code>Log_install</code> 文件中。我们只需根据日志文件，删除对应目录的文件，即可完成卸载。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;在ubuntu中安装程序时，并不能总能通过apt等包管理器完成；这时候就不得不通过编译源码，安装二进制程序解决。但如果make install默认安装的话，就会给之后的程序卸载带来隐患；基于这些问题，先记录如下：&lt;/p&gt;&lt;/blockquote&gt;&lt;h
      
    
    </summary>
    
      <category term="linux" scheme="http://rqsir.github.io/categories/linux/"/>
    
    
      <category term="make" scheme="http://rqsir.github.io/tags/make/"/>
    
  </entry>
  
  <entry>
    <title>linux -- 编译命令总结</title>
    <link href="http://rqsir.github.io/2019/04/13/linux-%E7%BC%96%E8%AF%91%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
    <id>http://rqsir.github.io/2019/04/13/linux-编译命令总结/</id>
    <published>2019-04-12T16:00:00.000Z</published>
    <updated>2019-05-18T15:56:37.358Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在平时的linux开发中，特别是非IDE开发 中，总是会或多或少的遇到相关开发命令，特点总结如下：</p></blockquote><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li>编译命令 <code>gcc</code> <code>g++</code></li></ul><p><code>gcc</code>是linux平台中默认的c语言编译命令，<code>g++</code>则是对应c++编译命令</p><ul><li>编译批处理命令<code>make</code></li></ul><p>如果源文件太多，一个一个编译时就会特别麻烦，于是人们想到可以通过批处理来编译源文件，<code>make</code>就是在这样的初衷下诞生的。但<code>make</code>命令有一个不方便的地方，就是你必须自己编辑<code>makefile</code>文件来指导<code>make</code>的编译过程，这在遇到大工程时，难度是不可想象的。</p><p><code>make</code>还支持增量编译，即当我们改变了一小部分的源码文件的时候重新执行<code>make</code>，它将不会重新编译整个程序，而是仅仅更新那些直接或者间接依赖这些改变了的源码文件的非源码文件。</p><ul><li>自动生成<code>makefile</code>的<code>cmake</code></li></ul><p>尽管<code>cmake</code>命令也需要手动编辑<code>CMakeLists.txt</code>文件来指导<code>cmake</code>命令，但相较于 <code>makefile</code>的编辑，难度已大大降低。</p><p>除此之外，<code>cmake</code>还支持跨平台<code>makefile</code>生成。它会自动辨别使用那种编译器去编译给出的源码种类，自动发现跨平台系统库。简而言之，就是<code>cmake</code>可以帮我们解决系统环境相关配置，解决跨平台编译难题。</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>在平时的使用中，基本遵循一下流程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.编辑CMakeLists.txt, 执行cmake &lt;path.CMakeList.txt&gt;, 生成makefile</span></span><br><span class="line">$ cmake ./CMakeLists.txt</span><br><span class="line"><span class="comment"># 2.执行make，进行批量编译</span></span><br><span class="line">$ make</span><br><span class="line"><span class="comment"># 3. 进入可执行文件所在目录，运行</span></span><br><span class="line">$ ./runflie</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;在平时的linux开发中，特别是非IDE开发 中，总是会或多或少的遇到相关开发命令，特点总结如下：&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;分类&quot;&gt;&lt;a href=&quot;#分类&quot; class=&quot;headerlink&quot; title=&quot;分类&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="linux" scheme="http://rqsir.github.io/categories/linux/"/>
    
    
      <category term="编译命令" scheme="http://rqsir.github.io/tags/%E7%BC%96%E8%AF%91%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>linux -- 文件编码与转换</title>
    <link href="http://rqsir.github.io/2019/04/12/linux-%E6%96%87%E4%BB%B6%E7%BC%96%E7%A0%81%E4%B8%8E%E8%BD%AC%E6%8D%A2/"/>
    <id>http://rqsir.github.io/2019/04/12/linux-文件编码与转换/</id>
    <published>2019-04-11T16:00:00.000Z</published>
    <updated>2019-05-18T15:56:00.939Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用vim进行文档识别（不改变编码）"><a href="#使用vim进行文档识别（不改变编码）" class="headerlink" title="使用vim进行文档识别（不改变编码）"></a>使用vim进行文档识别（不改变编码）</h2><p>由于windows系统普遍采用GBK编码，这样导致在windows上编辑的文本转移到采用utf-8编码的linux上后，容易出现乱码现象。</p><p><img src="https://raw.githubusercontent.com/RQsir/blog_pic_bed/master/img/81a5cfb3ly1g1xwmaibbyj20ok0ilqj0.jpg?token=AKZRZC6DBIXC4LJKZTLRWB24YQHKC" alt=""></p><p>其中的原因是，GBK编码的文件在linux上以utf-8进行解码，会出错。</p><p>于是，接下来打算在vim中以fileencodings的方式进行尝试解码，然后用vim的utf-8缓存编码进行显示</p><p>操作如下：</p><p>1.打开vimrc文件，没有则新建</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim ~/.vimrc</span><br></pre></td></tr></table></figure><p>2.在vimrc中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set encoding=utf-8</span><br><span class="line">set fileencodings=ucs-bom,utf-8,cp936</span><br></pre></td></tr></table></figure><p><em><u>知识补充</u></em></p><ul><li>vim 中通过底部命令<code>set fileencoding</code>显示当前编辑文件编码</li><li><strong>encoding:</strong> Vim 内部使用的字符编码方式，包括 Vim 的 buffer (缓冲区)、菜单文本、消息文本等。</li><li><strong>fileencoding:</strong> Vim 中当前编辑的文件的字符编码方式，Vim 保存文件时也会将文件保存为这种字符编码方式 (不管是否新文件都如此)。</li><li><strong>fileencodings</strong>: Vim自动探测fileencoding的顺序列表，启动时会按照它所列出的字符编码方式逐一探测即将打开的文件的字符编码方式，并且将 fileencoding 设置为最终探测到的字符编码方式。</li><li><strong>ermencoding</strong>: Vim 所工作的终端 (或者 Windows 的 Console 窗口) 的字符编码方式。如果vim所在的term与vim编码相同，则无需设置。如其不然，你可以用vim的termencoding选项将自动转换成term 的编码.这个选项在 Windows 下对我们常用的 GUI 模式的 gVim 无效，而对 Console 模式的Vim 而言就是 Windows 控制台的代码页，并且通常我们不需要改变它。</li></ul><h2 id="使用iconv进行编码转换"><a href="#使用iconv进行编码转换" class="headerlink" title="使用iconv进行编码转换"></a>使用iconv进行编码转换</h2><p>经过尝试，在vim中，通过底部命令<code>set fileencoding=utf-8</code>，即使将原GBK（也称cp936）编码的文档转码为utf-8，在vim中显示也依然存在乱码现象。</p><p>问题分析：这种原因可能是在vim中<code>set fileencoding=utf-8</code> 仅仅是改变了文档编码标志，并未真正改变其编码。</p><p>基予此，采用iconv进行转码操作。iconv命令是用来转换文件的编码方式的（Convert encoding of given files from one encoding to another），比如它可以将UTF8编码的转换成GB18030的编码，反过来也行。</p><p>命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ iconv -f &#123;&#123;from_encoding&#125;&#125; &#123;&#123;input_file&#125;&#125; &gt; &#123;&#123;output_file&#125;&#125;</span><br></pre></td></tr></table></figure><p>实际上vim的编码自适应显示，底层也是调用了<code>iconv</code>命令</p><p><img src="https://raw.githubusercontent.com/RQsir/blog_pic_bed/master/img/81a5cfb3ly1g1xwiqu5e7j20oa01udgb.jpg?token=AKZRZC6VXNB4YQL6OBYAUPC4YQHLW" alt=""></p><p><img src="https://raw.githubusercontent.com/RQsir/blog_pic_bed/master/img/81a5cfb3ly1g1xwjzn36rj20o40iqwof.jpg?token=AKZRZCYSYMDIDCXGRCN3D324YQHM6" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;使用vim进行文档识别（不改变编码）&quot;&gt;&lt;a href=&quot;#使用vim进行文档识别（不改变编码）&quot; class=&quot;headerlink&quot; title=&quot;使用vim进行文档识别（不改变编码）&quot;&gt;&lt;/a&gt;使用vim进行文档识别（不改变编码）&lt;/h2&gt;&lt;p&gt;由于wind
      
    
    </summary>
    
      <category term="linux" scheme="http://rqsir.github.io/categories/linux/"/>
    
    
      <category term="文件乱码" scheme="http://rqsir.github.io/tags/%E6%96%87%E4%BB%B6%E4%B9%B1%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>linux -- 软链接和硬链接</title>
    <link href="http://rqsir.github.io/2019/04/12/linux-%E8%BD%AF%E9%93%BE%E6%8E%A5%E5%92%8C%E7%A1%AC%E9%93%BE%E6%8E%A5/"/>
    <id>http://rqsir.github.io/2019/04/12/linux-软链接和硬链接/</id>
    <published>2019-04-11T16:00:00.000Z</published>
    <updated>2019-05-18T15:56:47.066Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文件名和数据"><a href="#文件名和数据" class="headerlink" title="文件名和数据"></a>文件名和数据</h2><p>文件名与数据，这在 Linux 上被分成两个部分：用户数据 (user data) 与元数据 (metadata)。如下所示：</p><p><img src="https://raw.githubusercontent.com/RQsir/blog_pic_bed/master/img/image001.jpg" alt=""></p><p>用户数据，即文件数据块（data block），是真正记录数据的地方；而元数据（metadata）是记录文件相关属性（如文件名、文件大小、索引节点inode）的地方。并且实际上，linux系统是通过inode进行文件查找等相关操作的。文件名主要是为了方便用户对文件的识记。</p><p>显示inode节点可以使用<code>stat</code>或<code>ls -i</code>命令</p><p><img src="https://raw.githubusercontent.com/RQsir/blog_pic_bed/master/img/81a5cfb3ly1g1zkal7avzj20p306xdm9.jpg?token=AKZRZC6Y6ZGLYL2G6G4QUDC4YQHGM" alt=""></p><h2 id="硬链接与软链接"><a href="#硬链接与软链接" class="headerlink" title="硬链接与软链接"></a>硬链接与软链接</h2><p>为解决文件共享，引入了软硬链接。链接为 Linux 系统解决了文件的共享使用，还带来了隐藏文件路径、增加权限安全及节省存储等好处。</p><p><strong>硬链接</strong> 硬链接文件除了文件名与所指向文件不同外，其余全部相同，即原被链接文件inode对应多个文件名。通过如下方式创建硬链接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ link oldfile hard.link</span><br></pre></td></tr></table></figure><p>特点如下：</p><ul><li>文件有相同的 inode 及 data block；</li><li>只能对已存在的文件进行创建；</li><li>不能交叉文件系统进行硬链接的创建；</li><li>不能对目录进行创建，只可对文件创建；</li><li>删除一个硬链接文件并不影响其他有相同 inode 号的文件。</li></ul><p><strong>软链接</strong> 就是一个普通文件，只是数据块内容写有指向文件的inode信息。软链接也有自己的 inode 号以及用户数据块。通过如下方式创建软链接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ln -s old.file soft.link</span><br></pre></td></tr></table></figure><p>特点如下：</p><ul><li>软链接有自己的文件属性及权限等；</li><li>可对不存在的文件或目录创建软链接；</li><li>软链接可交叉文件系统；</li><li>软链接可对文件或目录创建；</li><li>创建软链接时，链接计数 i_nlink 不会增加；</li><li>删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接（即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接）。</li></ul><h2 id="链接相关命令使用"><a href="#链接相关命令使用" class="headerlink" title="链接相关命令使用"></a>链接相关命令使用</h2><p>find 命令，其不仅可查找某文件的软链接，还可以用于查找相同 inode 的所有硬链接。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 查找目录下文件的软链接</span><br><span class="line">$ find &lt;directory&gt; -lname &lt;file&gt;</span><br><span class="line"></span><br><span class="line">// 查找目录下文件的硬链接</span><br><span class="line">$ find &lt;directory&gt; -samefile &lt;file&gt;</span><br><span class="line">or</span><br><span class="line">$ find &lt;directory&gt; -inum &lt;inode&gt;</span><br><span class="line"></span><br><span class="line">// 列出目录下所有的软链接</span><br><span class="line">$ find &lt;directory&gt; -<span class="built_in">type</span> l -ls</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;文件名和数据&quot;&gt;&lt;a href=&quot;#文件名和数据&quot; class=&quot;headerlink&quot; title=&quot;文件名和数据&quot;&gt;&lt;/a&gt;文件名和数据&lt;/h2&gt;&lt;p&gt;文件名与数据，这在 Linux 上被分成两个部分：用户数据 (user data) 与元数据 (metada
      
    
    </summary>
    
      <category term="linux" scheme="http://rqsir.github.io/categories/linux/"/>
    
    
      <category term="软链接和硬链接" scheme="http://rqsir.github.io/tags/%E8%BD%AF%E9%93%BE%E6%8E%A5%E5%92%8C%E7%A1%AC%E9%93%BE%E6%8E%A5/"/>
    
  </entry>
  
  <entry>
    <title>百度anyQ -- 编译错误</title>
    <link href="http://rqsir.github.io/2019/04/10/%E7%99%BE%E5%BA%A6anyQ-%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF/"/>
    <id>http://rqsir.github.io/2019/04/10/百度anyQ-编译错误/</id>
    <published>2019-04-09T16:00:00.000Z</published>
    <updated>2019-05-18T15:57:25.034Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>偶然在github上发现了百度的anyQ智能对话框架，刚好自己也在研究这一块，遂决定重现一下这个模型。中途遇到不少编译错误，现记录下来</p></blockquote><h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><p>执行<code>mkdir build &amp;&amp; cd build &amp;&amp; cmake .. &amp;&amp; make</code> 后报错如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/home/AnyQ/build/third_party/include/dmlc/./logging.h:323:31: error: ‘DMLC_LOG_STACK_TRACE_SIZE’ was not declared <span class="keyword">in</span> this scope</span><br><span class="line">make[2]: *** [third_party/paddle/src/extern_paddle-stamp/extern_paddle-build] Error 2</span><br><span class="line">make[1]: *** [CMakeFiles/extern_paddle.dir/all] Error 2</span><br><span class="line">make: *** [all] Error 2</span><br></pre></td></tr></table></figure><p>解决方法：</p><ul><li>首先将原官方<code>https://github.com/baidu/AnyQ.git</code> 替换为 <code>https://github.com/ljch2018/AnyQ.git</code></li><li>然后修改如下两个文件，使之以单线程编译即可</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xgboost.cmake：</span><br><span class="line">INSTALL_COMMAND cd $&#123;XGBOOST_INSTALL_DIR&#125; &amp;&amp; make -j1</span><br><span class="line">paddle.cmake</span><br><span class="line">BUILD_COMMAND cd $&#123;PADDLE_INSTALL_DIR&#125; &amp;&amp; make -j1</span><br></pre></td></tr></table></figure><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><p><strong>尽量使用官方的docker镜像，避免不必用的环境问题</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># paddle官方镜像</span></span><br><span class="line">docker pull paddlepaddle/paddle:latest-dev</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;偶然在github上发现了百度的anyQ智能对话框架，刚好自己也在研究这一块，遂决定重现一下这个模型。中途遇到不少编译错误，现记录下来&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;错误&quot;&gt;&lt;a href=&quot;#错误&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="智能对话系统" scheme="http://rqsir.github.io/categories/%E6%99%BA%E8%83%BD%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="anyQ" scheme="http://rqsir.github.io/tags/anyQ/"/>
    
  </entry>
  
</feed>
